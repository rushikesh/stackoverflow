[{"t":":: (double colon) operator in Java 8","l":"http://stackoverflow.com/questions/20001427/double-colon-operator-in-java-8","q":"\n\n<p>I was exploring the Java 8 source and found this particular part of code very surprising:</p>\n\n<pre><code>//defined in IntPipeline.java\n@Override\npublic final OptionalInt reduce(IntBinaryOperator op) {\n    return evaluate(ReduceOps.makeInt(op));\n}\n\n@Override\npublic final OptionalInt max() {\n    return reduce(Math::max); //this is the gotcha line\n}\n\n//defined in Math.java\npublic static int max(int a, int b) {\n    return (a &gt;= b) ? a : b;\n}\n</code></pre>\n\n<p>Is <code>Math::max</code> something like a method pointer? How does a normal <code>static</code> method get converted to <code>IntBinaryOperator</code>?</p>\n    ","a":"\n<p>Usually, one would call the <code>reduce</code> method using <code>Math.max(int, int)</code> as follows:</p>\n\n<pre><code>reduce(new IntBinaryOperator() {\n    int applyAsInt(int left, int right) {\n        return Math.max(left, right);\n    }\n});\n</code></pre>\n\n<p>Now that requires lot of syntax for just calling <code>Math.max</code>. That's where lambda expressions come into play. Since Java 8 it is allowed to do the same thing in a much shorter way:</p>\n\n<pre><code>reduce( (int left, int right) -&gt; Math.max(left, right) );\n</code></pre>\n\n<p>How does this work? The java compiler \"detects\", that you want to implement a method that accepts two <code>int</code>s and returns one <code>int</code>. This is equivalent to the formal parameters of the one and only method of interface <code>IntBinaryOperator</code> (the parameter of method <code>reduce</code> you wanna call). So the compiler does the rest for you - it just assumes you want to implement <code>IntBinaryOperator</code>.</p>\n\n<p>But as <code>Math.max(int, int)</code> itself fulfills the formal requirements of <code>IntBinaryOperator</code>, it can be used directly. Now java does not have any syntax that allows a method itself to be passed as an argument (you can only pass method results, but never methods itself), the <code>::</code> syntax was introduced in Java 8 to reference methods:</p>\n\n<pre><code>reduce(Math::max);\n</code></pre>\n\n<p>Note that this will be interpreted by the compiler, not by the JVM at runtime! Although it produces different bytecodes for all three code snippets, they are semantically equal, so the last two can be considered to be short (and probably more efficient) versions of the <code>IntBinaryOperator</code> implementation above!</p>\n\n<p>(See also <a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html\">Translation of Lambda Expressions</a>)</p>\n    "},{"t":"Is it possible to use Java 8 for Android development?","l":"http://stackoverflow.com/questions/23318109/is-it-possible-to-use-java-8-for-android-development","q":"\n\n<p>Searching the web, it is not clear if Java 8 is supported for Android development or not.</p>\n\n<p>Before I download/setup Java 8, can some one point me at any \"official\" documentation that say Java 8 is or is not supported for Android development.</p>\n    ","a":"\n<p>I think it is too early to say if Java 8 is suitable for android development, officially android needs the Java 6 JDK as mentioned at the bottom of this page: <a href=\"https://developer.android.com/sdk/installing/installing-adt.html\">https://developer.android.com/sdk/installing/installing-adt.html</a></p>\n\n<p>If you installed the Java 8 JDK, then give it a try, if any problems appears try to set the compiler as 1.6 in eclipse from window menu -&gt; preferences -&gt; java -&gt; Compiler</p>\n\n<p>by the way, this is works for me with java 7</p>\n\n<p><img src=\"http://i.stack.imgur.com/SCTyV.png\" alt=\"enter image description here\"> </p>\n\n<h1>Update:</h1>\n\n<p>To build apps for android 5.0 and higher, JDK 7 is required.\nThis is according to Installing Android Studio webpage:\n<a href=\"http://developer.android.com/sdk/installing/index.html?pkg=studio\">http://developer.android.com/sdk/installing/index.html?pkg=studio</a></p>\n\n<p>\"Before you set up Android Studio, be sure you have installed JDK 6 or higher (the JRE alone is not sufficient)—JDK 7 is required when developing for Android 5.0 and higher. To check if you have JDK installed (and which version), open a terminal and type javac -version. If the JDK is not available or the version is lower than 6, go download JDK.\"</p>\n    "},{"t":"Why is “final” not allowed in Java 8 interface methods?","l":"http://stackoverflow.com/questions/23453287/why-is-final-not-allowed-in-java-8-interface-methods","q":"\n\n<p>One of the most useful features of Java 8 are the new <code>default</code> methods on interfaces. There are essentially two reasons (there may be others) why they have been introduced:</p>\n\n<ul>\n<li>Providing actual default implementations. Example: <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#remove--\"><code>Iterator.remove()</code></a></li>\n<li>Allowing for JDK API evolution. Example: <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html#forEach-java.util.function.Consumer-\"><code>Iterable.forEach()</code></a></li>\n</ul>\n\n<p>From an API designer's perspective, I would have liked to be able to use other modifiers on interface methods, e.g. <code>final</code>. This would be useful when adding convenience methods, preventing \"accidental\" overrides in implementing classes:</p>\n\n<pre><code>interface Sender {\n\n    // Convenience method to send an empty message\n    default final void send() {\n        send(null);\n    }\n\n    // Implementations should only implement this method\n    void send(String message);\n}\n</code></pre>\n\n<p>The above is already common practice if <code>Sender</code> were a class:</p>\n\n<pre><code>abstract class Sender {\n\n    // Convenience method to send an empty message\n    final void send() {\n        send(null);\n    }\n\n    // Implementations should only implement this method\n    abstract void send(String message);\n}\n</code></pre>\n\n<p>Now, <code>default</code> and <code>final</code> are obviously contradicting keywords, but the default keyword itself <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-August/005393.html\">would not have been strictly required</a>, so I'm assuming that this contradiction is deliberate, to reflect the subtle differences between <em>\"class methods with body\"</em> (just methods) and <em>\"interface methods with body\"</em> (default methods), i.e. differences which I have not yet understood.</p>\n\n<p>At some point of time, support for modifiers like <code>static</code> and <code>final</code> on interface methods was not yet fully explored, <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2011-December/004430.html\">citing Brian Goetz</a>:</p>\n\n<blockquote>\n  <p>The other part is how far we're going to go to support class-building \n  tools in interfaces, such as final methods, private methods, protected \n  methods, static methods, etc.  The answer is: we don't know yet</p>\n</blockquote>\n\n<p>Since that time in late 2011, obviously, support for <code>static</code> methods in interfaces was added. Clearly, this added a lot of value to the JDK libraries themselves, such as with <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparing-java.util.function.Function-\"><code>Comparator.comparing()</code></a>.</p>\n\n<h3>Question:</h3>\n\n<p>What is the reason <code>final</code> (and also <code>static final</code>) never made it to Java 8 interfaces?</p>\n    ","a":"\n<p>This question is, to some degree, related to <a href=\"http://stackoverflow.com/questions/23453568/what-is-the-reason-why-synchronized-is-not-allowed-in-java-8-interface-methods/23463334#23463334\">What is the reason why “synchronized” is not allowed in Java 8 interface methods?</a></p>\n\n<p>The key thing to understand about default methods is that the primary design goal is <em>interface evolution</em>, not \"turn interfaces into (mediocre) traits\".  While there's some overlap between the two, and we tried to be accomodating to the latter where it didn't get in the way of the former, these questions are best understood when viewed in this light.  (Note too that class methods <em>are</em> going to be different from interface methods, no matter what the intent, by virtue of the fact that interface methods can be multiply inherited.)</p>\n\n<p>The basic idea of a default method is: it is an interface method with a default implementation, and a derived class can provide a more specific implementation.  And because the design center was interface evolution, it was a critical design goal that default methods be able to be added to interfaces <em>after the fact</em> in a source-compatible and binary-compatible manner.  </p>\n\n<p>The too-simple answer to \"why not final default methods\" is that then the body would then not simply be the default implementation, it would be the only implementation.  While that's a little too simple an answer, it gives us a clue that the question is already heading in a questionable direction.</p>\n\n<p>Another reason why final interface methods are questionable is that they create impossible problems for implementors.  For example, supposing you have:</p>\n\n<pre><code>interface A { \n    default void foo() { ... }\n}\n\ninterface B { \n}\n\nclass C implements A, B { \n}\n</code></pre>\n\n<p>Here, everything is good; C inherits foo() from A.  Now supposing B is changed to have a foo method, with a default:</p>\n\n<pre><code>interface B { \n    default void foo() { ... }\n}\n</code></pre>\n\n<p>Now, when we go to recompile C, the compiler will tell us that it doesn't know what behavior to inherit for <code>foo()</code>, so C has to override it (and could choose to delegate to <code>A.super.foo()</code> if it wanted to retain the same behavior.)  But what if B had made its default final, and A is not under the control of the author of C?  Now C is irretrievably broken; it can't compile without overriding <code>foo()</code>, but it can't override <code>foo()</code> if it was final in <code>B</code>.  </p>\n\n<p>This is just one example, but the point is that final methods are really a tool that makes more sense in the world of single-inheritance classes (generally which couple state to behavior), than to interfaces which merely contribute behavior and can be multiply inherited.  It's too hard to reason about \"what other interfaces might be mixed into the eventual implementor\", and allowing an interface method to be final would likely cause these problems (and they would blow up not on the person who wrote the interface, but on the poor user who tries to implement it.)  </p>\n\n<p>Another reason to disallow them is that they wouldn't mean what you think they mean.  A default implementation is only considered if the class (or its superclasses) don't provide a declaration (concrete or abstract) of the method.  If a default method were final, but a superclass already implemented the method, the default would be ignored, which is probably not what the default author was expecting when declaring it final.  (This inheritance behavior is a reflection of the design center for default methods -- interface evolution.  It should be possible to add a default method (or a default implementation to an existing interface method) to existing interfaces that already have implementations, without changing the behavior of existing classes that implement the interface, guaranteeing that classes that already worked before default methods were added will work the same way in the presence of default methods.)</p>\n    "},{"t":"What is the reason why “synchronized” is not allowed in Java 8 interface methods?","l":"http://stackoverflow.com/questions/23453568/what-is-the-reason-why-synchronized-is-not-allowed-in-java-8-interface-methods","q":"\n\n<p>In Java 8, I can easily write: </p>\n\n<pre><code>interface Interface1 {\n    default void method1() {\n        synchronized (this) {\n            // Something\n        }\n    }\n\n    static void method2() {\n        synchronized (Interface1.class) {\n            // Something\n        }\n    }\n}\n</code></pre>\n\n<p>I will get the full synchronisation semantics that I can use also in classes. I cannot, however, use the <code>synchronized</code> modifier on method declarations:</p>\n\n<pre><code>interface Interface2 {\n    default synchronized void method1() {\n        //  ^^^^^^^^^^^^ Modifier 'synchronized' not allowed here\n    }\n\n    static synchronized void method2() {\n        // ^^^^^^^^^^^^ Modifier 'synchronized' not allowed here\n    }\n}\n</code></pre>\n\n<p>Now, one can argue that the two interfaces behave the same way except that <code>Interface2</code> establishes a <em>contract</em> on <code>method1()</code> and on <code>method2()</code>, which is a bit stronger than what <code>Interface1</code> does. Of course, we might also argue that <code>default</code> implementations should not make any assumptions about concrete implementation state, or that such a keyword simply wouldn't pull its weight.</p>\n\n<h3>Question:</h3>\n\n<p>What is the reason why the JSR-335 expert group decided not to support <code>synchronized</code> on interface methods?</p>\n\n<hr>\n\n<p><strong>Note, before this question is eagerly closed</strong>: To fit Stack Overflow's Q&amp;A format: I'm looking for authoritative citations only, not speculation. An authoritative answer to this question will likely help many future visitors of this question, so please <em>do not close it eagerly</em>.</p>\n    ","a":"\n<p>This was a deliberate decision, rather than an omission (as has been suggested elsewhere.)  While at first it might seem obvious that one would want to support the <code>synchronized</code> modifier on default methods, it turns out that doing so would be dangerous, and so was prohibited.  </p>\n\n<p>Synchronized methods are a shorthand for a method which behaves as if the entire body is enclosed in a <code>synchronized</code> block whose lock object is the receiver.  It might seem sensible to extend this semantics to default methods as well; after all, they are instance methods with a receiver too.  (Note that <code>synchronized</code> methods are entirely a syntactic optimization; they're not needed, they're just more compact than the corresponding <code>synchronized</code> block.  There's a reasonable argument to be made that this was a premature syntactic optimization in the first place, and that synchronized methods cause more problems than they solve, but that ship sailed a long time ago.)  </p>\n\n<p>So, why are they dangerous?  Synchronization is about locking.  Locking is about coordinating shared access to mutable state.  Each object should have a synchronization policy that determines which locks guard which state variables.  (See <a href=\"http://amzn.to/1jyE5Kx\">Java Concurrency in Practice</a>, section 2.4.)  </p>\n\n<p>Many objects use as their synchronization policy the <em>Java Monitor Pattern</em> (JCiP 4.1), in which an object's state is guarded by its intrinsic lock.  There is nothing magic or special about this pattern, but it is convenient, and the use of the <code>synchronized</code> keyword on methods implicitly assumes this pattern.  </p>\n\n<p>It is the class that owns the state that gets to determine that object's synchronization policy.  But interfaces do not own the state of the objects into which they are mixed in.  So using a synchronized method in an interface assumes a particular synchronization policy, but one which you have no reasonable basis for assuming, so it might well be the case that the use of synchronization provides no additional thread safety whatsoever (you might be synchronizing on the wrong lock).  This would give you the false sense of confidence that you have done something about thread safety, and no error message tells you that you're assuming the wrong synchronization policy.  </p>\n\n<p>It is already hard enough to consistently maintain a synchronization policy for a single source file; it is even harder to ensure that a subclass correctly adhere to the synchronization policy defined by its superclass.  Trying to do so between such loosely coupled classes (an interface and the possibly many classes which implement it) would be nearly impossible and highly error-prone.  </p>\n\n<p>Given all those arguments against, what would be the argument for?  It seems they're mostly about making interfaces behave more like traits.  While this is an understandable desire, the design center for default methods is interface evolution, not \"Traits--\".  Where the two could be consistently achieved, we strove to do so, but where one is in conflict with the other, we had to choose in favor of the primary design goal.  </p>\n    "},{"t":"Why is Cloneable not deprecated?","l":"http://stackoverflow.com/questions/26398951/why-is-cloneable-not-deprecated","q":"\n\n<p>It is commonly understood that <code>Cloneable</code> interface in Java is broken. There are many reasons for this, which I will not mention; <a href=\"http://howtodoinjava.com/2012/11/10/cloneable-interface-is-broken-in-java/\">others</a> already did it. It is also the position of <a href=\"http://www.artima.com/intv/bloch13.html\">Java architects</a> themselves.</p>\n\n<p>My question is therefore: why has is not been deprecated yet? If the core Java team have decided that it is broken, then they must also have considered deprecation. What are their reasons against doing so (in Java 8 it is <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html\">still not deprecated</a>)? </p>\n    ","a":"\n<p>There is a <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4098033\">bug</a> submitted in 1997 to <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4098033\">Java Bug Database</a> about adding <code>clone()</code> method to <code>Cloneable</code>, so it would no longer be useless. It was closed with resolution \"won't fix\" and justification was as follows:</p>\n\n<blockquote>\n  <p>Sun's Technical Review Committee (TRC) considered this issue at length\n  and recommended against taking <strong>any action other than improving the\n  documentation of the current Cloneable interface</strong>.  Here is the full\n  text of the recommendation:</p>\n  \n  <p>The existing Java object cloning APIs are problematic.  There is a\n  protected \"clone\" method on java.lang.Object and there is an interface\n  java.lang.Cloneable.  The intention is that if a class wants to allow\n  other people to clone it, then it should support the Cloneable\n  interface and override the default protected clone method with a\n  public clone method.  Unfortunately, for reasons conveniently lost in\n  the mists of time, the Cloneable interface does not define a clone\n  method.</p>\n  \n  <p>This combination results in a fair amount of confusion.  Some classes\n  claim to support Cloneable, but accidentally forget to support the\n  clone method.  Developers are confused about how Cloneable is supposed\n  to work and what clone is supposed to do.</p>\n  \n  <p>Unfortunately, adding a \"clone\" method to Cloneable would be an\n  incompatible change.  It won't break binary compatibility, but it will\n  break source compatibility.  Anecdotal evidence suggests that in\n  practice there are a number of cases where classes support the\n  Cloneable interface but fail to provide a public clone method.  After\n  discussion, TRC unanimously recommended that we should NOT modify the\n  existing Cloneable interface, because of the compatibility impact.</p>\n  \n  <p>An alternative proposal was to add a new interface\n  java.lang.PubliclyCloneable to reflect the original intended purpose\n  of Cloneable.  By a 5 to 2 majority, TRC recommended against this. \n  The main concern was that this would add yet more confusion (including\n  spelling confusion!) to an already confused picture.</p>\n  \n  <p><strong>TRC unanimously recommended that we should add additional\n  documentation to the existing Cloneable interface</strong> to better describe\n  how it is intended to be used and to describe \"best practices\" for\n  implementors.</p>\n</blockquote>\n\n<p>So, although this is not directly about <em>deprecated</em>, the reason for not making Cloneable \"deprecated\" is that Technical Review Comitee decided that <strong>modifying existing documentation will be sufficient enough</strong> to make this interface useful. And so they did. Until Java 1.4, <code>Cloneable</code> was documented as follows:</p>\n\n<blockquote>\n  <p>A class implements the Cloneable interface to indicate to the\n  Object.clone() method that it is legal for that method to make a\n  field-for-field copy of instances of that class. </p>\n  \n  <p>Attempts to clone instances that do not implement the Cloneable\n  interface result in the exception CloneNotSupportedException being\n  thrown. </p>\n  \n  <p>The interface Cloneable declares no methods.</p>\n</blockquote>\n\n<p>Since Java 1.4 (which was released in February 2002) up to current edition (Java 8) it looks like this:</p>\n\n<blockquote>\n  <p>A class implements the Cloneable interface to indicate to the\n  Object.clone() method that it is legal for that method to make a\n  field-for-field copy of instances of that class.  Invoking Object's\n  clone method on an instance that does not implement the Cloneable\n  interface results in the exception CloneNotSupportedException being\n  thrown. </p>\n  \n  <p>By convention, classes that implement this interface should override\n  Object.clone (which is protected) with a public method. See\n  Object.clone() for details on overriding this method. </p>\n  \n  <p>Note that this interface does not contain the clone method. Therefore,\n  it is not possible to clone an object merely by virtue of the fact\n  that it implements this interface. Even if the clone method is invoked\n  reflectively, there is no guarantee that it will succeed.</p>\n</blockquote>\n    "},{"t":"Retrieving a List from a java.util.stream.Stream in Java8","l":"http://stackoverflow.com/questions/14830313/retrieving-a-list-from-a-java-util-stream-stream-in-java8","q":"\n\n<p>I was playing around with Java 8 lambdas to easily filter collections. But I did not find a concise way to retrieve the result as a new list within the same statement. Here is my most concise approach so far:</p>\n\n<pre><code>List&lt;Long&gt; sourceLongList = Arrays.asList(1L, 10L, 50L, 80L, 100L, 120L, 133L, 333L);\nList&lt;Long&gt; targetLongList = new ArrayList&lt;&gt;();\nsourceLongList.stream().filter(l -&gt; l &gt; 100).forEach(targetLongList::add);\n</code></pre>\n\n<p>Examples on the net did not answer my question because they stop without generating a new result list. There must be a more concise way. I would have expected, that the Stream class has methods as toList(), toSet(), ...</p>\n\n<p>Is there a way that the variables <em>targetLongList</em> can be directly be assigned by the third line?</p>\n    ","a":"\n<p>What you are doing may be the simplest way, provided your stream stays sequential—otherwise you will have to put a call to sequential() before <code>forEach</code>. </p>\n\n<p>[later edit: the reason the call to sequential() is necessary is that the code as it stands (<code>forEach(targetLongList::add)</code>) would be racy if the stream was parallel. Even then, it will not achieve the effect intended, as <code>forEach</code> is explicitly nondeterministic—even in a sequential stream the order of element processing is not guaranteed. You would have to use <code>forEachOrdered</code> to ensure correct ordering. The intention of the Stream API designers is that you will use collector in this situation, as below.]</p>\n\n<p>An alternative is </p>\n\n<pre><code>targetLongList = sourceLongList.stream()\n    .filter(l -&gt; l &gt; 100)\n    .collect(Collectors.toList());\n</code></pre>\n    "},{"t":"Java 8 Iterable.forEach() vs foreach loop","l":"http://stackoverflow.com/questions/16635398/java-8-iterable-foreach-vs-foreach-loop","q":"\n\n<p>Which of the following is better practice in Java 8?</p>\n\n<p>Java8:</p>\n\n<pre><code>joins.forEach((join) -&gt; mIrc.join(mSession, join));\n</code></pre>\n\n<p>Java7:</p>\n\n<pre><code>for (String join : joins) {\n    mIrc.join(mSession, join);\n}\n</code></pre>\n\n<p>I have lots of for loops that could be \"simplified\" with lambdas, but is there really any advantage of using them including performance and readability?</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>I'll also extend this question to longer methods - I know that you cant return or break the parent function from a lambda and this should be mentioned to if they are compared, but is there anything else to be considered?</p>\n    ","a":"\n<p>The advantage comes into account when the operations can be executed in parallel. (See <a href=\"http://java.dzone.com/articles/devoxx-2012-java-8-lambda-and\">http://java.dzone.com/articles/devoxx-2012-java-8-lambda-and</a> - the section about internal and external iteration)</p>\n\n<p><strong>UPDATE:</strong>\nThe main advantage from my point of view is that the implementation of what is to be done within the loop can be defined without having to decide if it will be executed in parallel or sequential.</p>\n\n<p><strong>UPDATE2:</strong>\nIf you want your loop to be executed in parallel you could simply write</p>\n\n<pre><code>joins.parallelStream().forEach((join) -&gt; mIrc.join(mSession, join));\n</code></pre>\n\n<p>in the first case. In the second case you will have to write some extra code for thread handling etc.</p>\n\n<p><strong>UPDATE3:</strong>\nfor my answer I assumed joins implementing the <code>java.util.Stream</code> interface. If joins implements only the <code>java.util.Iterable</code> interface this is no longer true. </p>\n\n<p><strong>UPDATE4:</strong> now in the released version of Java 8, the method parallel() was renamed to parallelStream()</p>\n    "},{"t":"Java 8 stream's .min() and .max(): why does this compile?","l":"http://stackoverflow.com/questions/22561614/java-8-streams-min-and-max-why-does-this-compile","q":"\n\n<p>Note: this question originates from a dead link which was a previous SO question, but here goes...</p>\n\n<p>See this code (note: I do know that this code won't \"work\" and that <code>Integer::compare</code> should be used -- I just extracted it from the linked question):</p>\n\n<pre><code>final ArrayList &lt;Integer&gt; list \n    = IntStream.rangeClosed(1, 20).boxed().collect(Collectors.toList());\n\nSystem.out.println(list.stream().max(Integer::max).get());\nSystem.out.println(list.stream().min(Integer::min).get());\n</code></pre>\n\n<p>According to the javadoc of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-\"><code>.min()</code></a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-\"><code>.max()</code></a>, the argument of both should be a <code>Comparator</code>. Yet here the method references are to static methods of the <a href=\"http://download.java.net/jdk8/docs/api/java/lang/Integer.html\"><code>Integer</code></a> class.</p>\n\n<p>So, why does this compile at all?</p>\n    ","a":"\n<p>Let me explain what is happening here, because it isn't obvious!</p>\n\n<p>First, [<code>Stream.max()</code>] accepts an instance of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html\" rel=\"nofollow\"><code>Comparator</code></a> so that items in the stream can be compared against each other to find the minimum or maximum, in some optimal order that you don't need to worry too much about.</p>\n\n<p>So the question is, of course, why is <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#max-int-int-\" rel=\"nofollow\"><code>Integer::max</code></a> accepted?  After all it's not a comparator!</p>\n\n<p>The answer is in the way that the new lambda functionality works in Java 8.  It relies on a concept which is informally known as \"single abstract method\" interfaces, or \"SAM\" interfaces.  The idea is that any interface with one abstract method can be automatically implemented by any lambda - or method reference - whose method signature is a match for the one method on the interface.  So examining the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html\" rel=\"nofollow\"><code>Comparator</code></a> interface (simple version):</p>\n\n<pre><code>public Comparator&lt;T&gt; {\n    int compare(T o1, T o2);\n}\n</code></pre>\n\n<p>If a method is looking for a <code>Comparator&lt;Integer&gt;</code>, then it's essentially looking for this signature:</p>\n\n<pre><code>int xxx(Integer o1, Integer o2);\n</code></pre>\n\n<p>I use \"xxx\" <strong>because the method name is not used for matching purposes</strong>.</p>\n\n<p>Therefore, both <code>Integer.min(int a, int b)</code> and <code>Integer.max(int a, int b)</code> are close enough that autoboxing will allow this to appear as a <code>Comparator&lt;Integer&gt;</code> in a method context.</p>\n    "},{"t":"Why are Java Streams once-off?","l":"http://stackoverflow.com/questions/28459498/why-are-java-streams-once-off","q":"\n\n<p>Unlike C#'s <code>IEnumerable</code>, where an execution pipeline can be executed as many times as we want, in Java a stream can be 'iterated' only once. </p>\n\n<p>Any call to a terminal operation closes the stream, rendering it unusable.\nThis 'feature' takes away a lot of power. </p>\n\n<p>I imagine the reason for this is <em>not</em> technical. What were the design considerations behind this strange restriction?</p>\n\n<p>Edit: in order to demonstrate what I am talking about, consider the following implementation of Quick-Sort in C#:</p>\n\n<pre><code>IEnumerable&lt;int&gt; QuickSort(IEnumerable&lt;int&gt; ints)\n{\n  if (!ints.Any()) {\n    return Enumerable.Empty&lt;int&gt;();\n  }\n\n  int pivot = ints.First();\n\n  IEnumerable&lt;int&gt; lt = ints.Where(i =&gt; i &lt; pivot);\n  IEnumerable&lt;int&gt; gt = ints.Where(i =&gt; i &gt; pivot);\n\n  return QuickSort(lt).Concat(new int[] { pivot }).Concat(QuickSort(gt));\n}\n</code></pre>\n\n<p>Now to be sure, I am not advocating that this is a good implementation of quick sort! It is however great example of the expressive power of lambda expression combined with stream operation. </p>\n\n<p>And it can't be done in Java!\nI can't even ask a stream whether it is empty without rendering it unusable. </p>\n    ","a":"\n<p>I have some recollections from the early design of the Streams API that might shed some light on the design rationale.</p>\n\n<p>Back in 2012, we were adding lambdas to the language, and we wanted a collections-oriented or \"bulk data\" set of operations, programmed using lambdas, that would facilitate parallelism. The idea of lazily chaining operations together was well established by this point. We also didn't want the intermediate operations to store results.</p>\n\n<p>The main issues we needed to decide were what the objects in the chain looked like in the API and how they hooked up to data sources. The sources were often collections, but we also wanted to support data coming from a file or the network, or data generated on-the-fly, e.g., from a random number generator.</p>\n\n<p>There were many influences of existing work on the design. Among the more influential were Google's <a href=\"https://code.google.com/p/guava-libraries/\">Guava</a> library and the Scala collections library. (If anybody is surprised about the influence from Guava, note that <a href=\"http://stackoverflow.com/users/202214/kevin-bourrillion\">Kevin Bourrillion</a>, Guava lead developer, was on the <a href=\"https://jcp.org/en/jsr/detail?id=335\">JSR-335 Lambda</a> expert group.) On Scala collections, we found this talk by Martin Odersky to be of particular interest: <a href=\"http://youtu.be/HoIOIluNFzQ\">Future-Proofing Scala Collections: from Mutable to Persistent to Parallel</a>. (Stanford EE380, 2011 June 1.)</p>\n\n<p>Our prototype design at the time was based around <code>Iterable</code>. The familiar operations <code>filter</code>, <code>map</code>, and so forth were extension (default) methods on <code>Iterable</code>. Calling one added an operation to the chain and returned another <code>Iterable</code>. A terminal operation like <code>count</code> would call <code>iterator()</code> up the chain to the source, and the operations were implemented within each stage's Iterator.</p>\n\n<p>Since these are Iterables, you can call the <code>iterator()</code> method more than once. What should happen then?</p>\n\n<p>If the source is a collection, this mostly works fine. Collections are Iterable, and each call to <code>iterator()</code> produces a distinct Iterator instance that is independent of any other active instances, and each traverses the collection independently. Great.</p>\n\n<p>Now what if the source is one-shot, like reading lines from a file? Maybe the first Iterator should get all the values but the second and subsequent ones should be empty. Maybe the values should be interleaved among the Iterators. Or maybe each Iterator should get all the same values. Then, what if you have two iterators and one gets farther ahead of the other? Somebody will have to buffer up the values in the second Iterator until they're read. Worse, what if you get one Iterator and read all the values, and only <em>then</em> get a second Iterator. Where do the values come from now? Is there a requirement for them all to be buffered up <em>just in case</em> somebody wants a second Iterator?</p>\n\n<p>Clearly, allowing multiple Iterators over a one-shot source raises a lot of questions. We didn't have good answers for them. We wanted consistent, predictable behavior for what happens if you call <code>iterator()</code> twice. This pushed us toward disallowing multiple traversals, making the pipelines one-shot.</p>\n\n<p>We also observed others bumping into these issues. In the JDK, most Iterables are collections or collection-like objects, which allow multiple traversal. It isn't specified anywhere, but there seemed to be an unwritten expectation that Iterables allow multiple traversal. A notable exception is the NIO <a href=\"http://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.html\">DirectoryStream</a> interface. Its specification includes this interesting warning:</p>\n\n<blockquote>\n  <p><strong>While DirectoryStream extends Iterable, it is not a general-purpose Iterable as it supports only a single Iterator; invoking the iterator method to obtain a second or subsequent iterator throws IllegalStateException.</strong></p>\n</blockquote>\n\n<p>[bold in original]</p>\n\n<p>This seemed unusual and unpleasant enough that we didn't want to create a whole bunch of new Iterables that might be once-only. This pushed us away from using Iterable.</p>\n\n<p>About this time, an <a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=339521\">article by Bruce Eckel</a> appeared that described a spot of trouble he'd had with Scala. He'd written this code:</p>\n\n<pre><code>// Scala\nval lines = fromString(data).getLines\nval registrants = lines.map(Registrant)\nregistrants.foreach(println)\nregistrants.foreach(println)\n</code></pre>\n\n<p>It's pretty straightforward. It parses lines of text into <code>Registrant</code> objects and prints them out twice. Except that it actually only prints them out once. It turns out that he thought that <code>registrants</code> was a collection, when in fact it's an iterator. The second call to <code>foreach</code> encounters an empty iterator, from which all values have been exhausted, so it prints nothing.</p>\n\n<p>This kind of experience convinced us that it was very important to have clearly predictable results if multiple traversal is attempted. It also highlighted the importance of distinguishing between lazy pipeline-like structures from actual collections that store data. This in turn drove the separation of the lazy pipeline operations into the new Stream interface and keeping only eager, mutative operations directly on Collections. <a href=\"http://stackoverflow.com/a/24472635/1441122\">Brian Goetz has explained</a> the rationale for that.</p>\n\n<p>What about allowing multiple traversal for collection-based pipelines but disallowing it for non-collection-based pipelines? It's inconsistent, but it's sensible. If you're reading values from the network, <em>of course</em> you can't traverse them again. If you want to traverse them multiple times, you have to pull them into a collection explicitly.</p>\n\n<p>But let's explore allowing multiple traversal from collections-based pipelines. Let's say you did this:</p>\n\n<pre><code>Iterable&lt;?&gt; it = source.filter(...).map(...).filter(...).map(...);\nit.into(dest1);\nit.into(dest2);\n</code></pre>\n\n<p>(The <code>into</code> operation is now spelled <code>collect(toList())</code>.)</p>\n\n<p>If source is a collection, then the first <code>into()</code> call will create a chain of Iterators back to the source, execute the pipeline operations, and send the results into the destination. The second call to <code>into()</code> will create another chain of Iterators, and execute the pipeline operations <strong>again</strong>. This isn't obviously wrong but it does have the effect of performing all the filter and map operations a second time for each element. I think many programmers would have been surprised by this behavior.</p>\n\n<p>As I mentioned above, we had been talking to the Guava developers. One of the cool things they have is an <a href=\"https://code.google.com/p/guava-libraries/wiki/IdeaGraveyard\">Idea Graveyard</a> where they describe features that they decided <strong>not</strong> to implement along with the reasons. The idea of lazy collections sounds pretty cool, but here's what they have to say about it. Consider a <code>List.filter()</code> operation that returns a <code>List</code>:</p>\n\n<blockquote>\n  <p>The biggest concern here is that too many operations become expensive, linear-time propositions. If you want to filter a list and get a list back, and not just a Collection or an Iterable, you can use <code>ImmutableList.copyOf(Iterables.filter(list, predicate))</code>, which \"states up front\" what it's doing and how expensive it is.</p>\n</blockquote>\n\n<p>To take a specific example, what's the cost of <code>get(0)</code> or <code>size()</code> on a List? For commonly used classes like <code>ArrayList</code>, they're O(1). But if you call one of these on a lazily-filtered list, it has to run the filter over the backing list, and all of a sudden these operations are O(n). Worse, it has to traverse the backing list on <strong>every</strong> operation.</p>\n\n<p>This seemed to us to be <em>too much</em> laziness. It's one thing to set up some operations and defer actual execution until you so \"Go\". It's another to set things up in such a way that hides a potentially large amount of recomputation.</p>\n\n<p>In proposing to disallow non-linear or \"no-reuse\" streams, <a href=\"http://stackoverflow.com/users/4042945/paul-sandoz\">Paul Sandoz</a> described the <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-experts/2012-November/000412.html\">potential consequences</a> of allowing them as giving rise to \"unexpected or confusing results.\" He also mentioned that parallel execution would make things even trickier. Finally, I'd add that a pipeline operation with side effects would lead to difficult and obscure bugs if the operation were unexpectedly executed multiple times, or at least a different number of times than the programmer expected. (But Java programmers don't write lambda expressions with side effects, do they? DO THEY??)</p>\n\n<p>So that's the basic rationale for the Java 8 Streams API design that allows one-shot traversal and that requires a strictly linear (no branching) pipeline. It provides consistent behavior across multiple different stream sources, it clearly separates lazy from eager operations, and it provides a straightforward execution model.</p>\n\n<hr>\n\n<p>With regard to <code>IEnumerable</code>, I am far from an expert on C# and .NET, so I would appreciate being corrected (gently) if I draw any incorrect conclusions. It does appear, however, that <code>IEnumerable</code> permits multiple traversal to behave differently with different sources; and it permits a branching structure of nested <code>IEnumerable</code> operations, which may result in some significant recomputation. While I appreciate that different systems make different tradeoffs, these are two characteristics that we sought to avoid in the design of the Java 8 Streams API.</p>\n\n<p>The quicksort example given by the OP is interesting, puzzling, and I'm sorry to say, somewhat horrifying. Calling <code>QuickSort</code> takes an <code>IEnumerable</code> and returns an <code>IEnumerable</code>, so no sorting is actually done until the final <code>IEnumerable</code> is traversed. What the call seems to do, though, is build up a tree structure of <code>IEnumerables</code> that reflects the partitioning that quicksort would do, without actually doing it. (This is lazy computation, after all.) If the source has N elements, the tree will be N elements wide at its widest, and it will be lg(N) levels deep.</p>\n\n<p>It seems to me -- and once again, I'm not a C# or .NET expert -- that this will cause certain innocuous-looking calls, such as pivot selection via <code>ints.First()</code>, to be more expensive than they look. At the first level, of course, it's O(1). But consider a partition deep in the tree, at the right-hand edge. To compute the first element of this partition, the entire source has to be traversed, an O(N) operation. But since the partitions above are lazy, they must be recomputed, requiring O(lg N) comparisons. So selecting the pivot would be an O(N lg N) operation, which is as expensive as an entire sort.</p>\n\n<p>But we don't actually sort until we traverse the returned <code>IEnumerable</code>. In the standard quicksort algorithm, each level of partitioning doubles the number of partitions. Each partition is only half the size, so each level remains at O(N) complexity. The tree of partitions is O(lg N) high, so the total work is O(N lg N).</p>\n\n<p>With the tree of lazy IEnumerables, at the bottom of the tree there are N partitions. Computing each partition requires a traversal of N elements, each of which requires lg(N) comparisons up the tree. To compute all the partitions at the bottom of the tree, then, requires O(N^2 lg N) comparisons.</p>\n\n<p>(Is this right? I can hardly believe this. Somebody please check this for me.)</p>\n\n<p>In any case, it is indeed cool that <code>IEnumerable</code> can be used this way to build up complicated structures of computation. But if it does increase the computational complexity as much as I think it does, it would seem that programming this way is something that should be avoided unless one is extremely careful.</p>\n    "},{"t":"Java 8 List<V> into Map<K, V>","l":"http://stackoverflow.com/questions/20363719/java-8-listv-into-mapk-v","q":"\n\n<p>I want to translate a List of objects into a Map using Java 8's streams and lambdas.</p>\n\n<p>This is how I would write it in Java 7 and below.</p>\n\n<pre><code>private Map&lt;String, Choice&gt; nameMap() {\n        final Map&lt;String, Choice&gt; hashMap = new HashMap&lt;&gt;();\n        for (final Choice choice : choices) {\n            hashMap.put(choice.getName(), choice);\n        }\n        return hashMap;\n}\n</code></pre>\n\n<p>I can accomplish this easily using Java 8 and Guava but I would like to know how to do this without Guava.</p>\n\n<p>In Guava:</p>\n\n<pre><code>private Map&lt;String, Choice&gt; nameMap() {\n    return Maps.uniqueIndex(choices, new Function&lt;Choice, String&gt;() {\n\n        @Override\n        public String apply(final Choice input) {\n            return input.getName();\n        }\n    });\n}\n</code></pre>\n\n<p>And Guava with Java 8 lambdas.</p>\n\n<pre><code>private Map&lt;String, Choice&gt; nameMap() {\n    return Maps.uniqueIndex(choices, c -&gt; c.getName());\n}\n</code></pre>\n    ","a":"\n<p>Based on <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-\"><code>Collectors</code> documentation</a> it's as simple as:</p>\n\n<pre><code>Map&lt;String, Choice&gt; result =\n    choices.stream().collect(Collectors.toMap(Choice::getName,\n                                              Function.identity()));\n</code></pre>\n    "},{"t":"Custom thread pool in Java 8 parallel stream","l":"http://stackoverflow.com/questions/21163108/custom-thread-pool-in-java-8-parallel-stream","q":"\n\n<p>Is it possible to specify a custom thread pool for Java 8 <a href=\"http://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html\">parallel stream</a>? I can not find it anywhere. </p>\n\n<p>Imagine that I have a server application and I would like to use parallel streams. But the application is large and multi-threaded so I want to compartmentalize it. I do not want a slow running task in one module of the applicationblock tasks from another module.</p>\n\n<p>If I can not use different thread pools for different modules, it means I can not safely use parallel streams in most of real world situations.</p>\n\n<p>Try the following example. There are some CPU intensive tasks executed in separate threads.\nThe tasks leverage parallel streams. The first task is broken, so each step takes 1 second (simulated by thread sleep). The issue is that other threads get stuck and wait for the broken task to finish. This is contrived example, but imagine a servlet app and someone submitting a long running task to the shared fork join pool. </p>\n\n<pre><code>public class ParallelTest {\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService es = Executors.newCachedThreadPool();\n\n        es.execute(() -&gt; runTask(1000)); //incorrect task\n        es.execute(() -&gt; runTask(0));\n        es.execute(() -&gt; runTask(0));\n        es.execute(() -&gt; runTask(0));\n        es.execute(() -&gt; runTask(0));\n        es.execute(() -&gt; runTask(0));\n\n\n        es.shutdown();\n        es.awaitTermination(60, TimeUnit.SECONDS);\n    }\n\n    private static void runTask(int delay) {\n        range(1, 1_000_000).parallel().filter(ParallelTest::isPrime).peek(i -&gt; Utils.sleep(delay)).max()\n                .ifPresent(max -&gt; System.out.println(Thread.currentThread() + \" \" + max));\n    }\n\n    public static boolean isPrime(long n) {\n        return n &gt; 1 &amp;&amp; rangeClosed(2, (long) sqrt(n)).noneMatch(divisor -&gt; n % divisor == 0);\n    }\n}\n</code></pre>\n    ","a":"\n<p>There actually is a trick how to execute a parallel operation in a specific fork-join pool. If you execute it as a task in a fork-join pool, it stays there and does not use the common one.  </p>\n\n<pre><code>ForkJoinPool forkJoinPool = new ForkJoinPool(2);\nforkJoinPool.submit(() -&gt;\n    //parallel task here, for example\n    IntStream.range(1, 1_000_000).parallel().filter(PrimesPrint::isPrime).collect(toList())\n).get();\n</code></pre>\n\n<p>The trick is based on <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html#fork--\">ForkJoinTask.fork</a> which specifies: \"Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the ForkJoinPool.commonPool() if not inForkJoinPool()\"</p>\n    "},{"t":"When is an interface with a default method initialized?","l":"http://stackoverflow.com/questions/23096084/when-is-an-interface-with-a-default-method-initialized","q":"\n\n<p>While searching through the Java Language Specification to answer <a href=\"http://stackoverflow.com/questions/23093470/java-order-of-initialization-and-instantiation#23093470\">this question</a>, I learned <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.4\" rel=\"nofollow\">that</a></p>\n\n<blockquote>\n  <p>Before a class is initialized, its direct superclass must be\n  initialized, <strong>but interfaces implemented by the class are not\n  initialized.</strong> Similarly, the superinterfaces of an interface are not\n  initialized before the interface is initialized.</p>\n</blockquote>\n\n<p>For my own curiosity, I tried it and, really, the interface <code>InterfaceType</code> was not initialized.</p>\n\n<pre><code>public class Example {\n    public static void main(String[] args) throws Exception {\n        InterfaceType foo = new InterfaceTypeImpl();\n        foo.method();\n    }\n}\n\nclass InterfaceTypeImpl implements InterfaceType {\n    @Override\n    public void method() {\n        System.out.println(\"implemented method\");\n    }\n}\n\nclass ClassInitializer {\n    static {\n        System.out.println(\"static initializer\");\n    }\n}\n\ninterface InterfaceType {\n    public static final ClassInitializer init = new ClassInitializer();\n\n    public void method();\n}\n</code></pre>\n\n<p>This program prints</p>\n\n<pre><code>implemented method\n</code></pre>\n\n<p>However, if the interface declares a <code>default</code> method, then initialization occurs. Consider the <code>InterfaceType</code> interface given as</p>\n\n<pre><code>interface InterfaceType {\n    public static final ClassInitializer init = new ClassInitializer();\n\n    public default void method() {\n        System.out.println(\"default method\");\n    }\n}\n</code></pre>\n\n<p>then the same program above would print</p>\n\n<pre><code>static initializer\nimplemented method\n</code></pre>\n\n<p>In other words, the <code>static</code> field of the interface is initialized (<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.4\" rel=\"nofollow\">step 9 in the Detailed Initialization Procedure</a>) and the <code>static</code> initializer of the type being initialized is executed. This means that the interface was initialized. </p>\n\n<p>I could not find anything in the JLS to indicate that this should happen. Don't get me wrong, I understand that this should happen in case the implementing class doesn't provide an implementation for the method, but what if it does? Is this condition missing from the Java Language Specification, did I miss something, or am I interpreting it wrongly?</p>\n    ","a":"\n<p>This is a very interesting issue!</p>\n\n<p>It seems like <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.4.1\">JLS section 12.4.1</a> ought to cover this definitively. However, the behavior of Oracle JDK and OpenJDK (javac and HotSpot) differs from what's specified here. In particular, the Example 12.4.1-3 from this section covers interface initialization. The example as follows:</p>\n\n<pre><code>interface I {\n    int i = 1, ii = Test.out(\"ii\", 2);\n}\ninterface J extends I {\n    int j = Test.out(\"j\", 3), jj = Test.out(\"jj\", 4);\n}\ninterface K extends J {\n    int k = Test.out(\"k\", 5);\n}\nclass Test {\n    public static void main(String[] args) {\n        System.out.println(J.i);\n        System.out.println(K.j);\n    }\n    static int out(String s, int i) {\n        System.out.println(s + \"=\" + i);\n        return i;\n    }\n}\n</code></pre>\n\n<p>Its expected output is:</p>\n\n<pre><code>1\nj=3\njj=4\n3\n</code></pre>\n\n<p>and indeed I get the expected output. However, if a default method is added to interface <code>I</code>,</p>\n\n<pre><code>interface I {\n    int i = 1, ii = Test.out(\"ii\", 2);\n    default void method() { } // causes initialization!\n}\n</code></pre>\n\n<p>the output changes to:</p>\n\n<pre><code>1\nii=2\nj=3\njj=4\n3\n</code></pre>\n\n<p>which clearly indicates that interface <code>I</code> is being initialized where it wasn't before! The mere presence of the default method is enough to trigger the initialization. The default method doesn't have to be called or overridden or even mentioned, nor does the presence of an abstract method trigger initialization.</p>\n\n<p>My speculation is that the HotSpot implementation wanted to avoid adding class/interface initialization checking into the critical path of the <code>invokevirtual</code> call. Prior to Java 8 and default methods, <code>invokevirtual</code> could never end up executing code in an interface, so this didn't arise. One might think this is  part of the class/interface preparation stage (<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.3.2\">JLS 12.3.2</a>) which initializes things like method tables. But perhaps this went too far and accidentally did full initialization instead.</p>\n\n<p>I've <a href=\"http://mail.openjdk.java.net/pipermail/compiler-dev/2014-April/008733.html\">raised this question</a> on the OpenJDK compiler-dev mailing list. There's been a <a href=\"http://mail.openjdk.java.net/pipermail/compiler-dev/2014-April/008734.html\">reply from Alex Buckley</a> (editor of the JLS) in which he raises more questions directed at the JVM and lambda implementation teams. He also notes that there's a bug in the spec here where it says \"T is a class and a static method declared by T is invoked\" should also apply if T is an interface. So, it might be that there are both specification and HotSpot bugs here.</p>\n\n<p><strong><em>Disclosure</em></strong><em>: I work for Oracle on OpenJDK. If people think this gives me an unfair advantage at getting the bounty attached to this question, I'm willing to be flexible about it.</em> </p>\n    "},{"t":"PermGen elimination in JDK 8","l":"http://stackoverflow.com/questions/18339707/permgen-elimination-in-jdk-8","q":"\n\n<p>I have installed JDK 8 and trying to run Eclipse. I am getting following warning message:</p>\n\n<pre><code>Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=512m;\nsupport was removed in 8.0 \n</code></pre>\n\n<p>What are the reasons of ignoring this argument?</p>\n    ","a":"\n<p>This is one of the new features of Java 8, part of <a href=\"http://openjdk.java.net/jeps/122\">JDK Enhancement Proposals 122</a>:</p>\n\n<blockquote>\n  <p>Remove the permanent generation from the Hotspot JVM and thus the need to tune the size of the permanent generation.</p>\n</blockquote>\n\n<p>The list of all the JEPs that will be included in Java 8 can be found on the <a href=\"http://openjdk.java.net/projects/jdk8/milestones\">JDK8 milestones page</a>.</p>\n    "},{"t":"Interface with default methods vs Abstract class in Java 8","l":"http://stackoverflow.com/questions/19998454/interface-with-default-methods-vs-abstract-class-in-java-8","q":"\n\n<p>As Java 8 allows for default implementation of methods in interface called <a href=\"http://java.dzone.com/articles/introduction-default-methods\">Defender Methods</a>, there seems to be a confusion between when would I use a <code>abstract class</code>.</p>\n\n<p>So when should interface with default methods be used and when should an abstract class be used? Are the abstract classes still useful in that scenario?   </p>\n    ","a":"\n<p>There's a lot more to abstract classes than default method implementations (such as private state), but as of Java 8, whenever you have the choice of either, you should go with the defender method in the interface.</p>\n\n<p>The constraint on the defender method is that it can be implemented only in the terms of calls to other interface methods, with no reference to a particular implementation's state. So the main use case is higher-level and convenience methods.</p>\n\n<p>The good thing about this new feature is that, where before you were forced to use an abstract class for the convenience methods, thus constraining the implementor to single inheritance, now you can have a really clean design with just the interface and a minumum of implementation effort forced on the programmer.</p>\n    "},{"t":"Why does Stream<T> not implement Iterable<T>?","l":"http://stackoverflow.com/questions/20129762/why-does-streamt-not-implement-iterablet","q":"\n\n<p>In Java 8 we have the class <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\">Stream&lt;T&gt;</a>, which curiously have a method</p>\n\n<pre><code>Iterator&lt;T&gt; iterator()\n</code></pre>\n\n<p>So you would expect it to implement interface <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html\">Iterable&lt;T&gt;</a>, which requires exactly this method, but that's not the case.</p>\n\n<p>When I want to iterate over a Stream using a foreach loop, I have to do something like</p>\n\n<pre><code>public static Iterable&lt;T&gt; getIterable(Stream&lt;T&gt; s) {\n    return new Iterable&lt;T&gt; {\n        @Override\n        public Iterator&lt;T&gt; iterator() {\n            return s.iterator();\n        }\n    };\n}\n\nfor (T element : getIterable(s)) { ... }\n</code></pre>\n\n<p>Am I missing something here?</p>\n    ","a":"\n<p>There are already people asked the same <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008876.html\">on the mailing list</a> ☺. The main reason is Iterable also has a re-iterable semantic, while Stream is not.</p>\n\n<blockquote>\n  <p>I think the main reason is that <code>Iterable</code> implies reusability, whereas <code>Stream</code> is something that can only be used once — more like an <code>Iterator</code>.</p>\n  \n  <p>If <code>Stream</code> extended <code>Iterable</code> then existing code might be surprised when it receives an <code>Iterable</code> that throws an <code>Exception</code> the\n  second time they do <code>for (element : iterable)</code>.</p>\n</blockquote>\n    "},{"t":"Convert java.util.Date to java.time.LocalDate","l":"http://stackoverflow.com/questions/21242110/convert-java-util-date-to-java-time-localdate","q":"\n\n<p>What is the best way to convert a <code>java.util.Date</code> object to the new JDK 8/JSR-310 <code>java.time.LocalDate</code>?</p>\n\n<pre><code>Date input = new Date();\nLocalDate date = ???\n</code></pre>\n    ","a":"\n<p>Short answer:</p>\n\n<pre><code>Date input = new Date();\nLocalDate date = input.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\n</code></pre>\n\n<p>Explanation:</p>\n\n<p>Despite its name, <code>java.util.Date</code> represents an instant on the time-line, not a \"date\". The actual data stored within the object is a <code>long</code> count of milliseconds since 1970-01-01T00:00Z (midnight at the start of 1970 GMT/UTC).</p>\n\n<p>The equivalent class to <code>java.util.Date</code> in JSR-310 is <code>Instant</code>, thus there is a convenient method <code>toInstant()</code> to provide the conversion:</p>\n\n<pre><code>Date input = new Date();\nInstant instant = input.toInstant();\n</code></pre>\n\n<p>A <code>java.util.Date</code> instance has no concept of time-zone. This might seem strange if you call <code>toString()</code> on a <code>java.util.Date</code>, because the <code>toString</code> is relative to a time-zone. However that method actually uses Java's default time-zone on the fly to provide the string. The time-zone is not part of the actual state of <code>java.util.Date</code>.</p>\n\n<p>An <code>Instant</code> also does not contain any information about the time-zone. Thus, to convert from an <code>Instant</code> to a local date it is necessary to specify a time-zone. This might be the default zone - <code>ZoneId.systemDefault()</code> - or it might be a time-zone that your application controls, such as a time-zone from user preferences. Use the <code>atZone()</code> method to apply the time-zone:</p>\n\n<pre><code>Date input = new Date();\nInstant instant = input.toInstant();\nZonedDateTime zdt = instant.atZone(ZoneId.systemDefault());\n</code></pre>\n\n<p>A <code>ZonedDateTime</code> contains state consisting of the local date and time, time-zone and the offset from GMT/UTC. As such the date - <code>LocalDate</code> - can be easily extracted using <code>toLocalDate()</code>:</p>\n\n<pre><code>Date input = new Date();\nInstant instant = input.toInstant();\nZonedDateTime zdt = instant.atZone(ZoneId.systemDefault());\nLocalDate date = zdt.toLocalDate();\n</code></pre>\n    "},{"t":"Why does this Java 8 lambda fail to compile?","l":"http://stackoverflow.com/questions/29262002/why-does-this-java-8-lambda-fail-to-compile","q":"\n\n<p>The following Java code fails to compile:</p>\n\n<pre><code>@FunctionalInterface\nprivate interface BiConsumer&lt;A, B&gt; {\n    void accept(A a, B b);\n}\n\nprivate static void takeBiConsumer(BiConsumer&lt;String, String&gt; bc) { }\n\npublic static void main(String[] args) {\n    takeBiConsumer((String s1, String s2) -&gt; new String(\"hi\")); // OK\n    takeBiConsumer((String s1, String s2) -&gt; \"hi\"); // Error\n}\n</code></pre>\n\n<p>The compiler reports:</p>\n\n<pre><code>Error:(31, 58) java: incompatible types: bad return type in lambda expression\n    java.lang.String cannot be converted to void\n</code></pre>\n\n<p>The weird thing is that the line marked \"OK\" compiles fine, but the line marked \"Error\" fails. They seem essentially identical.</p>\n    ","a":"\n<p>Your lambda needs to be congruent with <code>BiConsumer&lt;String, String&gt;</code>. If you refer to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3\">JLS #15.27.3 (Type of a Lambda)</a>:</p>\n\n<blockquote>\n  <p>A lambda expression is congruent with a function type if all of the following are true:</p>\n  \n  <ul>\n  <li>[...]  </li>\n  <li>If the function type's result is void, the lambda body is either a statement expression (§14.8) or a void-compatible block.</li>\n  </ul>\n</blockquote>\n\n<p>So the lambda must either be a statement expression or a void compatible block:</p>\n\n<ul>\n<li>A constructor invocation is <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.8\">a statement expression</a> so it compiles.</li>\n<li>A string literal isn't a statement expression and is not void compatible (cf. <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.2-230\">the examples in 15.27.2</a>) so it does not compile.</li>\n</ul>\n    "},{"t":"Why does Iterable<T> not provide stream() and parallelStream() methods?","l":"http://stackoverflow.com/questions/23114015/why-does-iterablet-not-provide-stream-and-parallelstream-methods","q":"\n\n<p>I am wondering why the <code>Iterable</code> interface does not provide the <code>stream()</code> and <code>parallelStream()</code> methods. Consider the following class:</p>\n\n<pre><code>public class Hand implements Iterable&lt;Card&gt; {\n    private final List&lt;Card&gt; list = new ArrayList&lt;&gt;();\n    private final int capacity;\n\n    //...\n\n    @Override\n    public Iterator&lt;Card&gt; iterator() {\n        return list.iterator();\n    }\n}\n</code></pre>\n\n<p>It is an implementation of a <em>Hand</em> as you can have cards in your hand while playing a Trading Card Game.</p>\n\n<p>Essentially it wraps a <code>List&lt;Card&gt;</code>, ensures a maximum capacity and offers some other useful features. It is better as implementing it directly as a <code>List&lt;Card&gt;</code>.</p>\n\n<p>Now, for convienience I thought it would be nice to implement <code>Iterable&lt;Card&gt;</code>, such that you can use enhanced for-loops if you want to loop over it. (My <code>Hand</code> class also provides a <code>get(int index)</code> method, hence the <code>Iterable&lt;Card&gt;</code> is justified in my opinion.)</p>\n\n<p>The <code>Iterable</code> interface provides the following (left out javadoc):</p>\n\n<pre><code>public interface Iterable&lt;T&gt; {\n    Iterator&lt;T&gt; iterator();\n\n    default void forEach(Consumer&lt;? super T&gt; action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n\n    default Spliterator&lt;T&gt; spliterator() {\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    }\n}\n</code></pre>\n\n<p>Now can you obtain a stream with:</p>\n\n<pre><code>Stream&lt;Hand&gt; stream = StreamSupport.stream(hand.spliterator(), false);\n</code></pre>\n\n<p>So onto the real question:</p>\n\n<ul>\n<li>Why does <code>Iterable&lt;T&gt;</code> not provide a default methods that implement <code>stream()</code> and <code>parallelStream()</code>, I see nothing that would make this impossible or unwanted?</li>\n</ul>\n\n<p>A related question I found is the following though: <a href=\"http://stackoverflow.com/questions/20129762/why-does-streamt-not-implement-iterablet\">Why does Stream&lt;T&gt; not implement Iterable&lt;T&gt;?</a><br>\nWhich is oddly enough suggesting it to do it somewhat the other way around.</p>\n    ","a":"\n<p>This was not an omission; there was detailed discussion on the EG list in June of 2013.  </p>\n\n<p>The definitive discussion of the Expert Group is rooted at <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-experts/2013-June/001910.html\">this thread</a>.</p>\n\n<p>While it seemed \"obvious\" (even to the Expert Group, initially) that <code>stream()</code> seemed to make sense on <code>Iterable</code>, the fact that <code>Iterable</code> was so general became a problem, because the obvious signature:</p>\n\n<pre><code>Stream&lt;T&gt; stream()\n</code></pre>\n\n<p>was not always what you were going to want. Some things that were <code>Iterable&lt;Integer&gt;</code> would rather have their stream method return an <code>IntStream</code>, for example.  But putting the <code>stream()</code> method this high up in the hierarchy would make that impossible.  So instead, we made it really easy to make a <code>Stream</code> from an <code>Iterable</code>, by providing a <code>spliterator()</code> method. The implementation of <code>stream()</code> in <code>Collection</code> is just:</p>\n\n<pre><code>default Stream&lt;E&gt; stream() {\n    return StreamSupport.stream(spliterator(), false);\n}\n</code></pre>\n\n<p>Any client can get the stream they want from an <code>Iterable</code> with:</p>\n\n<pre><code>Stream s = StreamSupport.stream(iter.spliterator(), false);\n</code></pre>\n\n<p>In the end we concluded that adding <code>stream()</code> to <code>Iterable</code> would be a mistake.</p>\n    "},{"t":"Can Java 8 code be compiled to run on Java 7 jvm?","l":"http://stackoverflow.com/questions/16143684/can-java-8-code-be-compiled-to-run-on-java-7-jvm","q":"\n\n<p>Java 8 introduces important new language features such as lambda expressions.</p>\n\n<p>Are these changes in the language accompanied by such significant changes in the compiled bytecode that would prevent it from being run on a Java 7 virtual machine without using some retrotranslator?</p>\n    ","a":"\n<p>No, using 1.8 features in your source code requires you to target a 1.8 VM. I just tried the new Java 8 release and tried compiling with <code>-target 1.7 -source 1.8</code>, and the compiler refuses:</p>\n\n<pre><code>$ javac Test -source 1.8 -target 1.7\njavac: source release 1.8 requires target release 1.8\n</code></pre>\n    "},{"t":"Difference between final and effectively final","l":"http://stackoverflow.com/questions/20938095/difference-between-final-and-effectively-final","q":"\n\n<p>I'm playing with lambdas in Java 8 and I came across warning <code>local variables referenced from a lambda expression must be final or effectively final</code>. I know that when I use variables inside anonymous class they must be final in outer class, but still - what is the difference between <em>final</em> and <em>effectively final</em>?</p>\n    ","a":"\n<blockquote>\n  <p>However, starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or effectively final. <strong>A variable or parameter whose value is never changed after it is initialized is effectively final.</strong></p>\n</blockquote>\n\n<p>For example, suppose that the variable numberLength is not declared final, and you add the marked assignment statement in the PhoneNumber constructor:</p>\n\n<pre><code>PhoneNumber(String phoneNumber) {\n    numberLength = 7;   // &lt;== assignment to numberLength\n    String currentNumber = phoneNumber.replaceAll(\n        regularExpression, \"\");\n    if (currentNumber.length() == numberLength)\n        formattedPhoneNumber = currentNumber;\n    else\n        formattedPhoneNumber = null;\n}\n</code></pre>\n\n<p>Because of this assignment statement, the variable numberLength is not effectively final anymore. <strong>As a result, the Java compiler generates an error message similar to \"local variables referenced from an inner class must be final or effectively final\"</strong> where the inner class PhoneNumber tries to access the numberLength variable:</p>\n\n<p><a href=\"http://codeinventions.blogspot.in/2014/07/difference-between-final-and.html\">http://codeinventions.blogspot.in/2014/07/difference-between-final-and.html</a></p>\n\n<p><a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html\">http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html</a></p>\n    "},{"t":"What does the -> <- operator do?","l":"http://stackoverflow.com/questions/24938333/what-does-the-operator-do","q":"\n\n<p>I recently came upon the following code:</p>\n\n<pre><code>IntPredicate neg = x -&gt; x &lt;- x;\n</code></pre>\n\n<p>What is this, some sort of reverse double lambda?</p>\n    ","a":"\n<p>There is no <code>-&gt; &lt;-</code> operator. That first <code>-&gt;</code> is just lambda syntax, as introduced in Java 8, and that second <code>&lt;-</code> is a misleading concatenation of 'smaller than' <code>&lt;</code> and 'unary minus' <code>-</code>.</p>\n\n<p>You can read it as <code>IntPredicate neg = (x) -&gt; (x &lt; (-x));</code>, i.e. it tests whether <code>x</code> is smaller than <code>-x</code>, which is the case for all (well, <a href=\"http://stackoverflow.com/questions/24938333/what-does-the-operator-do/24938462#comment38754811_24938462\">most</a>) negative numbers, hence the name <code>neg</code>.</p>\n\n<pre><code>IntPredicate neg = x -&gt; x &lt;- x;\nSystem.out.println(neg.test(4));   // false\nSystem.out.println(neg.test(0));   // false\nSystem.out.println(neg.test(-4));  // true\n</code></pre>\n\n<hr>\n\n<p>Just for completeness: This test is not only (intentionally?) hard to understand, but -- as pointed out in the comments -- it also fails for <code>Integer.MIN_VALUE</code> (which is <code>==-Integer.MIN_VALUE</code>). Instead, you should probably just use the much simpler <code>IntPredicate neg = x -&gt; (x &lt; 0);</code>.</p>\n    "},{"t":"Why is StringBuilder#append(int) faster in Java 7 than in Java 8?","l":"http://stackoverflow.com/questions/23756966/why-is-stringbuilderappendint-faster-in-java-7-than-in-java-8","q":"\n\n<p>While investigating for a <a href=\"http://stackoverflow.com/q/23748186/507519\">little debate</a> w.r.t. using <code>\"\" + n</code> and <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#toString%28int%29\"><code>Integer.toString(int)</code></a> to convert an integer primitive to a string I wrote this <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">JMH</a> microbenchmark:</p>\n\n<pre><code>@Fork(1)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Benchmark)\npublic class IntStr {\n    protected int counter;\n\n\n    @GenerateMicroBenchmark\n    public String integerToString() {\n        return Integer.toString(this.counter++);\n    }\n\n    @GenerateMicroBenchmark\n    public String stringBuilder0() {\n        return new StringBuilder().append(this.counter++).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String stringBuilder1() {\n        return new StringBuilder().append(\"\").append(this.counter++).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String stringBuilder2() {\n        return new StringBuilder().append(\"\").append(Integer.toString(this.counter++)).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String stringFormat() {\n        return String.format(\"%d\", this.counter++);\n    }\n\n    @Setup(Level.Iteration)\n    public void prepareIteration() {\n        this.counter = 0;\n    }\n}\n</code></pre>\n\n<p>I ran it with the default JMH options with both Java VMs that exist on my Linux machine (up-to-date Mageia 4 64-bit, Intel i7-3770 CPU, 32GB RAM). The first JVM was the one supplied with Oracle JDK\n8u5 64-bit:</p>\n\n<pre><code>java version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n</code></pre>\n\n<p>With this JVM I got pretty much what I expected:</p>\n\n<pre><code>Benchmark                    Mode   Samples         Mean   Mean error    Units\nb.IntStr.integerToString    thrpt        20    32317.048      698.703   ops/ms\nb.IntStr.stringBuilder0     thrpt        20    28129.499      421.520   ops/ms\nb.IntStr.stringBuilder1     thrpt        20    28106.692     1117.958   ops/ms\nb.IntStr.stringBuilder2     thrpt        20    20066.939     1052.937   ops/ms\nb.IntStr.stringFormat       thrpt        20     2346.452       37.422   ops/ms\n</code></pre>\n\n<p>I.e. using the <code>StringBuilder</code> class is slower due to the additional overhead of creating the <code>StringBuilder</code> object and appending an empty string. Using <code>String.format(String, ...)</code> is even slower, by an order of magnitude or so.</p>\n\n<p>The distribution-provided compiler, on the other hand, is based on OpenJDK 1.7:</p>\n\n<pre><code>java version \"1.7.0_55\"\nOpenJDK Runtime Environment (mageia-2.4.7.1.mga4-x86_64 u55-b13)\nOpenJDK 64-Bit Server VM (build 24.51-b03, mixed mode)\n</code></pre>\n\n<p>The results here were <em>interesting</em>:</p>\n\n<pre><code>Benchmark                    Mode   Samples         Mean   Mean error    Units\nb.IntStr.integerToString    thrpt        20    31249.306      881.125   ops/ms\nb.IntStr.stringBuilder0     thrpt        20    39486.857      663.766   ops/ms\nb.IntStr.stringBuilder1     thrpt        20    41072.058      484.353   ops/ms\nb.IntStr.stringBuilder2     thrpt        20    20513.913      466.130   ops/ms\nb.IntStr.stringFormat       thrpt        20     2068.471       44.964   ops/ms\n</code></pre>\n\n<p>Why does <code>StringBuilder.append(int)</code> appear so much faster with this JVM? Looking at the <code>StringBuilder</code> class source code revealed nothing particularly interesting - the method in question is almost identical to <code>Integer#toString(int)</code>. Interestingly enough, appending the result of <code>Integer.toString(int)</code> (the <code>stringBuilder2</code> microbenchmark) does not appear to be faster.</p>\n\n<p>Is this performance discrepancy an issue with the testing harness? Or does my OpenJDK JVM contain optimizations that would affect this particular code (anti)-pattern?</p>\n\n<p><strong>EDIT:</strong></p>\n\n<p>For a more straight-forward comparison, I installed Oracle JDK 1.7u55:</p>\n\n<pre><code>java version \"1.7.0_55\"\nJava(TM) SE Runtime Environment (build 1.7.0_55-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 24.55-b03, mixed mode)\n</code></pre>\n\n<p>The results are similar to those of OpenJDK:</p>\n\n<pre><code>Benchmark                    Mode   Samples         Mean   Mean error    Units\nb.IntStr.integerToString    thrpt        20    32502.493      501.928   ops/ms\nb.IntStr.stringBuilder0     thrpt        20    39592.174      428.967   ops/ms\nb.IntStr.stringBuilder1     thrpt        20    40978.633      544.236   ops/ms\n</code></pre>\n\n<p>It seems that this is a more general Java 7 vs Java 8 issue. Perhaps Java 7 had more aggressive string optimizations?</p>\n\n<p><strong>EDIT 2</strong>:</p>\n\n<p>For completeness, here are the string-related VM options for both of these JVMs:</p>\n\n<p>For Oracle JDK 8u5:</p>\n\n<pre><code>$ /usr/java/default/bin/java -XX:+PrintFlagsFinal 2&gt;/dev/null | grep String\n     bool OptimizeStringConcat                      = true            {C2 product}\n     intx PerfMaxStringConstLength                  = 1024            {product}\n     bool PrintStringTableStatistics                = false           {product}\n    uintx StringTableSize                           = 60013           {product}\n</code></pre>\n\n<p>For OpenJDK 1.7:</p>\n\n<pre><code>$ java -XX:+PrintFlagsFinal 2&gt;/dev/null | grep String\n     bool OptimizeStringConcat                      = true            {C2 product}        \n     intx PerfMaxStringConstLength                  = 1024            {product}           \n     bool PrintStringTableStatistics                = false           {product}           \n    uintx StringTableSize                           = 60013           {product}           \n     bool UseStringCache                            = false           {product}   \n</code></pre>\n\n<p>The <code>UseStringCache</code> option was removed in Java 8 with no replacement, so I doubt that makes any difference. The rest of the options appear to have the same settings.</p>\n\n<p><strong>EDIT 3:</strong></p>\n\n<p>A side-by-side comparison of the source code of the <code>AbstractStringBuilder</code>, <code>StringBuilder</code> and <code>Integer</code> classes from the <code>src.zip</code> file of reveals nothing noteworty. Apart from a whole lot of cosmetic and documentation changes, <code>Integer</code> now has some support for unsigned integers and <code>StringBuilder</code> has been slightly refactored to share more code with <code>StringBuffer</code>. None of these changes seem to affect the code paths used by <code>StringBuilder#append(int)</code>, although I may have missed something.</p>\n\n<p>A comparison of the assembly code generated for <code>IntStr#integerToString()</code> and <code>IntStr#stringBuilder0()</code> is far more interesting. The basic layout of the code generated for <code>IntStr#integerToString()</code> was similar for both JVMs, although Oracle JDK 8u5 seemed to be more aggressive w.r.t. inlining some calls within the <code>Integer#toString(int)</code> code. There was a clear correspondence with the Java source code, even for someone with minimal assembly experience.</p>\n\n<p>The assembly code for <code>IntStr#stringBuilder0()</code>, however, was radically different. The code generated by Oracle JDK 8u5 was once again directly related to the Java source code - I could easily recognise the same layout. On the contrary, the code generated by OpenJDK 7 was almost unrecognisable to the untrained eye (like mine). The <code>new StringBuilder()</code> call was seemingly removed, as was the creation of the array in the <code>StringBuilder</code> constructor. Additionaly, the disassembler plugin was not able to provide as many references to the source code as it did in JDK 8.</p>\n\n<p>I assume that this is either the result of a much more aggressive optimization pass in OpenJDK 7, or more probably the result of inserting hand-written low-level code for certain <code>StringBuilder</code> operations. I am unsure why this optimization does not happen in my JVM 8 implementation or why the same optimizations were not implemented for <code>Integer#toString(int)</code> in JVM 7. I guess someone familiar with the related parts of the JRE source code would have to answer these questions...</p>\n    ","a":"\n<p><strong>TL;DR:</strong> Side effects in <code>append</code> apparently break StringConcat optimizations.</p>\n\n<p>Very good analysis in the original question and updates! </p>\n\n<p>For completeness, below are a few missing steps:</p>\n\n<ul>\n<li><p>See through the <code>-XX:+PrintInlining</code> for both 7u55 and 8u5. In 7u55, you will see something like this:</p>\n\n<blockquote>\n<pre><code> @ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle\n   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)\n   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method\n   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)\n</code></pre>\n</blockquote>\n\n<p>...and in 8u5: </p>\n\n<blockquote>\n<pre><code> @ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle\n   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)\n     @ 3   java.lang.AbstractStringBuilder::&lt;init&gt; (12 bytes)   inline (hot)\n       @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n   @ 18   java.lang.StringBuilder::append (8 bytes)   inline (hot)\n     @ 2   java.lang.AbstractStringBuilder::append (62 bytes)   already compiled into a big method\n   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)\n     @ 13   java.lang.String::&lt;init&gt; (62 bytes)   inline (hot)\n       @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n       @ 55   java.util.Arrays::copyOfRange (63 bytes)   inline (hot)\n         @ 54   java.lang.Math::min (11 bytes)   (intrinsic)\n         @ 57   java.lang.System::arraycopy (0 bytes)   (intrinsic)\n</code></pre>\n</blockquote>\n\n<p>You might notice that 7u55 version is shallower, and it looks like nothing is called after <code>StringBuilder</code> methods -- this is a good indication the string optimizations are in effect. Indeed, if you run 7u55 with <code>-XX:-OptimizeStringConcat</code>, the subcalls will reappear, and performance drops to 8u5 levels.</p></li>\n<li><p>OK, so we need to figure out why 8u5 does not do the same optimization. Grep <a href=\"http://hg.openjdk.java.net/jdk9/jdk9/hotspot\">http://hg.openjdk.java.net/jdk9/jdk9/hotspot</a> for \"StringBuilder\" to figure out where VM handles the StringConcat optimization; this will get you into <code>src/share/vm/opto/stringopts.cpp</code></p></li>\n<li><p><code>hg log src/share/vm/opto/stringopts.cpp</code> to figure out the latest changes there. One of the candidates would be:</p>\n\n<blockquote>\n<pre><code>changeset:   5493:90abdd727e64\nuser:        iveresov\ndate:        Wed Oct 16 11:13:15 2013 -0700\nsummary:     8009303: Tiered: incorrect results in VM tests stringconcat...\n</code></pre>\n</blockquote></li>\n<li><p>Look for the review threads on OpenJDK mailing lists (easy enough to google for changeset summary): <a href=\"http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2013-October/012084.html\">http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2013-October/012084.html</a></p></li>\n<li><p>Spot \"String concat optimization optimization collapses the pattern [...] into a single allocation of a string and forming the result directly. All possible deopts that may happen in the optimized code restart this pattern from the beginning (starting from the StringBuffer allocation). <strong>That means that the whole pattern must me side-effect free.</strong>\" Eureka?</p></li>\n<li><p>Write out the contrasting benchmark:</p>\n\n<blockquote>\n<pre><code>@Fork(5)\n@Warmup(iterations = 5)\n@Measurement(iterations = 5)\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@State(Scope.Benchmark)\npublic class IntStr {\n    private int counter;\n\n    @GenerateMicroBenchmark\n    public String inlineSideEffect() {\n        return new StringBuilder().append(counter++).toString();\n    }\n\n    @GenerateMicroBenchmark\n    public String spliceSideEffect() {\n        int cnt = counter++;\n        return new StringBuilder().append(cnt).toString();\n    }\n}\n</code></pre>\n</blockquote></li>\n<li><p>Measure it on JDK 7u55, seeing the same performance for inlined/spliced side effects:</p>\n\n<blockquote>\n<pre><code>Benchmark                       Mode   Samples         Mean   Mean error    Units\no.s.IntStr.inlineSideEffect     avgt        25       65.460        1.747    ns/op\no.s.IntStr.spliceSideEffect     avgt        25       64.414        1.323    ns/op\n</code></pre>\n</blockquote></li>\n<li><p>Measure it on JDK 8u5, seeing the performance degradation with the inlined effect:</p>\n\n<blockquote>\n<pre><code>Benchmark                       Mode   Samples         Mean   Mean error    Units\no.s.IntStr.inlineSideEffect     avgt        25       84.953        2.274    ns/op\no.s.IntStr.spliceSideEffect     avgt        25       65.386        1.194    ns/op\n</code></pre>\n</blockquote></li>\n<li><p>Submit the bug report (<a href=\"https://bugs.openjdk.java.net/browse/JDK-8043677\">https://bugs.openjdk.java.net/browse/JDK-8043677</a>) to discuss this behavior with VM guys. The rationale for original fix is rock solid, it is interesting however if we can/should get back this optimization in some trivial cases like these.</p></li>\n<li><p>???</p></li>\n<li><p>PROFIT.</p></li>\n</ul>\n\n<p>And yeah, I should post the results for the benchmark which moves the increment from the <code>StringBuilder</code> chain, doing it before the entire chain. Also, switched to average time, and ns/op. This is JDK 7u55:</p>\n\n<blockquote>\n<pre><code>Benchmark                      Mode   Samples         Mean   Mean error    Units\no.s.IntStr.integerToString     avgt        25      153.805        1.093    ns/op\no.s.IntStr.stringBuilder0      avgt        25      128.284        6.797    ns/op\no.s.IntStr.stringBuilder1      avgt        25      131.524        3.116    ns/op\no.s.IntStr.stringBuilder2      avgt        25      254.384        9.204    ns/op\no.s.IntStr.stringFormat        avgt        25     2302.501      103.032    ns/op\n</code></pre>\n</blockquote>\n\n<p>And this is 8u5:</p>\n\n<blockquote>\n<pre><code>Benchmark                      Mode   Samples         Mean   Mean error    Units\no.s.IntStr.integerToString     avgt        25      153.032        3.295    ns/op\no.s.IntStr.stringBuilder0      avgt        25      127.796        1.158    ns/op\no.s.IntStr.stringBuilder1      avgt        25      131.585        1.137    ns/op\no.s.IntStr.stringBuilder2      avgt        25      250.980        2.773    ns/op\no.s.IntStr.stringFormat        avgt        25     2123.706       25.105    ns/op\n</code></pre>\n</blockquote>\n\n<p><code>stringFormat</code> is actually a bit faster in 8u5, and all other tests are the same. This solidifies the hypothesis the side-effect breakage in SB chains in the major culprit in the original question.</p>\n    "},{"t":"Default method returns true for a while, and then returns false? (Possible JVM bug)","l":"http://stackoverflow.com/questions/22096052/default-method-returns-true-for-a-while-and-then-returns-false-possible-jvm-b","q":"\n\n<p>I have an issue with the following code, which I isolated to the most closed form, I am using Java 8, which is almost ready for launch (18 March 2014), so I expect no serious issues in the implementation itself, so it may/must be my own code:</p>\n\n<p><strong>Note: The code is written in Java 8, which has all kinds of new features, including <code>default</code> method implementation in interfaces.</strong></p>\n\n<pre><code>public abstract class Drawable implements DrawableInterface {    \n\n}\n</code></pre>\n\n<hr>\n\n<pre><code>interface DrawableInterface {\n    default public boolean isShadowReceiver() {\n        return false;\n    }\n\n    default public boolean isShadowCaster() {\n        return false;\n    }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>public interface ShadowDrawable extends DrawableInterface {\n    @Override\n    default public boolean isShadowReceiver() {\n        return true;\n    }\n\n    @Override\n    default public boolean isShadowCaster() {\n        return true;\n    }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>public class Box extends Drawable implements ShadowDrawable {\n\n}\n</code></pre>\n\n<hr>\n\n<pre><code>public class IsolatedBug {\n    private final Box box;\n\n    private final List&lt;Drawable&gt; drawables;\n\n    public IsolatedBug() {\n        this.box = new Box();\n        this.drawables = new ArrayList&lt;&gt;();\n\n        drawables.add(box);\n        drawables.forEach(drawable -&gt; System.out.println(drawable + \" C=\" + drawable.isShadowCaster() + \"/R=\" + drawable.isShadowReceiver()));\n    }\n\n    private void init() throws InterruptedException {\n        while (true) {\n            drawables.forEach(drawable -&gt; System.out.println(drawable + \" C=\" + drawable.isShadowCaster() + \"/R=\" + drawable.isShadowReceiver()));\n            Thread.sleep(100);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new IsolatedBug().init();\n    }\n}\n</code></pre>\n\n<p>The code in itself may not make most sense, but that is because I have stripped a load of other irrelevant methods.</p>\n\n<p>However, when you observe the output, you see something strange, at a certain point, for me personally after 30 seconds, I see the following:</p>\n\n<blockquote>\n  <p>isolatedbug.Box@5acf9800 C=true/R=true<br>\n  isolatedbug.Box@5acf9800 C=true/R=true<br>\n  isolatedbug.Box@5acf9800 C=true/R=true<br>\n  isolatedbug.Box@5acf9800 C=true/R=true<br>\n  isolatedbug.Box@5acf9800 C=false/R=false<br>\n  isolatedbug.Box@5acf9800 C=false/R=false<br>\n  isolatedbug.Box@5acf9800 C=false/R=false<br>\n  isolatedbug.Box@5acf9800 C=false/R=false<br>\n  isolatedbug.Box@5acf9800 C=false/R=false<br>\n  isolatedbug.Box@5acf9800 C=false/R=false  </p>\n</blockquote>\n\n<p>The time when it switches from <code>true</code> to <code>false</code>, seems to depend on the number of calls the method, as with longer sleeps in between, it takes longer to switch.</p>\n\n<p>I am running this, for full information on Windows 8 64-bit, with as <code>java -version</code>:</p>\n\n<blockquote>\n  <p>java version \"1.8.0\"<br>\n  Java(TM) SE Runtime Environment (build 1.8.0-b129)<br>\n  Java HotSpot(TM) 64-Bit Server VM (build 25.0-b69, mixed mode)  </p>\n</blockquote>\n\n<p>Can anyone explain to me what is going on?<br>\nI'd also appreciate if others with Java 8 -any build-, could run and see if they have the same issue.</p>\n\n<p>Some more information after using this code:</p>\n\n<pre><code>  Properties p = System.getProperties();\n  p.list(System.out);\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>-- listing properties --\njava.runtime.name=Java(TM) SE Runtime Environment\nsun.boot.library.path=C:\\Program Files\\Java\\jdk1.8.0\\jre\\bin\njava.vm.version=25.0-b69\njava.vm.vendor=Oracle Corporation\njava.vendor.url=http://java.oracle.com/\npath.separator=;\njava.vm.name=Java HotSpot(TM) 64-Bit Server VM\nfile.encoding.pkg=sun.io\nuser.script=\nuser.country=NL\nsun.java.launcher=SUN_STANDARD\nsun.os.patch.level=\njava.vm.specification.name=Java Virtual Machine Specification\nuser.dir=C:\\Users\\Frank\\Dropbox\\NetbeansProjec...\njava.runtime.version=1.8.0-b129\njava.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment\njava.endorsed.dirs=C:\\Program Files\\Java\\jdk1.8.0\\jre\\li...\nos.arch=amd64\njava.io.tmpdir=C:\\Users\\Frank\\AppData\\Local\\Temp\\\nline.separator=\n\njava.vm.specification.vendor=Oracle Corporation\nuser.variant=\nos.name=Windows 8.1\nsun.jnu.encoding=Cp1252\njava.library.path=C:\\Program Files\\Java\\jdk1.8.0\\bin;C:...\njava.specification.name=Java Platform API Specification\njava.class.version=52.0\nsun.management.compiler=HotSpot 64-Bit Tiered Compilers\nos.version=6.3\nuser.home=C:\\Users\\Frank\nuser.timezone=\njava.awt.printerjob=sun.awt.windows.WPrinterJob\nfile.encoding=UTF-8\njava.specification.version=1.8\nuser.name=Beheerder\njava.class.path=C:\\Users\\Frank\\Dropbox\\NetbeansProjec...\njava.vm.specification.version=1.8\nsun.arch.data.model=64\njava.home=C:\\Program Files\\Java\\jdk1.8.0\\jre\nsun.java.command=isolatedbug.IsolatedBug\njava.specification.vendor=Oracle Corporation\nuser.language=nl\nawt.toolkit=sun.awt.windows.WToolkit\njava.vm.info=mixed mode\njava.version=1.8.0\njava.ext.dirs=C:\\Program Files\\Java\\jdk1.8.0\\jre\\li...\nsun.boot.class.path=C:\\Program Files\\Java\\jdk1.8.0\\jre\\li...\njava.vendor=Oracle Corporation\nfile.separator=\\\njava.vendor.url.bug=http://bugreport.sun.com/bugreport/\nsun.cpu.endian=little\nsun.io.unicode.encoding=UnicodeLittle\nsun.desktop=windows\nsun.cpu.isalist=amd64\n</code></pre>\n\n<p>I have also checked the <code>-Xint</code> VM option, when this has been used, it returns <code>true</code> as expected.</p>\n\n<p>So the conclusion seems to be that in my particular use case, the interpreted and JIT compiled/inlined variants of the code are not the same and hence it is a possibility that after the interpreted code is compiled it switches from interpreted to compiled and thus clarifying the switch in output.</p>\n\n<p>Adding the <code>-Xint</code> option to the actual program in which the bug occured, has also fixed the issue there.</p>\n\n<p><strong>The official bug report has been accepted: <a href=\"https://bugs.openjdk.java.net/browse/JDK-8036100?page=com.atlassian.jira.plugin.system.issuetabpanels%3acomment-tabpanel\">JIRA Bug JDK-8036100</a></strong></p>\n    ","a":"\n<p>This is a known bug in Java8.</p>\n\n<p>See this Jira: <a href=\"https://bugs.openjdk.java.net/browse/JDK-8031695\">CHA ignores default methods during analysis leading to incorrect code generation</a></p>\n\n<p><a href=\"http://johnthecodingarchitect.blogspot.ca/2014/01/major-bug-with-java-8-default-methods.html\">This blog entry is enlightening</a>....</p>\n\n<h2>Update / Summary:</h2>\n\n<ul>\n<li>issue identified before b127, and fixed in b127 ( <a href=\"https://bugs.openjdk.java.net/browse/JDK-8031695\">JDK-8031695</a> )</li>\n<li>issue reappeared (or a similar issue appeared) in b129 ( <a href=\"https://bugs.openjdk.java.net/browse/JDK-8036100\">JDK-8036100</a> )</li>\n<li>issue has been 'worked around' (<a href=\"http://hg.openjdk.java.net/hsx/hotspot-main/hotspot/rev/e46f2ee62e78\">disable the optimization that was failing</a>) in b132 ( <a href=\"https://jdk8.java.net/download.html\">available here</a> )</li>\n<li>issue also logged for a 'proper' fix for later ( <a href=\"https://bugs.openjdk.java.net/browse/JDK-8036153\">JDK-8036153</a> )</li>\n</ul>\n\n<hr>\n\n<h2>Previous Notes</h2>\n\n<p>I have reproduced this issue with:</p>\n\n<p>Claims that this issue is resolved in b127 are confusing since I see it clearly in b129 (unless I am confused about the JVM version conventions...)</p>\n\n<blockquote>\n<pre><code>C:\\Java8\\jdk-1.8.0_01\\bin&gt;java -version\njava version \"1.8.0\"\nJava(TM) SE Runtime Environment (build 1.8.0-b129)\nJava HotSpot(TM) 64-Bit Server VM (build 25.0-b69, mixed mode)\n\nC:\\Java8\\jdk-1.8.0_01\\bin&gt;\n</code></pre>\n</blockquote>\n\n<p>Adding System.out.println(System.getProperties());</p>\n\n<blockquote>\n<pre><code>{\njava.runtime.name=Java(TM) SE Runtime Environment, \njava.runtime.version=1.8.0-b129, \njava.vm.specification.name=Java Virtual Machine Specification, \njava.vm.name=Java HotSpot(TM) 64-Bit Server VM, \njava.vm.version=25.0-b69, \njava.vm.vendor=Oracle Corporation, \njava.vendor.url=http://java.oracle.com/, \njava.vm.specification.version=1.8, \njava.specification.name=Java Platform API Specification, \njava.specification.version=1.8, \njava.specification.vendor=Oracle Corporation, \njava.class.version=52.0, \nsun.boot.library.path=C:\\Java8\\jdk-1.8.0_01\\jre\\bin, \nsun.java.launcher=SUN_STANDARD, \nsun.os.patch.level=Service Pack 1, \njava.endorsed.dirs=C:\\Java8\\jdk-1.8.0_01\\jre\\lib\\endorsed, \nos.arch=amd64, \njava.vm.specification.vendor=Oracle Corporation, \nos.name=Windows 7, \nsun.jnu.encoding=Cp1252, \njava.library.path=C:\\Java8\\jdk-1.8.0_01\\bin;......, \nsun.management.compiler=HotSpot 64-Bit Tiered Compilers, \nos.version=6.1, \nfile.encoding=UTF-8, \nsun.java.command=fromso.IsolatedBug, \njava.home=C:\\Java8\\jdk-1.8.0_01\\jre, \nsun.arch.data.model=64, \nuser.language=en, \njava.ext.dirs=C:\\Java8\\jdk-1.8.0_01\\jre\\lib\\ext;C:\\windows\\Sun\\Java\\lib\\ext,\n\nsun.boot.class.path=C:\\Java8\\jdk-1.8.0_01\\jre\\lib\\resources.jar;......,\njava.vendor=Oracle Corporation, \nfile.separator=\\, \njava.vendor.url.bug=http://bugreport.sun.com/bugreport/, \nsun.io.unicode.encoding=UnicodeLittle, \nsun.cpu.endian=little, \nsun.desktop=windows, \nsun.cpu.isalist=amd64\n}\n</code></pre>\n</blockquote>\n    "},{"t":"Why does this Java 8 program not compile?","l":"http://stackoverflow.com/questions/23063474/why-does-this-java-8-program-not-compile","q":"\n\n<p>This program compiles fine in Java 7 (or in Java 8 with <code>-source 7</code>), but fails to compile with Java 8:</p>\n\n<pre><code>interface Iface&lt;T&gt; {}\nclass Impl implements Iface&lt;Impl&gt; {}\n\nclass Acceptor&lt;T extends Iface&lt;T&gt;&gt; {\n    public Acceptor(T obj) {}\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Acceptor&lt;?&gt; acceptor = new Acceptor&lt;&gt;(new Impl());\n    }\n}\n</code></pre>\n\n<p>Result:</p>\n\n<pre><code>Main.java:10: error: incompatible types: cannot infer type arguments for Acceptor&lt;&gt;\n        Acceptor&lt;?&gt; acceptor = new Acceptor&lt;&gt;(new Impl());\n                                           ^\n    reason: inference variable T has incompatible bounds\n      equality constraints: Impl\n      upper bounds: Iface&lt;CAP#1&gt;,Iface&lt;T&gt;\n  where T is a type-variable:\n    T extends Iface&lt;T&gt; declared in class Acceptor\n  where CAP#1 is a fresh type-variable:\n    CAP#1 extends Iface&lt;CAP#1&gt; from capture of ?\n1 error\n</code></pre>\n\n<p>In other words, this is a <em>backwards</em> source incompatibility between Java 7 and 8. I've gone through <a href=\"http://www.oracle.com/technetwork/java/javase/8-compatibility-guide-2156366.html#A999198\">Incompatibilities between Java SE 8 and Java SE 7</a> list but did not found anything that would fit my problem.</p>\n\n<p>So, is this a bug?</p>\n\n<p>Environment:</p>\n\n<pre><code>$ /usr/lib/jvm/java-8-oracle/bin/java -version\njava version \"1.8.0\"\nJava(TM) SE Runtime Environment (build 1.8.0-b132)\nJava HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode)\n</code></pre>\n    ","a":"\n<p>Thanks for the report. This looks like a bug. I will take care of it and probably add a better answer once we have more information about why this is happening. I have filed this bug entry <a href=\"https://bugs.openjdk.java.net/browse/JDK-8043926\">JDK-8043926</a>, to track it.</p>\n    "},{"t":"Java 8 Lambda function that throws exception?","l":"http://stackoverflow.com/questions/18198176/java-8-lambda-function-that-throws-exception","q":"\n\n<p>I know how to create a reference to a method that has a String parameter and returns an int, it's:</p>\n\n<pre><code>Function&lt;String, Integer&gt;\n</code></pre>\n\n<p>However, this doesn't work if the function throws an exception, say it's defined as:</p>\n\n<pre><code>Integer myMethod(String s) throws IOException\n</code></pre>\n\n<p>How would I define this reference?</p>\n    ","a":"\n<blockquote>\n  <p>How would I define this reference?</p>\n</blockquote>\n\n<p>You can't. You'll need to do one of the following.</p>\n\n<p>Define your own functional interface that declares the checked exception:</p>\n\n<pre><code> @FunctionalInterface\n public interface FunctionThatThrows&lt;T, R&gt; {\n     R apply(T t) throws IOException;\n }\n</code></pre>\n\n<p>Wrap <code>Integer myMethod(String s)</code> in a method that doesn't declare a checked exception:</p>\n\n<pre><code>public Integer myWrappedMethod(String s) {\n    try {\n        return myMethod(s);\n    }\n    catch(IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n</code></pre>\n\n<p>and then</p>\n\n<pre><code>Function&lt;String, Integer&gt; f = (String t) -&gt; myWrappedMethod(t);\n</code></pre>\n\n<p>or</p>\n\n<pre><code>Function&lt;String, Integer&gt; f =\n    (String t) -&gt; {\n        try {\n            return myMethod(t);\n        }\n        catch(IOException e) {\n            throw new RuntimeException(e);\n        }\n    };\n</code></pre>\n\n<p><a href=\"http://stackoverflow.com/users/829571/assylias\">@assylias</a> makes a great point that if you're trying to use this with <a href=\"http://download.java.net/lambda/b81/docs/api/java/util/stream/Stream.html#map%28java.util.function.Function%29\"><code>Stream&lt;String&gt;.map</code></a> or some other method expecting a <code>Function&lt;T, R&gt;</code>, you have <em>no</em> choice but to catch and rethrow as an unchecked exception.</p>\n    "},{"t":"Removing Java 8 JDK from Mac","l":"http://stackoverflow.com/questions/19039752/removing-java-8-jdk-from-mac","q":"\n\n<p>So I installed the beta of JDK 8 a while ago to look at some of the examples. I thought for sure by now, it's easy to change between versions. </p>\n\n<p>Doing some Play development with IntelliJ. For some reason, IntelliJ is compiling with 8 even though:</p>\n\n<ul>\n<li>I have the compiler set in Preferences to use 1.6</li>\n<li>Supposedly it's using SBT through external build, but sbt from the command line works</li>\n<li>JAVA_HOME is pointing to JDK 6.</li>\n</ul>\n\n<p>If I go to the Java Preferences page, it does show 8 installed, but there is no option to uninstall it and it doesn't see any of the other versions.</p>\n\n<p>When I do <code>which java</code>, it tells me <code>/usr/bin/java</code> and I do <code>/usr/bin/java -version</code> and it returns 1.6.</p>\n\n<p>Note: with a  little fiddling, you can use IntelliJ and JDK7, see <a href=\"http://stackoverflow.com/questions/13019199/how-do-i-run-idea-intellij-on-mac-os-x-with-jdk-7\">here</a>.</p>\n    ","a":"\n<p>I was able to unistall jdk 8 in mavericks successfully doing the following steps:</p>\n\n<pre><code>sudo rm -rf /Library/Java/JavaVirtualMachines/jdk&lt;version&gt;.jdk\nsudo rm -rf /Library/PreferencePanes/JavaControlPanel.prefPane\nsudo rm -rf /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\n</code></pre>\n    "},{"t":"installing JDK8 on Windows XP - advapi32.dll error","l":"http://stackoverflow.com/questions/20965564/installing-jdk8-on-windows-xp-advapi32-dll-error","q":"\n\n<p>I downloaded <a href=\"https://jdk8.java.net/download.html\">JDK8</a> build b121 and while trying to install I'm getting the following error:</p>\n\n<blockquote>\n  <p>the procedure entry point RegDeleteKeyExA could not be located in the dynamic link library ADVAPI32.dll</p>\n</blockquote>\n\n<p>The operating system is Windows XP, Version 2002 Service Pack 3, 32-bit.</p>\n    ","a":"\n<p>This happens because Oracle dropped support for Windows XP (which doesn't have <code>RegDeleteKeyExA</code> used by the installer in its <code>ADVAPI32.DLL</code> by the way) as described in <a href=\"http://mail.openjdk.java.net/pipermail/openjfx-dev/2013-July/009005.html\">http://mail.openjdk.java.net/pipermail/openjfx-dev/2013-July/009005.html</a>. Yet while the official support for XP has ended, the Java binaries are still (as of Java 8u20 EA b05 at least) XP-compatible - only the installer isn't...</p>\n\n<p>Because of that, the solution is actually quite easy:</p>\n\n<ol>\n<li><p>get 7-zip (or any other quality archiver), unpack the distribution .exe manually, it has one .zip file inside of it (<code>tools.zip</code>), extract it too,</p></li>\n<li><p>use <code>unpack200</code> from JDK8 to unpack all .pack files to .jar files (older unpacks won't work properly); <code>JAVA_HOME</code> environment variable should be set to your Java unpack root, e.g. \"C:\\Program Files\\Java\\jdk8\" - you can specify it implicitly by e.g.</p>\n\n<pre><code>SET JAVA_HOME=C:\\Program Files\\Java\\jdk8\n</code></pre>\n\n<ul>\n<li><p>Unpack all files with a single command (in batch file):</p>\n\n<pre><code>FOR /R %%f IN (*.pack) DO \"%JAVA_HOME%\\bin\\unpack200.exe\" -r -v \"%%f\" \"%%~pf%%~nf.jar\"\n</code></pre></li>\n<li><p>Unpack all files with a single command (command line from JRE root):</p>\n\n<pre><code>FOR /R %f IN (*.pack) DO \"bin\\unpack200.exe\" -r -v \"%f\" \"%~pf%~nf.jar\"\n</code></pre></li>\n<li><p>Unpack by manually locating the files and unpacking them one-by-one:</p>\n\n<pre><code>%JAVA_HOME%\\bin\\unpack200 -r packname.pack packname.jar\n</code></pre></li>\n</ul>\n\n<p>where <code>packname</code> is for example <code>rt</code></p></li>\n<li><p>point the tool you want to use (e.g. Netbeans) to the <code>%JAVA_HOME%</code> and you're good to go.</p></li>\n</ol>\n\n<p>Note: you probably shouldn't do this just to use Java 8 in your web browser or for any similar reason (installing JRE 8 comes to mind); security flaws in early updates of major Java version releases are (mind me) <em>legendary</em>, and adding to that no real support for neither XP nor Java 8 on XP only makes matters much worse. Not to mention you usually <strong>don't</strong> need Java in your browser (see e.g. <a href=\"http://nakedsecurity.sophos.com/2013/01/15/disable-java-browsers-homeland-security/\">http://nakedsecurity.sophos.com/2013/01/15/disable-java-browsers-homeland-security/</a> - the topic is already covered on many pages, just Google it if you require further info). In any case, AFAIK the only thing required to apply this procedure to JRE is to change some of the paths specified above from \\bin\\ to \\lib\\ (the file placement in installer directory tree is a bit different) - yet I <strong>strongly</strong> advise against doing it.</p>\n\n<p>See also: <a href=\"http://stackoverflow.com/questions/1619662/how-can-i-get-the-latest-jre-jdk-as-a-zip-file-rather-than-exe-or-msi-installe\">How can I get the latest JRE / JDK as a zip file rather than EXE or MSI installer?</a>, <a href=\"http://stackoverflow.com/questions/11808829/jre-1-7-returns-java-lang-noclassdeffounderror-java-lang-object\">JRE 1.7 returns: java/lang/NoClassDefFoundError: java/lang/Object</a></p>\n    "},{"t":"Java 8 default methods as traits : safe?","l":"http://stackoverflow.com/questions/28681737/java-8-default-methods-as-traits-safe","q":"\n\n<p>Is it a safe practice to use <strong>default methods as a poor's man version of traits</strong> in Java 8?</p>\n\n<p><a href=\"http://zeroturnaround.com/rebellabs/how-your-addiction-to-java-8-default-methods-may-make-pandas-sad-and-your-teammates-angry/\">Some claim it may make pandas sad</a> if you use them just for the sake of it, because it's cool, but that's not my intention. It is also often reminded that default methods were introduced to support API evolution and backward compatibility, which is true, but this does not make it wrong or twisted to use them as traits per se.</p>\n\n<p>I have <a href=\"http://www.opencredo.com/2015/01/30/traits-java-8-default-methods/\">the following practical use case</a> in mind:</p>\n\n<pre><code>public interface Loggable {\n    default Logger logger() {\n        return LoggerFactory.getLogger(this.getClass());\n    }\n}\n</code></pre>\n\n<p>Or perhaps, define a <code>PeriodTrait</code>:</p>\n\n<pre><code>public interface PeriodeTrait {\n    Date getStartDate();\n    Date getEndDate();\n    default isValid(Date atDate) {\n        ...\n    }\n}\n</code></pre>\n\n<p>Admitedly, composition could be used (or even helper classes) but it seems more verbose and cluttered and does not allow to benefit from polymorphism.</p>\n\n<p>So, <strong>is it ok/safe to use default methods as basic traits</strong>, or should I be worried about unforeseen side effects?</p>\n\n<p><a href=\"http://stackoverflow.com/search?q=java+default+method+trait\">Several questions</a> on SO are related to Java vs Scala traits; that's not the point here. I'm not asking merely for opinions either. Instead, I'm looking for an authoritative answer or at least field insight: if you've used default methods as traits on your corporate project, did it turn out to be a timebomb?</p>\n    ","a":"\n<p>The short answer is: it's safe if you use them safely :)  </p>\n\n<p>The snarky answer: tell me what <em>you</em> mean by traits, and maybe I'll give you a better answer :)  </p>\n\n<p>In all seriousness, the term \"trait\" is not well-defined.  Many Java developers are most familiar with traits as they are expressed in Scala, but Scala is far from the first language to have traits, either in name or in effect.  </p>\n\n<p>For example, in Scala, traits are stateful (can have <code>var</code> variables); in Fortress they are pure behavior.  Java's interfaces with default methods are stateless; does this mean they are not traits?  (Hint: that was a trick question.)  </p>\n\n<p>Again, in Scala, traits are composed through linearization; if class <code>A</code> extends traits <code>X</code> and <code>Y</code>, then the order in which <code>X</code> and <code>Y</code> are mixed in determines how conflicts between <code>X</code> and <code>Y</code> are resolved.  In Java, this linearization mechanism is not present (it was rejected, in part, because it was too \"un-Java-like\".)  </p>\n\n<p>The proximate reason for adding default methods to interfaces was to support <em>interface evolution</em>, but we were well aware that we were going beyond that.  Whether you consider that to be \"interface evolution++\" or \"traits--\" is a matter of personal interpretation.  So, to answer your question about safety ... so long as you stick to what the mechanism actually supports, rather than trying to wishfully stretch it to something it does not support, you should be fine.</p>\n\n<p>A key design goal was that, from the perspective of the <em>client</em> of an interface, default methods should be indistinguishable from \"regular\" interface methods.  The default-ness of a method, therefore, is only interesting to the <em>designer</em> and <em>implementor</em> of the interface.  </p>\n\n<p>Here are some use cases that are well within the design goals:</p>\n\n<ul>\n<li><p>Interface evolution.  Here, we are adding a new method to an existing interface, which has a sensible default implementation in terms of existing methods on that interface.  An example would be adding the <code>forEach</code> method to <code>Collection</code>, where the default implementation is written in terms of the <code>iterator()</code> method.  </p></li>\n<li><p>\"Optional\" methods.  Here, the designer of an interface is saying \"Implementors need not implement this method if they are willing to live with the limitations in functionality that entails\".  For example, <code>Iterator.remove</code> was given a default which throws <code>UnsupportedOperationException</code>; since the vast majority of implementations of <code>Iterator</code> have this behavior anyway, the default makes this method essentially optional.  (If the behavior from <code>AbstractCollection</code> were expressed as defaults on <code>Collection</code>, we might do the same for the mutative methods.)  </p></li>\n<li><p>Convenience methods.  These are methods that are strictly for convenience, again generally implemented in terms of non-default methods on the class.  The <code>logger()</code> method in your first example is a reasonable illustration of this.</p></li>\n<li><p>Combinators.  These are compositional methods that instantiate new instances of the interface based on the current instance.  For example, the methods <code>Predicate.and()</code> or <code>Comparator.thenComparing()</code> are examples of combinators.  </p></li>\n</ul>\n\n<p>If you provide a default implementation, you should also provide some specification for the default (in the JDK, we use the <code>@implSpec</code> javadoc tag for this) to aid implementors in understanding whether they want to override the method or not.  Some defaults, like convenience methods and combinators, are almost never overridden; others, like optional methods, are often overridden.  You need to provide enough specification (not just documentation) about what the default promises to do, so the implementor can make a sensible decision about whether they need to override it.</p>\n    "},{"t":"Differences between Java 8 Date Time API (java.time) and Joda-Time","l":"http://stackoverflow.com/questions/24631909/differences-between-java-8-date-time-api-java-time-and-joda-time","q":"\n\n<p>I know there are questions relating to <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Date.html\">java.util.Date</a> and Joda-Time. But after some digging, I couldn't find a thread about the differences between the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html\">java.time API</a> (new in <a href=\"http://en.wikipedia.org/wiki/Java_version_history#Java_SE_8_.28March_18.2C_2014.29\">Java 8</a>, defined by <a href=\"https://jcp.org/en/jsr/detail?id=310\">JSR 310</a>) and <a href=\"http://www.joda.org/joda-time/\">Joda-Time</a>.</p>\n\n<p>I have heard that Java 8’s java.time API is much cleaner and can do much more than Joda-Time. But I cannot find examples comparing the two. </p>\n\n<ul>\n<li>What can java.time do that Joda-Time cannot? </li>\n<li>What can java.time do better than Joda-Time? </li>\n<li>Is the performance better with java.time?</li>\n</ul>\n    ","a":"\n<p><strong>Common features</strong></p>\n\n<p>a) Both libraries use immutable types. Joda-Time also offers additional mutable types like <code>MutableDateTime</code>. </p>\n\n<p>b) Furthermore: Both libraries are inspired by the design study <a href=\"http://timeandmoney.sourceforge.net/\">\"TimeAndMoney\" from Eric Evans</a> or ideas from <a href=\"http://martinfowler.com/tags/domain%20driven%20design.html\">Martin Fowler about domain driven style</a> so they strive more or less for a <a href=\"http://en.wikipedia.org/wiki/Fluent_interface\">fluent programming style</a> (although not always perfect ;-)).</p>\n\n<p>c) With both libraries we get a real calendar date type (called <code>LocalDate</code>), a real wall time type (called <code>LocalTime</code>) and the composition (called <code>LocalDateTime</code>). That is a very big win compared with old <code>java.util.Calendar</code> and <code>java.util.Date</code>.</p>\n\n<p>d) Both libraries use a method-centric approach meaning they encourage the user to use <code>getDayOfYear()</code> instead of <code>get(DAY_OF_YEAR)</code>. This causes a lot of extra methods compared with <code>java.util.Calendar</code> (although latter is not type-safe at all due to excessive use of ints).</p>\n\n<p><strong>Performance</strong></p>\n\n<p>See the other answer by @OO7 pointing to the analysis of Mikhail Vorontsov although point 3 (exception catching) is probably obsolete - see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8046707\">this JDK-bug</a>. The different performance (which is in general favour of <a href=\"https://jcp.org/en/jsr/detail?id=310\">JSR-310</a>) is mainly due to the fact that the internal implementation of <a href=\"http://www.joda.org/joda-time/\">Joda-Time</a> always use a machine-time-like long-primitive (in milliseconds).</p>\n\n<p><strong>Null</strong></p>\n\n<p>Joda-Time often use NULL as default for system timezone, default locale, current timestamp etc. while JSR-310 almost always rejects NULL values.</p>\n\n<p><strong>Precision</strong></p>\n\n<p>JSR-310 handles <a href=\"http://en.wikipedia.org/wiki/Nanosecond\">nanonsecond</a> precision while Joda-Time is limited to <a href=\"http://en.wikipedia.org/wiki/Millisecond\">millisecond</a> precision. </p>\n\n<p><strong>Supported fields:</strong></p>\n\n<p>An overview about supported fields in Java-8 (JSR-310) is given by some classes in the temporal-package (for example <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoField.html\">ChronoField</a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html\">WeekFields</a>) while Joda-Time is rather weak on this area - see <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeFieldType.html\">DateTimeFieldType</a>. The biggest lack of Joda-Time is here the absence of localized week-related fields. A common feature of both field implementation design is that both are based on values of type long (no other types, not even enums).</p>\n\n<p><strong>Enum</strong></p>\n\n<p>JSR-310 offers <a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html\">enums</a> like <code>DayOfWeek</code> or <code>Month</code> while Joda-Time does not offer this because it was mainly developed in years 2002-2004 before <a href=\"http://en.wikipedia.org/wiki/Java_version_history#J2SE_5.0_.28September_30.2C_2004.29\">Java 5</a>.</p>\n\n<p><strong>Zone API</strong></p>\n\n<p>a) JSR-310 offers more timezone features than Joda-Time. Latter is not able to yield a programmatical access to the history of timezone offset transitions while JSR-310 is capable to do this.</p>\n\n<p>b) For your information: JSR-310 has moved its internal timezone repository to a new location and a different format. The old library folder lib/zi does not exist any more.</p>\n\n<p><strong>Adjuster vs. Property</strong></p>\n\n<p>JSR-310 has introduced the <code>TemporalAdjuster</code>-interface as a formalized way to externalize temporal calculations and manipulations, especially for library or framework-writers this is a nice and relative easy way to embed new extensions of JSR-310 (a kind of equivalent to static helper classes for former <code>java.util.Date</code>).</p>\n\n<p>For most users however, this feature has very limited value because the burden to write code is still with the user. Built-in solutions based on the new <code>TemporalAdjuster</code>-concept are not so many, there is currently only the helper class <code>TemporalAdjusters</code> with a limited set of manipulations (and the enums <code>Month</code> or other temporal types). </p>\n\n<p>Joda-Time offers a field-package but practice has shown evidence that new field implementations are very hard to code. On the other side Joda-Time offers so-called properties which make some manipulations much easier and more elegant than in JSR-310, for example <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTime.Property.html#withMaximumValue()\">property.withMaximumValue()</a>.</p>\n\n<p><strong>Calendar systems</strong></p>\n\n<p>JSR-310 offers 4 extra calendar systems. The most interesting one is <a href=\"http://en.wikipedia.org/wiki/Islamic_calendar#Saudi_Arabia.27s_Umm_al-Qura_calendar\">Umalqura</a> (used in Saudi Arabia). The other 3 are: <a href=\"http://en.wikipedia.org/wiki/Minguo_calendar\">Minguo</a> (Taiwan), Japanese (only the modern calendar since 1871!) and <a href=\"http://en.wikipedia.org/wiki/Buddhist_calendar\">ThaiBuddhist</a> (only correct after 1940).</p>\n\n<p>Joda-Time offers an <a href=\"http://joda-time.sourceforge.net/cal_islamic.html\">Islamic calendar</a> based on calculatory base - not a sighting-based calendar like Umalqura. Thai-Buddhist is also offered by Joda-Time in a similar form, Minguo and the japanese one not. Otherwise Joda-Time offers coptic and ethiopic calendar, too (I cannot say anything about the quality and correctness here).</p>\n\n<p>More interesting for Europeans: Joda-Time also offers a <a href=\"http://en.wikipedia.org/wiki/Gregorian_calendar\">Gregorian</a>, <a href=\"http://en.wikipedia.org/wiki/Julian_calendar\">Julian</a> and mixed-gregorian-julian calendar. However, the practical value for real historical calculations is limited because important features like different year starts in date history are not supported at all (the same criticism is valid for old <code>java.util.GregorianCalendar</code>).</p>\n\n<p>Other calendars like <a href=\"http://en.wikipedia.org/wiki/Hebrew_calendar\">Hebrew</a> or <a href=\"http://en.wikipedia.org/wiki/Iranian_calendars\">Persian</a> or <a href=\"http://en.wikipedia.org/wiki/Hindu_calendar\">Hindu</a> are completely missing in both libraries.</p>\n\n<p><strong>Epoch days</strong></p>\n\n<p>JSR-310 has the class <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/temporal/JulianFields.html\">JulianFields</a> while Joda-Time (version 2.0) offers some helper methods in the class <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeUtils.html#fromJulianDay(double)\">DateTimeUtils</a>.</p>\n\n<p><strong>Clocks</strong></p>\n\n<p>JSR-310 has no interface (a design mistake) but an abstract class <code>java.time.Clock</code> which can be used for any clock dependency injection. Joda-Time offers the interface <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeUtils.MillisProvider.html\">MillisProvider</a> and some helper methods in <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/DateTimeUtils.html#setCurrentMillisProvider(org.joda.time.DateTimeUtils.MillisProvider)\">DateTimeUtils</a> instead. So this way Joda-Time is also capable of supporting test-driven models with different clocks (mocking etc.).</p>\n\n<p><strong>Duration arithmetic</strong></p>\n\n<p>Both libraries support the calculation of time distances in one or more temporal units. However, when handling single-unit-durations the JSR-310-style is obviously nicer (and long-based instead of using int):</p>\n\n<p>JSR-310 =&gt; <code>long days = ChronoUnit.DAYS.between(date1, date2);</code></p>\n\n<p>Joda-Time =&gt; <code>int days = DAYS.daysBetween(date1, date2).getDays();</code></p>\n\n<p>Handling of multiple-unit-durations are also different. Even the calculation results can differ - see this closed <a href=\"https://github.com/JodaOrg/joda-time/issues/132\">Joda-Time issue</a>. While JSR-310 use a very simple and limited approach to use just the classes <code>Period</code> (duration based on years, months and days) and <code>Duration</code> (based on seconds and nanoseconds), Joda-Time uses a more sophisticated way using the class <code>PeriodType</code> in order to control in which units a duration (Joda-Time call it \"Period\") shall be expressed. While the <code>PeriodType</code>-API is somehow awkward to use a similar way is not offered by JSR-310 at all. Especially it is not yet possible in JSR-310 to define mixed date and time durations (based on days and hours for example). So be warned if it comes to migration from one library to another. The libraries in discussion are incompatible - despite of partially same class names.</p>\n\n<p><strong>Intervals</strong></p>\n\n<p>JSR-310 does not support this feature while Joda-Time has limited support. See also this <a href=\"https://stackoverflow.com/questions/22150722/is-there-a-class-in-java-time-comparable-to-the-joda-time-interval/22152890#22152890\">SO-answer</a>.</p>\n\n<p><strong>Formatting and Parsing</strong></p>\n\n<p>Best way to compare both libraries is to view the equal-named classes <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatterBuilder.html\">DateTimeFormatterBuilder</a> (JSR-310) and <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormatterBuilder.html\">DateTimeFormatterBuilder</a> (Joda-Time). The JSR-310-variant is a little bit more powerful (can also handle any kind of <code>TemporalField</code> provided the field implementor has managed to code some extension points like <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html#resolve-java.util.Map-java.time.temporal.TemporalAccessor-java.time.format.ResolverStyle-\">resolve()</a>). Most important difference is however - in my opinion: JSR-310 can much better parse timezone names (format pattern symbol z) while Joda-Time could not do this at all in its earlier versions and now only in a very limited way.</p>\n\n<p>Otherwise it should be noted that Joda-Time can format durations using <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/format/PeriodFormatter.html\">PeriodFormatter</a>. JSR-310 cannot do this.</p>\n\n<hr>\n\n<p>Hope this overview helps. All the gathered information is mainly there due to my efforts and investigations how to design and implement a better date-and-time library (nothing is perfect).</p>\n\n<p><strong>Update from 2015-06-24:</strong></p>\n\n<p>Meanwhile I have found the time to write and <a href=\"http://time4j.net/tutorial/appendix.html\">publish a tabular overview</a> for different time libraries in Java. The tables also contain a comparison between Joda-Time v2.8.1 and Java-8 (JSR-310). It is more detailed than this post.</p>\n    "},{"t":"Are defaults in JDK 8 a form of multiple inheritance in Java?","l":"http://stackoverflow.com/questions/7857832/are-defaults-in-jdk-8-a-form-of-multiple-inheritance-in-java","q":"\n\n<p>A new feature coming in JDK 8 allows you to add to an existing interface while preserving binary compatibility.</p>\n\n<p>The syntax is like</p>\n\n<pre><code>public interface SomeInterface() {\n  void existingInterface();\n  void newInterface() default SomeClass.defaultImplementation;\n}\n</code></pre>\n\n<p>This way for all existing implementations of <code>SomeInterface</code> when they upgrade to this new version they don't all suddenly have compiles errors around <code>newInterface()</code>.</p>\n\n<p>While this is neat, what happens when you are implementing two interfaces which both have added a new defaulted method which you did not implement?  Let me explain with an example.</p>\n\n<pre><code>public interface Attendance {\n   boolean present() default DefaultAttendance.present;\n}\n\npublic interface Timeline {\n   boolean present() default DefaultTimeline.present;\n}\n\npublic class TimeTravelingStudent implements Attendance, Timeline {\n}\n\n// which code gets called?\nnew TimeTravelingStudent().present();\n</code></pre>\n\n<p>Has this been defined as part of JDK 8 yet?</p>\n\n<p>I found the Java gods talking about something similar here <a href=\"http://cs.oswego.edu/pipermail/lambda-lib/2011-February/000068.html\">http://cs.oswego.edu/pipermail/lambda-lib/2011-February/000068.html</a>, but its part of private mailing list and I cannot ask them directly.</p>\n\n<p>See this for more details on how defaults are going to be used in JDK 8 and extending the Collection interface to support lambdas:\n<a href=\"https://oracleus.wingateweb.com/published/oracleus2011/sessions/25066/25066_Cho223662.pdf\">https://oracleus.wingateweb.com/published/oracleus2011/sessions/25066/25066_Cho223662.pdf</a></p>\n    ","a":"\n<p>The video session to watch is here <a href=\"http://medianetwork.oracle.com/video/player/1113272518001\">http://medianetwork.oracle.com/video/player/1113272518001</a> This is the designer talking about the feature called Virtual Extensions. He also talks about how this doesn't break backward compatibility.</p>\n    "},{"t":"“Why Apache Harmony” or “How to use Java 8 on Android”","l":"http://stackoverflow.com/questions/16921337/why-apache-harmony-or-how-to-use-java-8-on-android","q":"\n\n<p>Note: I didn't know where to put this question, it did look out of place on <em>Android Enthusiasts</em>. Please forgive me :)</p>\n\n<p>So, most of us have heard by now of the cool features Java 8 will bring, but Android will not support it. This is because of Google using <a href=\"http://en.wikipedia.org/wiki/Apache_Harmony\">Apache Harmony</a> for Android. This is what is keeping us (the android app developers) from improving our code with lambdas, default implementations in interfaces, switching on a String and a lot more. Surely, we will handle for some time, but what if some libraries we use in our apps start to use Java 8 features? As far as I know, this will not work (please correct me if wrong). This creates incompatibility between <em>Standard</em>-Java and <em>Android</em>-Java. It cannot be what Google intends, or at least I can't think of a reason why a company, developing a widely adopted operating system, would wan't to permanently stay with an <em>old</em> Java version.</p>\n\n<p>Questions to you:  </p>\n\n<ul>\n<li>Why do they use Apache Harmony?</li>\n<li>Why can't they adopt a newer version of java?</li>\n<li>If they don't want Oracle's Java, why can't they use a subset of <a href=\"http://openjdk.java.net/\">OpenJDK</a> (licensing noob here)?</li>\n<li>Do you know of any plans to update the used Java version?</li>\n<li>Do you know of any way to use Java 8 classes on current Android systems?</li>\n</ul>\n\n<p>Thank you in advance for answering any of these questions.</p>\n    ","a":"\n<blockquote>\n  <p>Why do they use Apache Harmony?</p>\n</blockquote>\n\n<p>Because Sun refused to provide Google with a license for Sun (now Oracle) Java under terms that were acceptable.  Google and Sun negotiated, but they ended up walking away from the deal.</p>\n\n<p><sup>Nitpick: in fact, the Android libraries are not Apache Harmony.  They started out as based on Harmony, but the two codebases have diverged.  Furthermore, the Apache Harmony project was officially \"retired\" in November 2011.</sup></p>\n\n<blockquote>\n  <p>Why can't they adopt a newer version of java?</p>\n</blockquote>\n\n<p>Firstly, Android does not run Java(tm).  It runs a language that is identical to Java with a class library that is functionally equivalent to a <em>subset</em> of the Java class library (+ Android-specific libraries), on a virtual machine with a <em>different</em> instruction set.</p>\n\n<p>From a technical pespective, they could ... but only if they put in a lot of work into implementing Java 7 and Java 8 language features, library features, etc, for the Android platform.</p>\n\n<p><strong>UPDATE</strong> - As of Android 19 (KitKat) and Eclipse ADT 22.6, Android does now support the Java 7 language extensions; see <a href=\"http://tools.android.com/recent/eclipseadt226preview\" rel=\"nofollow\">http://tools.android.com/recent/eclipseadt226preview</a></p>\n\n<blockquote>\n  <p>If they don't want Oracle's Java, why can't they use a subset of OpenJDK?</p>\n</blockquote>\n\n<p>I don't think that switching to OpenJDK would change anything.  Oracle Java and OpenJDK are 99.9% the same.  </p>\n\n<p>Anyway, there may be licensing and related legal issues.  (And to get a feel for that, read up on the Oracle vs Google lawsuit ... that is going to appeal.)</p>\n\n<p>More likely, Google doesn't see enough commercial value to counteract the (massive) effort it would take to change, and the disruption it would cause to the Android ecosystem ... which already suffers from problems with fragmentation.</p>\n\n<blockquote>\n  <p>Do you know of any plans to update the used Java version?</p>\n</blockquote>\n\n<p>No I don't.  It doesn't mean that there aren't plans, but if there are, they are not public.</p>\n\n<blockquote>\n  <p>Do you know of any way to use Java 8 classes on current Android systems?</p>\n</blockquote>\n\n<p>You could port them.  Or at least, you could <em>try</em> to port them.  (Some Java APIs have an intimate relationship with the native code side of the JVM ... and that could make porting problematic.)</p>\n    "},{"t":"will android java support lambda expression in java 8? [closed]","l":"http://stackoverflow.com/questions/14818348/will-android-java-support-lambda-expression-in-java-8","q":"\n\n<p>I understand that the \"java\" in a dalvik vm is different from Java se in terms of API and architecture etc. But the syntax has always been the same. (Please correct me if I am wrong)</p>\n\n<p>Now the support of <a href=\"http://openjdk.java.net/projects/lambda/\">lambda expression in java 8</a> is about to be released, will android java follow it? did google or aosp promise on making dalvik consistent with java se?</p>\n\n<p>UPDATE: Now as in Android 4.4 Kit Kat (API 19), Java 7 syntax has been OFFICIALLY supported.<a href=\"http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Using-sourceCompatibility-1.7\">Source from android.com</a></p>\n    ","a":"\n<p>Android doesn't use Oracle's Java SE versions, <a href=\"http://stackoverflow.com/questions/7535385/how-does-androids-java-version-relate-to-a-java-se-version\">it's based on parts of the Apache Harmony project</a> so it doesn't even support Java 7. Harmony is not actively developed any more and won't support 1.7.</p>\n\n<p>Unless Google decides to upgrade Harmony and the Android SDK to a newer Java version, there won't be any Java 7 or Java 8 features in Android - even if new features are just syntactical. They could use an alternative implementation like the <em>OpenJDK</em>, though I don't know of any plans for this. Some people think the use of OpenJDK is unlikely because of lawsuits between Google and Oracle.</p>\n    "},{"t":"JDK8 and Javadoc has become very strict","l":"http://stackoverflow.com/questions/22528767/jdk8-and-javadoc-has-become-very-strict","q":"\n\n<p>You'll quickly realize that JDK8 is a lot more strict (by default) when it comes to Javadoc. (<a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/whatsnew-8.html\">link</a> - see last bullet point)</p>\n\n<p>If you never generate any Javadoc then of course you'll not experience any problems but things like Maven release process and possibly your CI builds will suddenly fail where they worked just fine with JDK7. Anything that checks the exit value of the Javadoc tool will now fail. JDK8 Javadoc is probably also more verbose in terms of <code>warnings</code> compared to JDK7 but that's not the scope here. We are talking about <code>errors</code>!</p>\n\n<p>This question exist to collect proposals on what to do about it. What is the best approach ?  Should these errors be fixed once and for all in the source code files? If you have a huge code base this might be a lot of work. What other options exist ?</p>\n\n<p>You are also welcome to comment with stories of what now fails that would previously pass.</p>\n\n<h2>Horror stories of what now fails</h2>\n\n<h3>wsimport tools</h3>\n\n<p><code>wsimport</code> tool is a code generator for creating web service consumers. It is included in the JDK. Even if you use the <code>wsimport</code> tool from JDK8 it will nevertheless produce source code <a href=\"http://stackoverflow.com/questions/24495579/jdk8-not-working-with-jdk8-ws-client\">that cannot be compiled with the javadoc compiler from JDK8</a>.</p>\n\n<h3>@author tag</h3>\n\n<p>I'm opening up source code files 3-4 years old and see this:</p>\n\n<pre><code>/**\n * My very best class\n * @author John &lt;john.doe@mine.com&gt; \n */\n</code></pre>\n\n<p>This now fails because of the &lt; character. Strictly speaking this is justified, but not very forgiving.</p>\n\n<h3>HTML tables</h3>\n\n<p>HTML Tables in your Javadoc?  Consider this valid HTML:</p>\n\n<pre><code>/**\n *\n * &lt;table&gt;\n *   &lt;tr&gt;\n *      &lt;td&gt;Col1&lt;/td&gt;&lt;td&gt;Col2&lt;/td&gt;&lt;td&gt;Col3&lt;/td&gt;\n *   &lt;/tr&gt;\n * &lt;/table&gt;\n */\n</code></pre>\n\n<p>This now fails with error message <code>no summary or caption for table</code>. One quick fix is to do like this:</p>\n\n<pre><code>/**\n *\n * &lt;table summary=\"\"&gt;\n *   &lt;tr&gt;\n *      &lt;td&gt;Col1&lt;/td&gt;&lt;td&gt;Col2&lt;/td&gt;&lt;td&gt;Col3&lt;/td&gt;\n *   &lt;/tr&gt;\n * &lt;/table&gt;\n */\n</code></pre>\n\n<p>but why this has to be a stop-the-world error from Javadoc tool beats me??</p>\n\n<h2>Things that now fail for more obvious reasons</h2>\n\n<ol>\n<li>Invalid links, e.g. <code>{@link notexist}</code></li>\n<li>Malformed HTML, e.g. <code>always returns &lt;code&gt;true&lt;code&gt; if ...</code></li>\n</ol>\n\n<h2>UPDATE</h2>\n\n<p>Links:</p>\n\n<p>Excellent <a href=\"http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html\">blog on the subject</a> by <a href=\"https://www.blogger.com/profile/01454237967846880639\">Stephen Colebourne</a>.</p>\n    ","a":"\n<p>If you are using the maven javadoc plugin, you can use the <code>failOnError</code> option to prevent it from stopping if it finds any html errors:</p>\n\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;plugin&gt;\n  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n  &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;\n  &lt;configuration&gt;\n    &lt;failOnError&gt;false&lt;/failOnError&gt;\n  &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>\n\n<p>Or you can deactivate the strict html options completely with:</p>\n\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;plugin&gt;\n  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n  &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n      &lt;additionalparam&gt;-Xdoclint:none&lt;/additionalparam&gt;\n    &lt;/configuration&gt;\n  &lt;/plugin&gt;\n&lt;/plugins&gt;\n</code></pre>\n\n<p>For more <a href=\"http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html\" rel=\"nofollow\">info</a>.</p>\n    "},{"t":"What are “sugar”, “desugar” terms in context of Java 8?","l":"http://stackoverflow.com/questions/22060894/what-are-sugar-desugar-terms-in-context-of-java-8","q":"\n\n<p>I hear about 'sugaring' and 'desugaring' more often in Java 8, what does these terms mean ? are they conceptual or syntactical.</p>\n\n<p>Some Example:</p>\n\n<blockquote>\n  <p>Default iterated loop resugaring to java </p>\n  \n  <p>Observations about syntactic sugar in compilation.</p>\n</blockquote>\n    ","a":"\n<p><em>sugar</em>, in programming, usually refers to those <em>sweet</em> additions, mostly shortcuts, that make some constructs easier to type and to read (the latter being, in practice, the most important during the life cycle of your program).</p>\n\n<p>Wikipedia has a definition of <a href=\"http://en.wikipedia.org/wiki/Syntactic_sugar\">syntactic sugar</a> but you should note that not all sugar is, in essence, syntactical (not all recent sweet additions were just compiler changes). </p>\n\n<p>Here are a few examples :</p>\n\n<ul>\n<li>the postfix and prefix increment operators (<code>i++</code> and <code>++i</code>). Their only purpose is to avoid writing an additional statement. They're pure sugar.</li>\n<li><code>+=</code>, <code>|=</code>, <code>&amp;=</code>, etc. are made of the same kind of sugar.</li>\n<li>Implicit conversion between primitive types and objects is sugar too.</li>\n<li>type inference is sugar too.</li>\n<li>Lambda expression, coming with Java 8, is some other kind of sugar (this one not just syntactical)</li>\n</ul>\n\n<p>Java is widely seen as not being concise enough, especially compared to modern languages. That's why those additions that help make the code faster to read are welcome.</p>\n\n<p>To finish, I'd just note that while a lack of sugar can make your program fat, an excess of sugar, leading to many different ways to write the same things, can make your language queasy and your program less coherent and harder to maintain. Another kind of sugar, API sugar, is most often a plague which makes the API harder to grasp, especially when it's made of additions (overloading for example). Desugaring is the process by which you remove all that is redundant.</p>\n    "},{"t":"Maximum size of a method in Java 7 and 8","l":"http://stackoverflow.com/questions/17422480/maximum-size-of-a-method-in-java-7-and-8","q":"\n\n<p>I know that a method cannot be larger than 64&nbsp;KB with Java. The limitation causes us problems with generated code from a <a href=\"http://en.wikipedia.org/wiki/JavaCC\">JavaCC</a> grammar. We had problems with Java 6 and were able to fix this by changing the grammar. Has the limit been changed for Java 7 or is it planned for Java 8?</p>\n\n<p>Just to make it clear. I don't need a method larger than 64&nbsp;KB by myself. But I wrote a grammar which compiles to a very large method.</p>\n    ","a":"\n<p>According to <a href=\"http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.3\" rel=\"nofollow\">JVMS7</a> :</p>\n\n<blockquote>\n  <p>The fact that end_pc is exclusive is a historical mistake in the\n  design of the Java virtual machine: if the Java virtual machine code\n  for a method is exactly 65535 bytes long and ends with an instruction\n  that is 1 byte long, then that instruction cannot be protected by an\n  exception handler. A compiler writer can work around this bug by\n  limiting the maximum size of the generated Java virtual machine code\n  for any method, instance initialization method, or static initializer\n  (the size of any code array) to 65534 bytes.</p>\n</blockquote>\n\n<p>But this is about <code>Java 7</code>. <strike>There is no final specs for Java 8, so nobody (except its developers) could answer this question.</strike></p>\n\n<p><strong>UPD (2015-04-06)</strong> According to <a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7\" rel=\"nofollow\">JVM8</a> it is also true for <code>Java 8</code>.</p>\n    "},{"t":"Converting between java.time.LocalDateTime and java.util.Date","l":"http://stackoverflow.com/questions/19431234/converting-between-java-time-localdatetime-and-java-util-date","q":"\n\n<p>Java 8 has a completely new API for date and time. One of the most useful classes in this API is <code>LocalDateTime</code>, for holding a timezone-independent date-with-time value. </p>\n\n<p>There are probably millions of lines of code using the legacy class <code>java.util.Date</code> for this purpose. As such, when interfacing old and new code there will be a need for converting between the two. As there seems to be no direct methods for accomplishing this, how can it be done?</p>\n    ","a":"\n<p>Short answer:</p>\n\n<pre><code>Date in = new Date();\nLocalDateTime ldt = LocalDateTime.ofInstant(in.toInstant(), ZoneId.systemDefault());\nDate out = Date.from(ldt.atZone(ZoneId.systemDefault()).toInstant());\n</code></pre>\n\n<p>Explanation:\n(based on <a href=\"http://stackoverflow.com/questions/21242110/convert-java-util-date-to-java-time-localdate\">this question</a> about <code>LocalDate</code>)</p>\n\n<p>Despite its name, <code>java.util.Date</code> represents an instant on the time-line, not a \"date\". The actual data stored within the object is a <code>long</code> count of milliseconds since 1970-01-01T00:00Z (midnight at the start of 1970 GMT/UTC).</p>\n\n<p>The equivalent class to <code>java.util.Date</code> in JSR-310 is <code>Instant</code>, thus there are convenient methods to provide the conversion to and fro:</p>\n\n<pre><code>Date input = new Date();\nInstant instant = input.toInstant();\nDate output = Date.from(instant);\n</code></pre>\n\n<p>A <code>java.util.Date</code> instance has no concept of time-zone. This might seem strange if you call <code>toString()</code> on a <code>java.util.Date</code>, because the <code>toString</code> is relative to a time-zone. However that method actually uses Java's default time-zone on the fly to provide the string. The time-zone is not part of the actual state of <code>java.util.Date</code>.</p>\n\n<p>An <code>Instant</code> also does not contain any information about the time-zone. Thus, to convert from an <code>Instant</code> to a local date-time it is necessary to specify a time-zone. This might be the default zone - <code>ZoneId.systemDefault()</code> - or it might be a time-zone that your application controls, such as a time-zone from user preferences. <code>LocalDateTime</code> has a convenient factory method that takes both the instant and time-zone:</p>\n\n<pre><code>Date in = new Date();\nLocalDateTime ldt = LocalDateTime.ofInstant(in.toInstant(), ZoneId.systemDefault());\n</code></pre>\n\n<p>In reverse, the <code>LocalDateTime</code> the time-zone is specified by calling the <code>atZone(ZoneId)</code> method. The <code>ZonedDateTime</code> can then be converted directly to an <code>Instant</code>:</p>\n\n<pre><code>LocalDateTime ldt = ...\nZonedDateTime zdt = ldt.atZone(ZoneId.systemDefault());\nDate output = Date.from(zdt.toInstant());\n</code></pre>\n\n<p>Note that the conversion from <code>LocalDateTime</code> to <code>ZonedDateTime</code> has the potential to introduce unexpected behaviour. This is because not every local date-time exists due to Daylight Saving Time. In autumn/fall, there is an overlap in the local time-line where the same local date-time occurs twice. In spring, there is a gap, where an hour disappears. See the Javadoc of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html#atZone-java.time.ZoneId-\"><code>atZone(ZoneId)</code></a> for more the definition of what the conversion will do.</p>\n\n<p>Summary, if you round-trip a <code>java.util.Date</code> to a <code>LocalDateTime</code> and back to a <code>java.util.Date</code> you may end up with a different instant due to Daylight Saving Time.</p>\n    "},{"t":"Convert Iterable to Stream using Java 8 JDK","l":"http://stackoverflow.com/questions/23932061/convert-iterable-to-stream-using-java-8-jdk","q":"\n\n<p>I have an interface which returns <code>java.lang.Iterable&lt;T&gt;</code>.</p>\n\n<p>I would like to manipulate that result using the Java 8 Stream API.</p>\n\n<p>However Iterable can't \"Stream\". </p>\n\n<p>Any better idea how to use streams (without converting Iterable to List)?</p>\n    ","a":"\n<p>There's a much better answer than using <code>spliteratorUnknownSize</code> directly, which is both easier and gets a better result.  <code>Iterable</code> has a <code>spliterator()</code> method, so you should just use that to get your spliterator.  In the worst case, its the same code (the default implementation uses <code>spliteratorUnknownSize</code>), but in the more common case, where your <code>Iterable</code> is already a collection, you'll get a better spliterator, and therefore better stream performance (maybe even good parallelism.)  Its also less code: </p>\n\n<pre><code>StreamSupport.stream(iterable.spliterator(), false)\n             .filter(...)\n             .moreStreamOps(...);\n</code></pre>\n\n<p>As you can see, getting a stream from an Iterable (see <a href=\"http://stackoverflow.com/questions/23114015/why-does-iterablet-not-provide-stream-and-parallelstream-methods?rq=1\">Why does Iterable&lt;T&gt; not provide stream() and parallelStream() methods?</a>) is not very painful.  </p>\n    "},{"t":"Do Java 8 default methods break source compatibility?","l":"http://stackoverflow.com/questions/31188231/do-java-8-default-methods-break-source-compatibility","q":"\n\n<p>It has generally been the case the Java source code has been forward compatible.  Until Java 8, as far as I know, both compiled classes <em>and</em> source have been forward compatible with later JDK/JVM releases.  [Update: this is not correct, see comments re 'enum', etc, below.]  However, with the addition of default methods in Java 8 this appears to no longer be the case.</p>\n\n<p>For example, a library I have been using has an implementation of <code>java.util.List</code> which includes a <code>List&lt;V&gt; sort()</code>.  This method returns a copy of the contents of the list sorted. This library, deployed as a jar file dependency, worked fine in a project being built using JDK 1.8.</p>\n\n<p>However, later I had occasion to recompile the library itself using JDK 1.8 and\nI found the library no longer compiles: the <code>List</code>-implementing class with its own <code>sort()</code> method now conflicts with the Java 8 <code>java.util.List.sort()</code> default method.  The Java 8 <code>sort()</code> default method sorts the list in place (returns <code>void</code>); my library's <code>sort()</code> method - since it returns a new sorted list - has an incompatible signature.</p>\n\n<p>So my basic question is:</p>\n\n<ul>\n<li>Doesn't JDK 1.8 introduce a forward incompatibility for Java source code due to default methods?</li>\n</ul>\n\n<p>Also:</p>\n\n<ul>\n<li>Is this the first such forward incompatible change?</li>\n<li>Was this considered or discussed when default methods where designed and implemented?  Is it documented anywhere?</li>\n<li>Was the (admittedly small) inconvenience discounted versus the benefits?</li>\n</ul>\n\n<p>The following is an example of some code that compiles and runs under 1.7 and\nruns under 1.8 - but does not compile under 1.8:</p>\n\n<pre><code>import java.util.*;\n\npublic final class Sort8 {\n\n    public static void main(String[] args) {\n        SortableList&lt;String&gt; l = new SortableList&lt;String&gt;(Arrays.asList(args));\n        System.out.println(\"unsorted: \"+l);\n        SortableList&lt;String&gt; s = l.sort(Collections.reverseOrder());\n        System.out.println(\"sorted  : \"+s);\n    }\n\n    public static class SortableList&lt;V&gt; extends ArrayList&lt;V&gt; {\n\n        public SortableList() { super(); }\n        public SortableList(Collection&lt;? extends V&gt; col) { super(col); }\n\n        public SortableList&lt;V&gt; sort(Comparator&lt;? super V&gt; cmp) {\n            SortableList&lt;V&gt; l = new SortableList&lt;V&gt;();\n            l.addAll(this);\n            Collections.sort(l, cmp);\n            return l;\n        }\n\n    }\n\n}\n</code></pre>\n\n<p>The following shows this code being compiled (or failing to) and being run.</p>\n\n<pre><code>&gt; c:\\tools\\jdk1.7.0_10\\bin\\javac Sort8.java\n\n&gt; c:\\tools\\jdk1.7.0_10\\bin\\java Sort8 this is a test\nunsorted: [this, is, a, test]\nsorted  : [this, test, is, a]\n\n&gt; c:\\tools\\jdk1.8.0_05\\bin\\java Sort8 this is a test\nunsorted: [this, is, a, test]\nsorted  : [this, test, is, a]\n\n&gt; del Sort8*.class\n\n&gt; c:\\tools\\jdk1.8.0_05\\bin\\javac Sort8.java\nSort8.java:46: error: sort(Comparator&lt;? super V&gt;) in SortableList cannot implement sort(Comparator&lt;? super E&gt;) in List\n                public SortableList&lt;V&gt; sort(Comparator&lt;? super V&gt; cmp) {\n                                       ^\n  return type SortableList&lt;V&gt; is not compatible with void\n  where V,E are type-variables:\n    V extends Object declared in class SortableList\n    E extends Object declared in interface List\n1 error\n</code></pre>\n    ","a":"\n<p><strong><em>Doesn't JDK 1.8 introduce a forward incompatibility for Java source code due to default methods?</em></strong></p>\n\n<p>Any new method in a superclass or interface can break compatibility. Default methods make it <em>less likely</em> that a change in an interface will break compatibility. In the sense that default methods open the door to adding methods to interfaces, you could say that default methods may contribute to some broken compatibility.</p>\n\n<p><strong><em>Is this the first such forward incompatible change?</em></strong></p>\n\n<p>Almost certainly not, since we've been subclassing classes from the standard library since Java 1.0. </p>\n\n<p><strong><em>Was this considered or discussed when default methods were designed and implemented? Is it documented anywhere?</em></strong></p>\n\n<p>Yes, it was considered. See Brian Goetz's August 2010 paper <a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/Defender%20Methods%20v3.pdf\">\"Interface evolution via “public defender” methods\"</a>:</p>\n\n<blockquote>\n  <ol start=\"10\">\n  <li>Source compatibility</li>\n  </ol>\n  \n  <p>It is possible that this scheme could introduce source incompatibilities to the extent that library interfaces are modified to insert new methods that are incompatible with methods in existing classes. (For example, if a class has a float-valued xyz() method and implements Collection, and we add an int-valued xyz() method to Collection, the existing class will no longer compile.) </p>\n</blockquote>\n\n<p><strong><em>Was the (admittedly small) inconvenience discounted versus the benefits?</em></strong></p>\n\n<p>Before, changing an interface would <em>definitely</em> break compatibility. Now, it <em>might</em>. Going from 'definitely' to 'might' can be seen either positively or negatively. On the one hand, it makes it feasible to add methods to interfaces. On the other hand, it opens the door to the kind of incompatibility you saw, not just with classes, but with interfaces too.</p>\n\n<p>The benefits are larger than the inconveniences, though, as cited at the top of Goetz's paper:</p>\n\n<blockquote>\n  <ol>\n  <li>Problem statement</li>\n  </ol>\n  \n  <p>Once published, it is impossible to add methods to an interface without breaking existing implementations. The longer the time since a library has been published, the more likely it is that this restriction will cause grief for its maintainers.</p>\n  \n  <p>The addition of closures to the Java language in JDK 7 place additional stress on the aging Collection interfaces; one of the most significant benefits of closures is that it enables the development of more powerful libraries. It would be disappointing to add a language feature that enables better libraries while at the same time not extending the core libraries to take advantage of that feature. </p>\n</blockquote>\n    "},{"t":"A peculiar feature of exception type inference in Java 8","l":"http://stackoverflow.com/questions/31316581/a-peculiar-feature-of-exception-type-inference-in-java-8","q":"\n\n<p>While writing code for another answer on this site I came across this peculiarity:</p>\n\n<pre><code>static void testSneaky() {\n  final Exception e = new Exception();\n  sneakyThrow(e);    //no problems here\n  nonSneakyThrow(e); //ERRROR: Unhandled exception: java.lang.Exception\n}\n\n@SuppressWarnings(\"unchecked\")\nstatic &lt;T extends Throwable&gt; void sneakyThrow(Throwable t) throws T {\n  throw (T) t;\n}\n\nstatic &lt;T extends Throwable&gt; void nonSneakyThrow(T t) throws T {\n  throw t;\n}\n</code></pre>\n\n<p>First, I am quite confused why the <code>sneakyThrow</code> call is OK to the compiler. What possible type did it infer for <code>T</code> when there is no mention anywhere of an unchecked exception type?</p>\n\n<p>Second, accepting that this works, why then does the compiler complain on the <code>nonSneakyThrow</code> call? They seem very much alike.</p>\n    ","a":"\n<p>The T of <code>sneakyThrow</code> is inferred to be <code>RuntimeException</code>. This can be followed from the langauge spec on type inference (<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html\">http://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html</a>)</p>\n\n<p>Firstly, there's a note in section 18.1.3:</p>\n\n<blockquote>\n  <p>A bound of the form <code>throws α</code> is purely informational: it directs resolution to optimize the instantiation of α so that, if possible, it is not a checked exception type.</p>\n</blockquote>\n\n<p>This doesn't affect anything, but it points us to the Resolution section (18.4), which has got more information on inferred exception types with a special case:</p>\n\n<blockquote>\n  <p>... Otherwise, if the bound set contains <code>throws αi</code>, and the proper upper bounds of αi are, at most, <code>Exception</code>, <code>Throwable</code>, and <code>Object</code>, then Ti = <code>RuntimeException</code>. </p>\n</blockquote>\n\n<p>This case applies to <code>sneakyThrow</code> - the only upper bound is <code>Throwable</code>, so <code>T</code> is inferred to be <code>RuntimeException</code> as per the spec, so it compiles. The body of the method is immaterial - the unchecked cast succeeds at runtime because it doesn't actually happen, leaving a method that can defeat the compile-time checked exception system.</p>\n\n<p><code>nonSneakyThrow</code> does not compile as that method's <code>T</code> has got a lower bound of <code>Exception</code> (ie <code>T</code> must be a supertype of <code>Exception</code>, or <code>Exception</code> itself), which is a checked exception, due to the type it's being called with, so that <code>T</code> gets inferred as <code>Exception</code>.</p>\n    "},{"t":"How to convert a stream to an array in Java 8?","l":"http://stackoverflow.com/questions/23079003/how-to-convert-a-stream-to-an-array-in-java-8","q":"\n\n<p>What is the easiest/shortest way to convert a stream into an array?</p>\n    ","a":"\n<p>You can use the overloaded version of <code>toArray</code>, as the following:</p>\n\n<pre><code>Stream&lt;String&gt; stream = ...;\nString[] stringArray = stream.toArray(size -&gt; new String[size]);\n</code></pre>\n\n<p>The purpose of the <code>IntFunction&lt;A[]&gt; generator</code> is to convert an integer, the size of the array, to a new array.</p>\n\n<p>Example code:</p>\n\n<pre><code>Stream&lt;String&gt; streamString = Stream.of(\"a\", \"b\", \"c\");\nString[] stringArray = streamString.toArray(size -&gt; new String[size]);\nArrays.stream(stringArray).forEach(System.out::println);\n</code></pre>\n\n<p>Prints:</p>\n\n<pre><code>a\nb\nc\n</code></pre>\n\n<p>Another option is to use a method reference to the string array constructor, this one is a bit more tricky. Usage is easy:</p>\n\n<pre><code>String[] stringArray = streamString.toArray(String[]::new);\n</code></pre>\n\n<p>What it does, is find a method that takes in an integer (the size) as argument, and returns a <code>String[]</code>, which is exactly what (one of the overloads of) <code>new String[]</code> does.</p>\n    "},{"t":"Is there a concise way to iterate over a stream with indices in Java 8?","l":"http://stackoverflow.com/questions/18552005/is-there-a-concise-way-to-iterate-over-a-stream-with-indices-in-java-8","q":"\n\n<p>Is there a concise way to iterate over a stream whilst having access to the index in the stream?</p>\n\n<p>The best I've come across so far (<a href=\"http://blog.lahteenmaki.net/2013/04/java-streams-vs-c-linq-vs-java6.html\">challenge 2 here</a>) is</p>\n\n<pre><code>String[] names = {\"Sam\",\"Pamela\", \"Dave\", \"Pascal\", \"Erik\"};\n\nList&lt;String&gt; nameList;\nStream&lt;Integer&gt; indices = intRange(1, names.length).boxed();\nnameList = zip(indices, stream(names), SimpleEntry::new)\n        .filter(e -&gt; e.getValue().length() &lt;= e.getKey())\n        .map(Entry::getValue)\n        .collect(toList());\n</code></pre>\n\n<p>which seems rather disappointing compared to the LINQ example given there</p>\n\n<pre><code>string[] names = { \"Sam\", \"Pamela\", \"Dave\", \"Pascal\", \"Erik\" };\nvar nameList = names.Where((c, index) =&gt; c.Length &lt;= index + 1).ToList();\n</code></pre>\n\n<p>Is there a more concise way?</p>\n\n<p>Further it seems the zip has either moved or been removed...</p>\n    ","a":"\n<p>The cleanest way is to start from a stream of indices:</p>\n\n<pre><code>String[] names = {\"Sam\", \"Pamela\", \"Dave\", \"Pascal\", \"Erik\"};\nIntStream.range(0, names.length)\n         .filter(i -&gt; names[i].length() &lt;= i)\n         .mapToObj(i -&gt; names[i])\n         .collect(Collectors.toList());\n</code></pre>\n\n<p>The resulting list contains \"Erik\" only.</p>\n\n<hr>\n\n<p>One alternative which looks more familiar when you are used to for loops would be to maintain an ad hoc counter using a mutable object, for example an <code>AtomicInteger</code>:</p>\n\n<pre><code>String[] names = {\"Sam\", \"Pamela\", \"Dave\", \"Pascal\", \"Erik\"};\nAtomicInteger index = new AtomicInteger();\nList&lt;String&gt; list = Arrays.stream(names)\n                          .filter(n -&gt; n.length() &lt;= index.incrementAndGet())\n                          .collect(Collectors.toList());\n</code></pre>\n\n<p>Note that <strong><em>using the latter method on a parallel stream could break as the items would not necesarily be processed \"in order\"</em></strong>.</p>\n    "},{"t":"Recursive ConcurrentHashMap.computeIfAbsent() call never terminates. Bug or “feature”?","l":"http://stackoverflow.com/questions/28840047/recursive-concurrenthashmap-computeifabsent-call-never-terminates-bug-or-fea","q":"\n\n<p>Some time ago, <a href=\"http://blog.jooq.org/2014/02/28/java-8-friday-goodies-easy-as-pie-local-caching\">I've blogged about a Java 8 functional way of calculating fibonacci numbers recursively</a>, with a <code>ConcurrentHashMap</code> cache and the new, useful <code>computeIfAbsent()</code> method:</p>\n\n<pre><code>import java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class Test {\n    static Map&lt;Integer, Integer&gt; cache = new ConcurrentHashMap&lt;&gt;();\n\n    public static void main(String[] args) {\n        System.out.println(\n            \"f(\" + 8 + \") = \" + fibonacci(8));\n    }\n\n    static int fibonacci(int i) {\n        if (i == 0)\n            return i;\n\n        if (i == 1)\n            return 1;\n\n        return cache.computeIfAbsent(i, (key) -&gt; {\n            System.out.println(\n                \"Slow calculation of \" + key);\n\n            return fibonacci(i - 2) + fibonacci(i - 1);\n        });\n    }\n}\n</code></pre>\n\n<p>I chose <code>ConcurrentHashMap</code> because I was thinking of making this example even more sophisticated by introducing parallelism (which I didn't in the end).</p>\n\n<p>Now, let's increase the number from <code>8</code> to <code>25</code> and observe what happens:</p>\n\n<pre><code>        System.out.println(\n            \"f(\" + 25 + \") = \" + fibonacci(25));\n</code></pre>\n\n<p>The program never halts. Inside the method, there's a loop that just runs forever:</p>\n\n<pre><code>for (Node&lt;K,V&gt;[] tab = table;;) {\n    // ...\n}\n</code></pre>\n\n<p>I'm using:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>C:\\Users\\Lukas&gt;java -version\njava version \"1.8.0_40-ea\"\nJava(TM) SE Runtime Environment (build 1.8.0_40-ea-b23)\nJava HotSpot(TM) 64-Bit Server VM (build 25.40-b25, mixed mode)\n</code></pre>\n\n<p><a href=\"http://blog.jooq.org/2014/02/28/java-8-friday-goodies-easy-as-pie-local-caching/#comment-121821\">Matthias, a reader of that blog post also confirmed the issue (he actually found it)</a>.</p>\n\n<p>This is weird. I would have expected any of the following two:</p>\n\n<ul>\n<li>It works</li>\n<li>It throws a <code>ConcurrentModificationException</code></li>\n</ul>\n\n<p>But just never halting? That seems dangerous. Is it a bug? Or did I misunderstand some contract?</p>\n    ","a":"\n<p>This is fixed in <a href=\"https://bugs.openjdk.java.net/browse/JDK-8062841\">JDK-8062841</a>.</p>\n\n<p>In the <a href=\"http://jsr166-concurrency.10961.n7.nabble.com/ConcurrentHashMapV8-td7312.html\">2011 proposal</a>, I identified this issue during the code review. The JavaDoc was updated and a temporary fix was added. It was removed in a further rewrite due to performance issues.</p>\n\n<p>In the <a href=\"http://jsr166-concurrency.10961.n7.nabble.com/Re-ConcurrentHashMap-computeIfAbsent-td11687.html\">2014 discussion</a>, we explored ways to better detect and fail. Note that some of the discussion was taken offline to private email for considering the low-level changes. While not every case can be covered, the common cases will not livelock. These <a href=\"http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ConcurrentHashMap.java?r1=1.258&amp;r2=1.259\">fixes</a> are in Doug's repository but have not made it into a JDK release.</p>\n    "},{"t":"How do I define a method which takes a lambda as a parameter in Java 8?","l":"http://stackoverflow.com/questions/13604703/how-do-i-define-a-method-which-takes-a-lambda-as-a-parameter-in-java-8","q":"\n\n<p>In Java 8 methods can be created as Lambda expressions and can be passed by reference (with a little work under the hood). There are plenty of examples online with lambdas being created and used with methods, but no examples of how to make a method taking a lambda as a parameter. What is the syntax for that?</p>\n\n<pre><code>MyClass.method((a, b) -&gt; a+b);\n\n\nclass MyClass{\n  //How do I define this method?\n  static int method(Lambda l){\n    return l(5, 10);\n  }\n}\n</code></pre>\n    ","a":"\n<p>Lambdas are purely a call-site construct: the recipient of the lambda does not need to know that a Lambda is involved, instead it accepts an Interface with the appropriate method.</p>\n\n<p>In other words, you define or use a functional interface (i.e. an interface with a single method) that accepts and returns exactly what you want.</p>\n\n<p>For this Java 8 comes with a set of commonly-used interface types in <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html\"><code>java.util.function</code></a> (thanks to <a href=\"http://stackoverflow.com/users/1859863/maurice-naftalin\">Maurice Naftalin</a> for the hint about the JavaDoc).</p>\n\n<p>For this specific use case there's <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/function/IntBinaryOperator.html\"><code>java.util.function.IntBinaryOperator</code></a> with <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/function/IntBinaryOperator.html#applyAsInt-int-int-\">a single <code>int applyAsInt(int left, int right)</code> method</a>, so you could write your <code>method</code> like this:</p>\n\n<pre><code>static int method(IntBinaryOperator op){\n    return op.applyAsInt(5, 10);\n}\n</code></pre>\n\n<p>But you can just as well define your own interface and use it like this:</p>\n\n<pre><code>public interface TwoArgIntOperator {\n    public int op(int a, int b);\n}\n\n//elsewhere:\nstatic int method(TwoArgIntOperator operator) {\n    return operator.op(5, 10);\n}\n</code></pre>\n\n<p>Using your own interface has the advantage that you can have names that more clearly indicate the intent.</p>\n    "},{"t":"Should java 8 getters return optional type?","l":"http://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type","q":"\n\n<p>Optional type introduced in Java 8 is a new thing for many developers.</p>\n\n<p>Is a getter method returning <code>Optional&lt;Foo&gt;</code> type in place of the classic <code>Foo</code> a good practice? Assume that the value can be <code>null</code>.</p>\n    ","a":"\n<p>Of course, people will do what they want.  But we did have a clear intention when adding this feature, and it was <em>not</em> to be a general purpose Maybe or Some type, as much as many people would have liked us to do so.  Our intention was to provide a limited mechanism for library method return types where there needed to be a clear way to represent \"no result\", and using <code>null</code> for such was overwhelmingly likely to cause errors.  </p>\n\n<p>For example, you probably should never use it for something that returns an array of results, or a list of results; instead return an empty array or list.  You should almost never use it as a field of something or a method parameter.</p>\n\n<p>I think routinely using it as a return value for getters would definitely be over-use.  </p>\n\n<p>There's nothing <em>wrong</em> with Optional that it should be avoided, it's just not what many people wish it were, and accordingly we were fairly concerned about the risk of zealous over-use.</p>\n\n<p>(Public service announcement: <em>NEVER</em> call <code>Optional.get</code> unless you can prove it will never be null; instead use one of the safe methods like <code>orElse</code> or <code>ifPresent</code>.  In retrospect, we should have called <code>get</code> something like <code>getOrElseThrowNoSuchElementException</code> or something that made it far clearer that this was a highly dangerous method that undermined the whole purpose of <code>Optional</code> in the first place.  Lesson learned.)</p>\n    "},{"t":"How to serialize a lambda?","l":"http://stackoverflow.com/questions/22807912/how-to-serialize-a-lambda","q":"\n\n<p>How can I elegantly serialize a lambda?</p>\n\n<p>For example, the code below throws a <code>NotSerializableException</code>. How can I fix it without creating a <code>SerializableRunnable</code> \"dummy\" interface?</p>\n\n<pre><code>public static void main(String[] args) throws Exception {\n    File file = Files.createTempFile(\"lambda\", \"ser\").toFile();\n    try (ObjectOutput oo = new ObjectOutputStream(new FileOutputStream(file))) {\n        Runnable r = () -&gt; System.out.println(\"Can I be serialized?\");\n        oo.writeObject(r);\n    }\n\n    try (ObjectInput oi = new ObjectInputStream(new FileInputStream(file))) {\n        Runnable  r = (Runnable) oi.readObject();\n        r.run();\n    }\n}\n</code></pre>\n    ","a":"\n<p>Java 8 introduces the possibility to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.16\">cast an object to an intersection of types by adding multiple bounds</a>. In the case of serialization, it is therefore possible to write:</p>\n\n<pre><code>Runnable r = (Runnable &amp; Serializable)() -&gt; System.out.println(\"Serializable!\");\n</code></pre>\n\n<p>And the lambda automagically becomes serializable.</p>\n    "},{"t":"Java8 Iterator to Stream","l":"http://stackoverflow.com/questions/24511052/java8-iterator-to-stream","q":"\n\n<p>I am looking for a concise way to convert an <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\"><code>Iterator</code></a> to a <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\"><code>Stream</code></a> or more specifically to \"view\" the <code>iterator</code> as a <code>stream</code>.</p>\n\n<p>For performance reason, i would like to avoid a copy of the iterator in a new list:</p>\n\n<pre><code>Iterator&lt;String&gt; sourceIterator = Arrays.asList(\"A\", \"B\", \"C\").iterator();\nCollection&lt;String&gt; copyList = new ArrayList&lt;String&gt;();\nsourceIterator.forEachRemaining(copyList::add);\nStream&lt;String&gt; targetStream = copyList.stream();\n</code></pre>\n\n<hr>\n\n<p>Based on the some suggestions in the comments, i have also tried to use <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#generate-java.util.function.Supplier-\"><code>Stream.generate</code></a>:</p>\n\n<pre><code>public static void main(String[] args) throws Exception {\n    Iterator&lt;String&gt; sourceIterator = Arrays.asList(\"A\", \"B\", \"C\").iterator();\n    Stream&lt;String&gt; targetStream = Stream.generate(sourceIterator::next);\n    targetStream.forEach(System.out::println);\n}\n</code></pre>\n\n<p>but i get a <code>NoSuchElementException</code> (since there is no invocation of <code>hasNext</code>)</p>\n\n<pre><code>Exception in thread \"main\" java.util.NoSuchElementException\n    at java.util.AbstractList$Itr.next(AbstractList.java:364)\n    at Main$$Lambda$1/1175962212.get(Unknown Source)\n    at java.util.stream.StreamSpliterators$InfiniteSupplyingSpliterator$OfRef.tryAdvance(StreamSpliterators.java:1351)\n    at java.util.Spliterator.forEachRemaining(Spliterator.java:326)\n    at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)\n    at Main.main(Main.java:20)\n</code></pre>\n\n<p>I have looked at <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/StreamSupport.html\"><code>StreamSupport</code></a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html\"><code>Collections</code></a> but i didn't find anything.</p>\n    ","a":"\n<p>One way is to create a Spliterator from the Iterator and use that as a basis for your stream:</p>\n\n<pre><code>Iterator&lt;String&gt; sourceIterator = Arrays.asList(\"A\", \"B\", \"C\").iterator();\nStream&lt;String&gt; targetStream = StreamSupport.stream(\n          Spliterators.spliteratorUnknownSize(sourceIterator, Spliterator.ORDERED),\n          false);\n</code></pre>\n\n<p>An alternative which is maybe more readable is to use an Iterable - and creating an Iterable from an Iterator is very easy with lambdas because Iterable is a functional interface:</p>\n\n<pre><code>Iterator&lt;String&gt; sourceIterator = Arrays.asList(\"A\", \"B\", \"C\").iterator();\n\nIterable&lt;String&gt; iterable = () -&gt; sourceIterator;\nStream&lt;String&gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);\n</code></pre>\n    "},{"t":"Java8 streams sequential and parallel execution produce different results?","l":"http://stackoverflow.com/questions/28724850/java8-streams-sequential-and-parallel-execution-produce-different-results","q":"\n\n<p>Running the following stream example in Java8:</p>\n\n<pre><code>    System.out.println(Stream\n        .of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\n        .reduce(\"\", (s1, s2) -&gt; s1 + \"/\" + s2)\n    );\n</code></pre>\n\n<p>yields:</p>\n\n<pre><code>/a/b/c/d/e/f\n</code></pre>\n\n<p>Which is - of course - no surprise.\nDue to <a href=\"http://docs.oracle.com/javase/8/docs/api/index.html?overview-summary.html\">http://docs.oracle.com/javase/8/docs/api/index.html?overview-summary.html</a> it shouldn't matter whether the stream is executed sequentially or parallel: </p>\n\n<blockquote>\n  <p>Except for operations identified as explicitly nondeterministic, such as findAny(), whether a stream executes sequentially or in parallel should not change the result of the computation. </p>\n</blockquote>\n\n<p>AFAIK <code>reduce()</code> is deterministic and <code>(s1, s2) -&gt; s1 + \"/\" + s2</code> is associative, so that adding <code>parallel()</code> should yield the same result:</p>\n\n<pre><code>    System.out.println(Stream\n            .of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\n            .parallel()\n            .reduce(\"\", (s1, s2) -&gt; s1 + \"/\" + s2)\n    );\n</code></pre>\n\n<p>However the result on my machine is:</p>\n\n<pre><code>/a//b//c//d//e//f\n</code></pre>\n\n<p>What's wrong here?</p>\n\n<p>BTW: using (the preferred) <code>.collect(Collectors.joining(\"/\"))</code> instead of <code>reduce(...)</code> yields the same result <code>a/b/c/d/e/f</code> for sequential and parallel execution.</p>\n\n<p>JVM details:</p>\n\n<pre><code>java.specification.version: 1.8\njava.version: 1.8.0_31\njava.vm.version: 25.31-b07\njava.runtime.version: 1.8.0_31-b13\n</code></pre>\n    ","a":"\n<p>From reduce's documentation:</p>\n\n<blockquote>\n  <p>The identity value must be an identity for the accumulator function. This means that for all t, accumulator.apply(identity, t) is equal to t. </p>\n</blockquote>\n\n<p>Which is not true in your case - \"\" and \"a\" creates \"/a\".</p>\n\n<p>I have extracted the accumulator function and added a printout to show what happens:</p>\n\n<pre><code>BinaryOperator&lt;String&gt; accumulator = (s1, s2) -&gt; {\n    System.out.println(\"joining \\\"\" + s1 + \"\\\" and \\\"\" + s2 + \"\\\"\");\n    return s1 + \"/\" + s2;\n};\nSystem.out.println(Stream\n                .of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\n                .parallel()\n                .reduce(\"\", accumulator)\n);\n</code></pre>\n\n<p>This is example output (it differs between runs):</p>\n\n<pre><code>joining \"\" and \"d\"\njoining \"\" and \"f\"\njoining \"\" and \"b\"\njoining \"\" and \"a\"\njoining \"\" and \"c\"\njoining \"\" and \"e\"\njoining \"/b\" and \"/c\"\njoining \"/e\" and \"/f\"\njoining \"/a\" and \"/b//c\"\njoining \"/d\" and \"/e//f\"\njoining \"/a//b//c\" and \"/d//e//f\"\n/a//b//c//d//e//f\n</code></pre>\n\n<p>You can add an if statement to your function to handle empty string separately:</p>\n\n<pre><code>System.out.println(Stream\n        .of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\n        .parallel()\n        .reduce((s1, s2) -&gt; s1.isEmpty()? s2 : s1 + \"/\" + s2)\n);\n</code></pre>\n\n<p>As Marko Topolnik noticed, checking <code>s2</code> is not required as accumulator doesn't have to be commutative function.</p>\n    "},{"t":"Why does split in Java 8 sometimes remove empty strings at start of result array?","l":"http://stackoverflow.com/questions/22718744/why-does-split-in-java-8-sometimes-remove-empty-strings-at-start-of-result-array","q":"\n\n<p>In Java 7 (and earlier) when we split on empty string like </p>\n\n<pre><code>String[] tokens = \"abc\".split(\"\");\n</code></pre>\n\n<p>split mechanism would split in places marked with <code>|</code></p>\n\n<pre><code>|a|b|c|\n</code></pre>\n\n<p>because empty space <code>\"\"</code> exists before and after each character. So as result it would generate at first this array</p>\n\n<pre><code>[\"\", \"a\", \"b\", \"c\", \"\"]\n</code></pre>\n\n<p>and later will remove trailing empty strings (because we didn't explicitly provide negative value to <code>limit</code> argument) so it will finally return </p>\n\n<pre><code>[\"\", \"a\", \"b\", \"c\"]\n</code></pre>\n\n<hr>\n\n<p>Now in JDK 8 split mechanism seems to have changed. Now when we use </p>\n\n<pre><code>\"abc\".split(\"\")\n</code></pre>\n\n<p>we will get <code>[\"a\", \"b\", \"c\"]</code> array instead of <code>[\"\", \"a\", \"b\", \"c\"]</code> so it looks like empty strings at start are also removed, but this theory fails because for instance</p>\n\n<pre><code>\"abc\".split(\"a\")\n</code></pre>\n\n<p>is returning array with empty string at start <code>[\"\", \"bc\"]</code>. </p>\n\n<p>Can someone explain what is going on here and how rules of split for this cases have changed in Java&nbsp;8?</p>\n    ","a":"\n<p>The behavior of <code>String.split</code> (which calls <code>Pattern.split</code>) changes between Java 7 and Java 8.</p>\n\n<h1>Documentation</h1>\n\n<p>Comparing between the documentation of <code>Pattern.split</code> in <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#split%28java.lang.CharSequence,%20int%29\">Java 7</a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-\">Java 8</a>, we observe the following clause being added:</p>\n\n<blockquote>\n  <p>When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.</p>\n</blockquote>\n\n<p>The same clause is also added to <code>String.split</code> in <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-int-\">Java 8</a>, compared to <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#split%28java.lang.CharSequence,%20int%29\">Java 7</a>.</p>\n\n<h1>Reference implementation</h1>\n\n<p>Let us compare the code of <code>Pattern.split</code> of the reference implemetation in Java 7 and Java 8. The code is retrieved from grepcode, for version 7u40-b43 and 8-b132.</p>\n\n<h2>Java 7</h2>\n\n<pre><code>public String[] split(CharSequence input, int limit) {\n    int index = 0;\n    boolean matchLimited = limit &gt; 0;\n    ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();\n    Matcher m = matcher(input);\n\n    // Add segments before each match found\n    while(m.find()) {\n        if (!matchLimited || matchList.size() &lt; limit - 1) {\n            String match = input.subSequence(index, m.start()).toString();\n            matchList.add(match);\n            index = m.end();\n        } else if (matchList.size() == limit - 1) { // last one\n            String match = input.subSequence(index,\n                                             input.length()).toString();\n            matchList.add(match);\n            index = m.end();\n        }\n    }\n\n    // If no match was found, return this\n    if (index == 0)\n        return new String[] {input.toString()};\n\n    // Add remaining segment\n    if (!matchLimited || matchList.size() &lt; limit)\n        matchList.add(input.subSequence(index, input.length()).toString());\n\n    // Construct result\n    int resultSize = matchList.size();\n    if (limit == 0)\n        while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(\"\"))\n            resultSize--;\n    String[] result = new String[resultSize];\n    return matchList.subList(0, resultSize).toArray(result);\n}\n</code></pre>\n\n<h2>Java 8</h2>\n\n<pre><code>public String[] split(CharSequence input, int limit) {\n    int index = 0;\n    boolean matchLimited = limit &gt; 0;\n    ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();\n    Matcher m = matcher(input);\n\n    // Add segments before each match found\n    while(m.find()) {\n        if (!matchLimited || matchList.size() &lt; limit - 1) {\n            if (index == 0 &amp;&amp; index == m.start() &amp;&amp; m.start() == m.end()) {\n                // no empty leading substring included for zero-width match\n                // at the beginning of the input char sequence.\n                continue;\n            }\n            String match = input.subSequence(index, m.start()).toString();\n            matchList.add(match);\n            index = m.end();\n        } else if (matchList.size() == limit - 1) { // last one\n            String match = input.subSequence(index,\n                                             input.length()).toString();\n            matchList.add(match);\n            index = m.end();\n        }\n    }\n\n    // If no match was found, return this\n    if (index == 0)\n        return new String[] {input.toString()};\n\n    // Add remaining segment\n    if (!matchLimited || matchList.size() &lt; limit)\n        matchList.add(input.subSequence(index, input.length()).toString());\n\n    // Construct result\n    int resultSize = matchList.size();\n    if (limit == 0)\n        while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(\"\"))\n            resultSize--;\n    String[] result = new String[resultSize];\n    return matchList.subList(0, resultSize).toArray(result);\n}\n</code></pre>\n\n<p>The addition of the following code in Java 8 excludes the zero-length match at the beginning of the input string, which explains the behavior above.</p>\n\n<pre><code>            if (index == 0 &amp;&amp; index == m.start() &amp;&amp; m.start() == m.end()) {\n                // no empty leading substring included for zero-width match\n                // at the beginning of the input char sequence.\n                continue;\n            }\n</code></pre>\n    "},{"t":"Java 8 way to work with an enum","l":"http://stackoverflow.com/questions/29922296/java-8-way-to-work-with-an-enum","q":"\n\n<p>I'm wondering what the best way is in Java 8 to work with all the values of an enum. Specifically when you need to get all the values and add it to somewhere, for example, supposing that we have the following enum:</p>\n\n<pre><code>public enum Letter {\n A, B, C, D;\n}\n</code></pre>\n\n<p>I could of course do the following:</p>\n\n<pre><code>for (Letter l : Letter.values()) {\n    foo(l);\n}\n</code></pre>\n\n<p>But, I could also add the following method to the enum definition:</p>\n\n<pre><code>public static Stream&lt;Letter&gt; stream() {\n    return Arrays.stream(Letter.values());\n}\n</code></pre>\n\n<p>And then replace the for from above with:</p>\n\n<pre><code>Letter.stream().forEach(l -&gt; foo(l));\n</code></pre>\n\n<p>Is this approach OK or does it have some fault in design or performance? Moreover, why don't enums have a stream() method?</p>\n    ","a":"\n<p>Three questions: three-part answer:</p>\n\n<h3>Is it okay from a design point of view?</h3>\n\n<p>Absolutely. Nothing wrong with it. If you need to do lots of iterating over your enum, the stream API is the clean way to go and hiding the boiler plate behind a little method is fine. Although I’d consider <a href=\"http://stackoverflow.com/users/823393/oldcurmudgeon\">OldCumudgeon</a>’s <a href=\"http://stackoverflow.com/a/29922602/66686\">version</a> even better.</p>\n\n<h3>Is it okay from a performance point of view?</h3>\n\n<p>It most likely doesn’t matter. Most of the time, enums are not that big. Therefore, whatever overhead there is for one method or the other probably doesn’t matter in 99.9% of the cases.</p>\n\n<p>Of course, there are the 0.1% where it does. In that case: measure properly, with your real-world data and consumers.</p>\n\n<p>If I had to bet, I’d expect the <code>for each</code> loop to be faster, since it maps more directly to the memory model, but don’t guess when talking performance, and don’t tune before there is actual need for tuning. Write your code in a way that is correct first, easy to read second and only then worry about performance of code style.</p>\n\n<h3>Why aren’t Enums properly integrated into the Stream API?</h3>\n\n<p>If you compare Java’s Stream API to the equivalent in many other languages, it appears seriously limited. There are various pieces that are missing (reusable Streams and Optionals as Streams, for example). On the other hand, implementing the Stream API was certainly a huge change for the API. It was postponed multiple times for a reason. So I guess Oracle wanted to limit the changes to the most important use cases. Enums aren’t used that much anyway. Sure, every project has a couple of them, but they’re nothing compared to the number of Lists and other Collections. Even when you have an Enum, in many cases you  won’t ever iterate over it. Lists and Sets, on the other hand, are probably iterated over almost every time. I assume that these were the reasons why the Enums didn’t get their own adapter to the Stream world. We’ll see whether more of this gets added in future versions. And until then you always can use <code>Arrays.stream</code>.</p>\n    "},{"t":"Does a lambda expression create an object on the heap every time it's executed?","l":"http://stackoverflow.com/questions/27524445/does-a-lambda-expression-create-an-object-on-the-heap-every-time-its-executed","q":"\n\n<p>When I iterate over a collection using the new syntactic sugar of Java8, such as</p>\n\n<pre><code>myStream.forEach(Item -&gt; {\n  // do something useful\n});\n</code></pre>\n\n<p>Isn't this equivalent to the 'old syntax' snippet below?</p>\n\n<pre><code>myStream.forEach(new Consumer&lt;Item&gt;() {\n  @Override\n  public void accept(Item item) {\n    // do something useful\n  }\n});\n</code></pre>\n\n<p>Does this mean a new anonymous <code>Consumer</code> object is created on the heap everytime I iterate over a collection? How much heap space does this take? What performance implications does it have? Does it mean I should rather use the old style for loops when iterating over large multi-level data structures?</p>\n    ","a":"\n<p>It is equivalent but not identical. Simply said, if a lambda expression does not captures values, it will be a singleton that is re-used on every invocation.</p>\n\n<p>The behavior is not exactly specified. The JVM is given a big freedom how to implement it. Currently, Oracle’s JVM creates (at least) one instance per lambda expression (i.e. doesn’t share instance between different identical expressions) but creates singleton for all expression which don’t capture values.</p>\n\n<p>You may read <a href=\"http://stackoverflow.com/a/23991339/2711488\">this answer</a> for more details. There, I not only gave a more detailed description but also testing code to observe the current behavior.</p>\n\n<hr>\n\n<p>This is covered by the The Java® Language Specification, chapter “<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.4\">15.27.4. Run-time Evaluation of Lambda Expressions</a>”</p>\n\n<p>Summarized:</p>\n\n<blockquote>\n  <p>These rules are meant to offer flexibility to implementations of the Java programming language, in that:</p>\n  \n  <ul>\n  <li><p>A new object need not be allocated on every evaluation.</p></li>\n  <li><p>Objects produced by different lambda expressions need not belong to different classes (if the bodies are identical, for example).</p></li>\n  <li><p>Every object produced by evaluation need not belong to the same class (captured local variables might be inlined, for example).</p></li>\n  <li><p>If an \"existing instance\" is available, it need not have been created at a previous lambda evaluation (it might have been allocated during the enclosing class's initialization, for example).</p></li>\n  </ul>\n</blockquote>\n    "},{"t":"WebService Client Generation Error with JDK8","l":"http://stackoverflow.com/questions/23011547/webservice-client-generation-error-with-jdk8","q":"\n\n<p>I need to consume a web service in my project. I use NetBeans so I right-clicked on my project and tried to add a new \"Web Service Client\". Last time I checked, this was the way to create a web service client. But it resulted in an AssertionError, saying:</p>\n\n<blockquote>\n  <p>java.lang.AssertionError: org.xml.sax.SAXParseException; systemId: jar:file:/path/to/glassfish/modules/jaxb-osgi.jar!/com/sun/tools/xjc/reader/xmlschema/bindinfo/binding.xsd; lineNumber: 52; columnNumber: 88; schema_reference: Failed to read schema document '<strong>xjc.xsd</strong>', because 'file' access is not allowed due to restriction set by the <strong>accessExternalSchema</strong> property.</p>\n</blockquote>\n\n<p>The default Java platform for NetBeans was JDK8 (Oracle's official version), so when I changed my netbeans.conf file and made JDK7 (from Oracle, as well) as my default, everything worked fine. So I think the problem is with JDK8. Here is my <code>java -version</code> output:</p>\n\n<blockquote>\n  <p>java version \"1.8.0\"<br>\n  Java(TM) SE Runtime Environment (build 1.8.0-b132)<br>\n  Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode)</p>\n</blockquote>\n\n<p>For now, I'm keeping JDK7 as my default Java platform. If there is a way to make JDK8 work please share. Thanks in advance.</p>\n    ","a":"\n<p>Well, I found the solution. (based on <a href=\"http://docs.oracle.com/javase/7/docs/api/javax/xml/XMLConstants.html#ACCESS_EXTERNAL_SCHEMA\">http://docs.oracle.com/javase/7/docs/api/javax/xml/XMLConstants.html#ACCESS_EXTERNAL_SCHEMA</a>)</p>\n\n<p>Create a file named <code>jaxp.properties</code> (if it doesn't exist) under <code>/path/to/jdk1.8.0/jre/lib</code> and then write this line in it:</p>\n\n<pre><code>javax.xml.accessExternalSchema = all\n</code></pre>\n\n<p>That's all. Enjoy JDK 8.</p>\n    "},{"t":"What is the “default” implementation of method defined in an Interface?","l":"http://stackoverflow.com/questions/18286235/what-is-the-default-implementation-of-method-defined-in-an-interface","q":"\n\n<p>In the Collection Interface I found a method named <code>removeIf()</code> that contains its implementation.    </p>\n\n<pre><code>default boolean removeIf(Predicate&lt;? super E&gt; filter) {\n    Objects.requireNonNull(filter);  \n    boolean removed = false;  \n    final Iterator&lt;E&gt; each = iterator();   \n    while (each.hasNext()) {  \n        if (filter.test(each.next())) {  \n            each.remove();  \n            removed = true;  \n        }  \n    }  \n    return removed;  \n}  \n</code></pre>\n\n<p>I want to know if there is any way to define method body in an interface?<br>\nWhat is the <code>default</code> keyword and how does it work?   </p>\n    ","a":"\n<p>Java 8 introduces “Default Method” or (Defender methods) new feature, which allows developer to add new methods to the interfaces without breaking the existing implementation of these interface. It provides flexibility to allow interface define implementation which will use as default in the situation where a concrete class fails to provide an implementation for that method.  </p>\n\n<pre><code>public interface A {\n    default void foo(){\n       System.out.println(\"Calling A.foo()\");\n    }\n}\n\npublic class ClassAB implements A {\n}\n</code></pre>\n\n<p>There is one common question that people ask about default methods when they hear about the new feature for the first time: </p>\n\n<blockquote>\n  <p>What if the class implements two interfaces and both those interfaces define a default method with the same signature?</p>\n</blockquote>\n\n<p>Example to illustrate this situation:</p>\n\n<pre><code>public interface A {  \n    default void foo(){  \n        System.out.println(\"Calling A.foo()\");  \n    }  \n}\n\npublic interface B {\n    default void foo(){\n        System.out.println(\"Calling B.foo()\");\n    }\n}\n\n\npublic class ClassAB implements A, B {\n\n}  \n</code></pre>\n\n<p>This code fails to compile with the following result:</p>\n\n<pre><code>java: class Clazz inherits unrelated defaults for foo() from types A and B\n</code></pre>\n\n<p>To fix that, in Clazz, we have to resolve it manually by overriding the conflicting method:</p>\n\n<pre><code>public class Clazz implements A, B {\n    public void foo(){}\n}\n</code></pre>\n\n<p>But what if we would like to call the default implementation of method foo() from interface A instead of implementing our own. </p>\n\n<p>It is possible to refer to A#foo() as follows:</p>\n\n<pre><code>public class Clazz implements A, B {\n    public void foo(){\n       A.super.foo();\n    }\n}\n</code></pre>\n    "},{"t":"A better approach to handling exceptions in a functional way","l":"http://stackoverflow.com/questions/31270759/a-better-approach-to-handling-exceptions-in-a-functional-way","q":"\n\n<p>Exceptions, especially checked ones, can severely interrupt the flow of program logic when the FP idiom is used in Java 8. Here is an arbitrary example:</p>\n\n<pre><code>String s1 = \"oeu\", s2 = \"2\";\nStream.of(s1, s2).forEach(s -&gt; \n    System.out.println(Optional.of(s).map(Integer::parseInt).get()));\n</code></pre>\n\n<p>The above code breaks when there's an exception for an unparseable string. But say I just want to replace that with a default value, much like I can with <code>Optional</code>:</p>\n\n<pre><code>Stream.of(s1, s2).forEach(s -&gt; \n   System.out.println(Optional.of(s)\n                              .map(Integer::parseInt)\n                              .orElse(-1)));\n</code></pre>\n\n<p>Of course, this still fails because <code>Optional</code> only handles <code>null</code>s. I would like something as follows:</p>\n\n<pre><code>Stream.of(s1, s2).forEach(s -&gt;\n    System.out.println(\n        Exceptional.of(s)\n                   .map(Integer::parseInt)\n                   .handle(NumberFormatException.class, swallow())\n                   .orElse(-1)));\n</code></pre>\n\n<hr>\n\n<p><strong>Note:</strong> this is a self-answered question.</p>\n    ","a":"\n<p>Presented below is the full code of the <code>Exceptional</code> class. It has a quite large API which is a pure extension of the <code>Optional</code> API so it can be a drop-in replacement for it in any existing code—except that it isn't a subtype of the final <code>Optional</code> class. The class can be seen as being in the same relationship with the <a href=\"http://mauricio.github.io/2014/02/17/scala-either-try-and-the-m-word.html\" rel=\"nofollow\"><code>Try</code></a> monad as <code>Optional</code> is with the <code>Maybe</code> monad: it draws inspiration from it, but is adapted to the Java idiom (such as actually throwing exceptions, even from non-terminal operations).</p>\n\n<p>These are some key guidelines followed by the class:</p>\n\n<ul>\n<li><p>as opposed to the monadic approach, doesn't ignore Java's exception mechanism; </p></li>\n<li><p>instead it relieves the impedance mismatch between exceptions and higher-order functions;</p></li>\n<li><p>exception handling not statically typesafe (due to sneaky throwing), but always safe at runtime (never swallows an exception except on explicit request).</p></li>\n</ul>\n\n<p>The class tries to cover all the typical ways to handle an exception:</p>\n\n<ul>\n<li><code>recover</code> with some handling code which provides a substitute value;</li>\n<li><code>flatRecover</code> which, analogous to <code>flatMap</code>, allows to return a new <code>Exceptional</code> instance which will be unwrapped and the state of the current instance suitably updated;</li>\n<li><code>propagate</code> an exception, throwing it from the <code>Exceptional</code> expression and making the <code>propagate</code> call declare this exception type;</li>\n<li><code>propagate</code> it after wrapping into another exception (<em>translate</em> it);</li>\n<li><code>handle</code> it, resulting in an empty <code>Exceptional</code>;</li>\n<li>as a special case of handling, <code>swallow</code> it with an empty handler block.</li>\n</ul>\n\n<p>The <code>propagate</code> approach allows one to selectively pick which checked exceptions he wants to expose from his code. Exceptions which remain unhandled at the time a terminal operation is called (like <code>get</code>) will be <em>sneakily</em> thrown without declaration. This is often considered as an advanced and dangerous approach, but is nevertheless often employed as a way to somewhat alleviate the nuisance of checked exceptions in combination with lambda shapes which do not declare them. The <code>Exceptional</code> class hopes to offer a cleaner and more selective alternative to sneaky throw.</p>\n\n<hr>\n\n<pre><code>/*\n * Copyright (c) 2015, Marko Topolnik. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic final class Exceptional&lt;T&gt;\n{\n  private final T value;\n  private final Throwable exception;\n\n  private Exceptional(T value, Throwable exc) {\n    this.value = value;\n    this.exception = exc;\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; empty() {\n    return new Exceptional&lt;&gt;(null, null);\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; ofNullable(T value) {\n    return value != null ? of(value) : empty();\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; of(T value) {\n    return new Exceptional&lt;&gt;(Objects.requireNonNull(value), null);\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; ofNullableException(Throwable exception) {\n    return exception != null? new Exceptional&lt;&gt;(null, exception) : empty();\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; ofException(Throwable exception) {\n    return new Exceptional&lt;&gt;(null, Objects.requireNonNull(exception));\n  }\n\n  public static &lt;T&gt; Exceptional&lt;T&gt; from(TrySupplier&lt;T&gt; supplier) {\n    try {\n      return ofNullable(supplier.tryGet());\n    } catch (Throwable t) {\n      return new Exceptional&lt;&gt;(null, t);\n    }\n  }\n\n  public static Exceptional&lt;Void&gt; fromVoid(TryRunnable task) {\n    try {\n      task.run();\n      return new Exceptional&lt;&gt;(null, null);\n    } catch (Throwable t) {\n      return new Exceptional&lt;&gt;(null, t);\n    }\n  }\n\n  public static &lt;E extends Throwable&gt; Consumer&lt;? super E&gt; swallow() {\n    return e -&gt; {};\n  }\n\n  public T get() {\n    if (value != null) return value;\n    if (exception != null) sneakyThrow(exception);\n    throw new NoSuchElementException(\"No value present\");\n  }\n\n  public T orElse(T other) {\n    if (value != null) return value;\n    if (exception != null) sneakyThrow(exception);\n    return other;\n  }\n\n  public T orElseGet(Supplier&lt;? extends T&gt; other) {\n    if (value != null) return value;\n    if (exception != null) sneakyThrow(exception);\n    return other.get();\n  }\n\n  public&lt;U&gt; Exceptional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {\n    Objects.requireNonNull(mapper);\n    if (value == null) return new Exceptional&lt;&gt;(null, exception);\n    final U u;\n    try {\n      u = mapper.apply(value);\n    } catch (Throwable exc) {\n      return new Exceptional&lt;&gt;(null, exc);\n    }\n    return ofNullable(u);\n  }\n\n  public&lt;U&gt; Exceptional&lt;U&gt; flatMap(Function&lt;? super T, Exceptional&lt;U&gt;&gt; mapper) {\n    Objects.requireNonNull(mapper);\n    return value != null ? Objects.requireNonNull(mapper.apply(value)) : empty();\n  }\n\n  public Exceptional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {\n    Objects.requireNonNull(predicate);\n    if (value == null) return this;\n    final boolean b;\n    try {\n      b = predicate.test(value);\n    } catch (Throwable t) {\n      return ofException(t);\n    }\n    return b ? this : empty();\n  }\n\n  public &lt;X extends Throwable&gt; Exceptional&lt;T&gt; recover(\n      Class&lt;? extends X&gt; excType, Function&lt;? super X, T&gt; mapper)\n  {\n    Objects.requireNonNull(mapper);\n    return excType.isInstance(exception) ? ofNullable(mapper.apply(excType.cast(exception))) : this;\n  }\n\n  public &lt;X extends Throwable&gt; Exceptional&lt;T&gt; recover(\n      Iterable&lt;Class&lt;? extends X&gt;&gt; excTypes, Function&lt;? super X, T&gt; mapper)\n  {\n    Objects.requireNonNull(mapper);\n    for (Class&lt;? extends X&gt; excType : excTypes)\n      if (excType.isInstance(exception))\n        return ofNullable(mapper.apply(excType.cast(exception)));\n    return this;\n  }\n\n  public &lt;X extends Throwable&gt; Exceptional&lt;T&gt; flatRecover(\n      Class&lt;? extends X&gt; excType, Function&lt;? super X, Exceptional&lt;T&gt;&gt; mapper)\n  {\n    Objects.requireNonNull(mapper);\n    return excType.isInstance(exception) ? Objects.requireNonNull(mapper.apply(excType.cast(exception))) : this;\n  }\n\n  public &lt;X extends Throwable&gt; Exceptional&lt;T&gt; flatRecover(\n      Iterable&lt;Class&lt;? extends X&gt;&gt; excTypes, Function&lt;? super X, Exceptional&lt;T&gt;&gt; mapper)\n  {\n    Objects.requireNonNull(mapper);\n    for (Class&lt;? extends X&gt; c : excTypes)\n      if (c.isInstance(exception))\n        return Objects.requireNonNull(mapper.apply(c.cast(exception)));\n    return this;\n  }\n\n  public &lt;E extends Throwable&gt; Exceptional&lt;T&gt; propagate(Class&lt;E&gt; excType) throws E {\n    if (excType.isInstance(exception))\n      throw excType.cast(exception);\n    return this;\n  }\n\n  public &lt;E extends Throwable&gt; Exceptional&lt;T&gt; propagate(Iterable&lt;Class&lt;? extends E&gt;&gt; excTypes) throws E {\n    for (Class&lt;? extends E&gt; excType : excTypes)\n      if (excType.isInstance(exception))\n        throw excType.cast(exception);\n    return this;\n  }\n\n  public &lt;E extends Throwable, F extends Throwable&gt; Exceptional&lt;T&gt; propagate(\n      Class&lt;E&gt; excType, Function&lt;? super E, ? extends F&gt; translator)\n  throws F\n  {\n    if (excType.isInstance(exception))\n      throw translator.apply(excType.cast(exception));\n    return this;\n  }\n\n  public &lt;E extends Throwable, F extends Throwable&gt; Exceptional&lt;T&gt; propagate(\n      Iterable&lt;Class&lt;E&gt;&gt; excTypes, Function&lt;? super E, ? extends F&gt; translator)\n  throws F\n  {\n    for (Class&lt;? extends E&gt; excType : excTypes)\n      if (excType.isInstance(exception))\n        throw translator.apply(excType.cast(exception));\n    return this;\n  }\n\n  public &lt;E extends Throwable&gt; Exceptional&lt;T&gt; handle(Class&lt;E&gt; excType, Consumer&lt;? super E&gt; action) {\n    if (excType.isInstance(exception)) {\n      action.accept(excType.cast(exception));\n      return empty();\n    }\n    return this;\n  }\n\n  public &lt;E extends Throwable&gt; Exceptional&lt;T&gt; handle(Iterable&lt;Class&lt;E&gt;&gt; excTypes, Consumer&lt;? super E&gt; action) {\n    for (Class&lt;? extends E&gt; excType : excTypes)\n      if (excType.isInstance(exception)) {\n        action.accept(excType.cast(exception));\n        return empty();\n      }\n    return this;\n  }\n\n  public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X {\n    if (value != null) return value;\n    if (exception != null) sneakyThrow(exception);\n    throw exceptionSupplier.get();\n  }\n\n  public boolean isPresent() {\n    return value != null;\n  }\n\n  public void ifPresent(Consumer&lt;? super T&gt; consumer) {\n    if (value != null)\n      consumer.accept(value);\n    if (exception != null) sneakyThrow(exception);\n  }\n\n  public boolean isException() {\n    return exception != null;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) return true;\n    return obj instanceof Exceptional &amp;&amp; Objects.equals(value, ((Exceptional)obj).value);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hashCode(value);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private static &lt;T extends Throwable&gt; void sneakyThrow(Throwable t) throws T {\n    throw (T) t;\n  }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>@FunctionalInterface\npublic interface TrySupplier&lt;T&gt; {\n  T tryGet() throws Throwable;\n}\n</code></pre>\n\n<hr>\n\n<pre><code>@FunctionalInterface\npublic interface TryRunnable {\n  void run() throws Throwable;\n}\n</code></pre>\n    "},{"t":"Why is the SIZE constant only @Native for Integer and Long?","l":"http://stackoverflow.com/questions/28770822/why-is-the-size-constant-only-native-for-integer-and-long","q":"\n\n<p>I understand the use of the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Native.html\" rel=\"nofollow\"><code>@Native</code></a> annotation.</p>\n\n<blockquote>\n  <p>Indicates that a field defining a constant value may be referenced\n  from native code. The annotation may be used as a hint by tools that\n  generate native header files to determine whether a header file is\n  required, and if so, what declarations it should contain.</p>\n</blockquote>\n\n<p>However, while reading the java source code I noticed that in the class <code>Integer</code> and <code>Long</code> the <code>SIZE</code> constant is <code>@Native</code> while it is not for the Float, Byte, Double, Short and Character.</p>\n\n<p>Note that the SIZE constant represents the number of bits used to represent the actual value.</p>\n\n<pre><code>public static final int SIZE = 8;//Byte\npublic static final int SIZE = 16;//Character\npublic static final int SIZE = 16;//Short\npublic static final int SIZE = 32;//Float\n@Native public static final int SIZE = 32;//Integer\n@Native public static final int SIZE = 64;//Long\npublic static final int SIZE = 64;//Double\n</code></pre>\n\n<hr>\n\n<p><strong>Edit :</strong> I just noticed that this also applies for <code>MAX_VALUE</code> and <code>MIN_VALUE</code> of the same classes.</p>\n\n<hr>\n\n<p><strong>Edit 2 :</strong> I had spare time to do some research on this, and looking at the header files of the Long, Float etc. classes I had hope to figure out that the constants were not present in the other headers, but unfortunately they are.</p>\n\n<pre><code>static const jint SIZE = 8L;//java/lang/Byte.h\nstatic const jint SIZE = 16L;//java/lang/Character.h\nstatic const jint SIZE = 16L;//java/lang/Short.h\nstatic const jint SIZE = 32L;//java/lang/Float.h\nstatic const jint SIZE = 32L;//java/lang/Integer.h\nstatic const jint SIZE = 64L;//java/lang/Double.h\nstatic const jint SIZE = 64L;//java/lang/Long.h\n</code></pre>\n\n<hr>\n\n<p><strong>Why is the SIZE constant only @Native for Integer and Long ?</strong></p>\n    ","a":"\n<p><strong>TLDR</strong>: Jump to the conclusion</p>\n\n<hr>\n\n<blockquote>\n  <p>Why is the SIZE constant only @Native for Integer and Long?</p>\n</blockquote>\n\n<h2>A brief history of <code>@Native</code></h2>\n\n<p>I made some search on the mailing lists. I found some interesting things.</p>\n\n<p><strong>At first</strong> an annotation (<a href=\"http://mail.openjdk.java.net/pipermail/build-infra-dev/2011-November/000234.html\">1</a> <a href=\"http://mail.openjdk.java.net/pipermail/build-infra-dev/2011-November/000234.html\">2</a>) <a href=\"http://hg.openjdk.java.net/build-infra/jdk7/langtools/file/5d684df20334/src/share/classes/javax/tools/ForceNativeHeader.java\"><code>javax.tools.annotation.ForceNativeHeader</code></a>\n was introduced to</p>\n\n<blockquote>\n  <p>to trigger javah on a class.</p>\n</blockquote>\n\n<p>It is used by <a href=\"http://hg.openjdk.java.net/build-infra/jdk7/langtools/file/5d684df20334/src/share/classes/com/sun/tools/javac/processing/NativeapiVisitor.java\"><code>com.sun.tools.javac.processing.NativeapiVisitor</code></a>. By looking at the code we can see that the native header is generated if the class declare some native methods or if the class is annotated <code>@ForceNativeHeader</code>.</p>\n\n<p><strong>Later</strong> this annotation was renamed to <a href=\"http://hg.openjdk.java.net/build-infra/jdk8/langtools/file/27344710eaf1/src/share/classes/javax/tools/annotation/GenerateNativeHeader.java\"><code>GenerateNativeHeader</code></a> (<a href=\"http://mail.openjdk.java.net/pipermail/build-infra-dev/2012-March/000546.html\">1</a> <a href=\"http://mail.openjdk.java.net/pipermail/build-infra-dev/2012-March/000545.html\">2</a>).</p>\n\n<p><strong>Then</strong> <a href=\"http://cr.openjdk.java.net/~ohair/openjdk8/generateHeaders1/webrev/\">this annotation was added to several types</a> (especially <a href=\"http://cr.openjdk.java.net/~ohair/openjdk8/generateHeaders1/webrev/src/share/classes/java/lang/Integer.java.udiff.html\">Integer</a> and <a href=\"http://cr.openjdk.java.net/~ohair/openjdk8/generateHeaders1/webrev/src/share/classes/java/lang/Long.java.udiff.html\">Long</a>) with an interresting comment:</p>\n\n<pre><code>/* No native methods here, but the constants are needed in the supporting JNI code */\n@GenerateNativeHeader\npublic final class Long extends Number implements Comparable&lt;Long&gt; {...\n</code></pre>\n\n<p><strong>But</strong> by adding this annotation it add <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8000404\">a problematic dependency</a> from base module to the module containing javax.tools. So the annotation were removed from <a href=\"http://cr.openjdk.java.net/~erikj/build-infra-m1.1/jdk-base-headers/src/share/classes/java/lang/Integer.java.udiff.html\"><code>Integer</code></a> and <a href=\"http://cr.openjdk.java.net/~erikj/build-infra-m1.1/jdk-base-headers/src/share/classes/java/lang/Long.java.udiff.html\"><code>Long</code></a> and these files were explicitly <a href=\"http://cr.openjdk.java.net/~erikj/build-infra-m1.1/jdk-base-headers/makefiles/CompileJavaClasses.gmk.udiff.html\">added to the build process</a> since the header were no more automatically generated... a <a href=\"http://mail.openjdk.java.net/pipermail/build-dev/2012-June/006238.html\">\"(hopefully temporary) hack\"</a>.</p>\n\n<p><strong>So</strong> a new annotation <code>java.lang.annotation.Native</code> <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/rev/369709a13823\">was created</a> and used in <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/f92ab6dbbff8/src/share/classes/java/lang/Integer.java\">Integer</a> and <a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/f92ab6dbbff8/src/share/classes/java/lang/Long.java\">Long</a>. The annotation was set a <code>TargetType FIELD</code>.</p>\n\n<blockquote>\n  <p>the annotation should be directly applied to the constant fields that need to be exported -- and not to the class as a whole. </p>\n</blockquote>\n\n<hr>\n\n<p>All the purpose of this stuff is:</p>\n\n<blockquote>\n  <p>javac could generate native headers for classes containing native methods.</p>\n</blockquote>\n\n<p>It is the case of <code>Integer</code> and <code>Long</code></p>\n\n<p>this was a part of the <a href=\"http://openjdk.java.net/jeps/139\">JEP 139: Enhance javac to Improve Build Speed</a>:</p>\n\n<blockquote>\n  <p>javah will be automatically run on any class that contains native methods and the generated C-headers will be put in the (-h) headerdir. A new annotation @ForceNativeHeader is used for classes that have final static primitives that need to be exported to JNI, but no native methods.</p>\n</blockquote>\n\n<hr>\n\n<h2>A basic experimentation</h2>\n\n<p>I made a basic experimentation on the JDK. I clone the open-jdk forest and i successfully build it. As expected the header files where generated for <code>Integer</code> and <code>Long</code> (thanks to <code>@Native</code>) and for <code>Float</code> and <code>Double</code> (thanks to their native methods) but not for <code>Byte</code>, <code>Short</code>...</p>\n\n<pre><code>    ls -l build/macosx-x86_64-normal-server-release/support/headers/java.base/java_lang_*\n    ...\n    java_lang_Double.h\n    java_lang_Float.h\n    java_lang_Integer.h\n    java_lang_Long.h\n    java_lang_Object.h\n    java_lang_Package.h\n    ...\n</code></pre>\n\n<p>Then i tried to remove the <code>@Native</code> from the <code>Integer</code> fields and i tried to build again the <code>jdk</code> but i get an error:</p>\n\n<pre><code>jdk/src/java.base/unix/native/libnio/ch/FileChannelImpl.c:35:10: fatal error: 'java_lang_Integer.h' file not found\n#include \"java_lang_Integer.h\"\n         ^\n1 error generated.\n</code></pre>\n\n<p>logically since the header have not been generated.</p>\n\n<p>I have also confirmed that <code>java_lang_Integer.h</code> is included <strong>in several c and cpp files</strong>:</p>\n\n<pre><code>find .  \\( -name \"*.c\" -o -name \"*.cpp\" \\) -exec grep \"java_lang_Integer.h\" {} \\; -print\n#include \"java_lang_Integer.h\"\n./jdk/src/java.base/unix/native/libnio/ch/FileChannelImpl.c\n#include \"java_lang_Integer.h\"\n./jdk/src/java.base/unix/native/libnio/ch/IOUtil.c\n#include \"java_lang_Integer.h\"\n./jdk/src/java.base/windows/native/libnet/TwoStacksPlainSocketImpl.c\n#include \"java_lang_Integer.h\"\n./jdk/src/java.base/windows/native/libnio/ch/FileChannelImpl.c\n#include &lt;java_lang_Integer.h&gt;\n./jdk/src/java.desktop/windows/native/libawt/windows/awt_Frame.cpp\n</code></pre>\n\n<p>like <code>Long</code></p>\n\n<pre><code>find .  \\( -name \"*.c\" -o -name \"*.cpp\" \\) -exec grep \"java_lang_Long.h\" {} \\; -print\n#include \"java_lang_Long.h\"\n./jdk/src/java.base/unix/native/libnio/ch/FileDispatcherImpl.c\n</code></pre>\n\n<p>like <code>Float</code></p>\n\n<pre><code>find .  \\( -name \"*.c\" -o -name \"*.cpp\" \\) -exec grep \"java_lang_Float.h\" {} \\; -print\n#include \"java_lang_Float.h\"\n./jdk/src/java.base/share/native/libjava/Float.c\n#include \"java_lang_Float.h\"\n./jdk/src/java.base/share/native/libjava/ObjectInputStream.c\n#include \"java_lang_Float.h\"\n./jdk/src/java.base/share/native/libjava/ObjectOutputStream.c\n</code></pre>\n\n<p>and like <code>Double</code></p>\n\n<pre><code>find .  \\( -name \"*.c\" -o -name \"*.cpp\" \\) -exec grep \"java_lang_Double.h\" {} \\; -print\n#include \"java_lang_Double.h\"\n./jdk/src/java.base/share/native/libjava/Double.c\n#include \"java_lang_Double.h\"\n./jdk/src/java.base/share/native/libjava/ObjectInputStream.c\n#include \"java_lang_Double.h\"\n./jdk/src/java.base/share/native/libjava/ObjectOutputStream.c\n</code></pre>\n\n<p>but neither <code>Short</code></p>\n\n<pre><code>find .  \\( -name \"*.c\" -o -name \"*.cpp\" \\) -exec grep \"java_lang_Short.h\" {} \\; -print\n</code></pre>\n\n<p>nor <code>Byte</code>, nor <code>Character</code>.</p>\n\n<hr>\n\n<h1>Conclusion</h1>\n\n<p>Among all these types, <strong>only</strong> <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code> are used in the <strong>native source code of the jdk</strong>.</p>\n\n<p>And only the <code>Integer</code> and <code>Long</code> fields are annotated with <strong><code>@Native</code></strong> because they have <strong>no native methods</strong> (as opposed to <code>Float</code> and <code>Double</code>)</p>\n    "},{"t":"Collect successive pairs from a stream","l":"http://stackoverflow.com/questions/20470010/collect-successive-pairs-from-a-stream","q":"\n\n<p>Given a stream such as <code>{ 0, 1, 2, 3, 4 }</code>, </p>\n\n<p>how can I most elegantly transform it into given form:</p>\n\n<p><code>{ new Pair(0, 1), new Pair(1, 2), new Pair(2, 3), new Pair(3, 4) }</code> </p>\n\n<p>(assuming, of course, I've defined class Pair)?</p>\n\n<p><strong>Edit:</strong> This isn't strictly about ints or primitive streams. The answer should be general for a stream of any type.</p>\n    ","a":"\n<p>My <a href=\"https://github.com/amaembo/streamex\" rel=\"nofollow\">StreamEx</a> library which extends standard streams provides a <a href=\"http://amaembo.github.io/streamex/javadoc/javax/util/streamex/StreamEx.html#pairMap-java.util.function.BiFunction-\" rel=\"nofollow\"><code>pairMap</code></a> method for all stream types. For primitive streams it does not change the stream type, but can be used to make some calculations. Most common usage is to calculate differences:</p>\n\n<pre><code>int[] pairwiseDiffs = IntStreamEx.of(input).pairMap((a, b) -&gt; (b-a)).toArray();\n</code></pre>\n\n<p>For object stream you can create any other object type. My library does not provide any new user-visible data structures like <code>Pair</code> (that's the part of library concept). However if you have your own <code>Pair</code> class and want to use it, you can do the following:</p>\n\n<pre><code>Stream&lt;Pair&gt; pairs = IntStreamEx.of(input).boxed().pairMap(Pair::new);\n</code></pre>\n\n<p>Or if you already have some <code>Stream</code>:</p>\n\n<pre><code>Stream&lt;Pair&gt; pairs = StreamEx.of(stream).pairMap(Pair::new);\n</code></pre>\n\n<p>This functionality is implemented using <a href=\"https://github.com/amaembo/streamex/blob/master/src/main/java/javax/util/streamex/PairSpliterator.java\" rel=\"nofollow\">custom spliterator</a>. It has quite low overhead and can parallelize nicely. Of course it works with any stream source, not just random access list/array like many other solutions. In many tests it performs really well. <a href=\"https://gist.github.com/amaembo/336df22ea21316feccf1\" rel=\"nofollow\">Here's</a> a JMH benchmark where we find all input values preceding a larger value using different approaches (see <a href=\"http://stackoverflow.com/q/30089761/4856258\">this</a> question).</p>\n    "},{"t":"Limit a stream by a predicate","l":"http://stackoverflow.com/questions/20746429/limit-a-stream-by-a-predicate","q":"\n\n<p>Is there a Java 8 stream operation that limits a (potentially infinite) <code>Stream</code> until the first element that fails to match a predicate? Something that looks like the (non-existent) <code>takeWhile</code> operation in the example below and would print all numbers less than 10?</p>\n\n<pre><code>IntStream\n    .iterate(1, n -&gt; n + 1)\n    .takeWhile(n -&gt; n &lt; 10)\n    .forEach(System.out::println);\n</code></pre>\n\n<p>If there is no such operation, what's the best way of implementing it in a general way? </p>\n    ","a":"\n<p>Such an operation ought to be <em>possible</em> with a Java 8 <code>Stream</code>, but it can't necessarily be done efficiently -- for example, you can't necessarily parallelize such an operation, as you have to look at elements in order.</p>\n\n<p>The API doesn't provide an easy way to do it, but what's probably the simplest way is to take <code>Stream.iterator()</code>, wrap the <code>Iterator</code> to have a \"take-while\" implementation, and then go back to a <code>Spliterator</code> and then a <code>Stream</code>.  Or -- maybe -- wrap the <code>Spliterator</code>, though it can't really be split anymore in this implementation.</p>\n\n<p>Here's an untested implementation of <code>takeWhile</code> on a <code>Spliterator</code>:</p>\n\n<pre><code>static &lt;T&gt; Spliterator&lt;T&gt; takeWhile(\n    Spliterator&lt;T&gt; splitr, Predicate&lt;? super T&gt; predicate) {\n  return new Spliterators.AbstractSpliterator&lt;T&gt;(splitr.estimateSize(), 0) {\n    boolean stillGoing = true;\n    @Override public boolean tryAdvance(Consumer&lt;? super T&gt; consumer) {\n      if (stillGoing) {\n        boolean hadNext = splitr.tryAdvance(elem -&gt; {\n          if (predicate.test(elem)) {\n            consumer.accept(elem);\n          } else {\n            stillGoing = false;\n          }\n        });\n        return hadNext &amp;&amp; stillGoing;\n      }\n      return false;\n    }\n  };\n}\n</code></pre>\n    "},{"t":"Android Studio - supplied javaHome is not a valid folder","l":"http://stackoverflow.com/questions/22749200/android-studio-supplied-javahome-is-not-a-valid-folder","q":"\n\n<p>I decided to update my JDK to Java 8, and installed to the default location of <code>C:\\Program Files\\Java\\jdk1.8.0</code> with a <code>jre</code> subdirectory.</p>\n\n<p>I wasn't sure how Android Studio worked out the JDK location, so I decided to launch it and see. I got the following message:</p>\n\n<blockquote>\n  <p>Failed to complete Gradle execution.</p>\n  \n  <p>Cause:\n  Supplied javaHome is not a valid folder. You supplied: C:\\Program Files\\Java\\jdk1.7.0_45</p>\n</blockquote>\n\n<p>I updated my JAVA_HOME environment variable (both for system and user) to point to the new path, and tried adding it to my PATH variable as well, but every time I attempt to build in Android Studio I get the same message. The quoted path is nowhere to be found in my environment variables though, so where is it getting it from and how can I change it?</p>\n\n<p>Thanks</p>\n    ","a":"\n<p>The problem was my <strong>project's</strong> JDK location. From the Android Studio Project tool window, I right clicked on the root directory, selected 'module settings', and set the JDK location. Everything's fine now.</p>\n    "},{"t":"Does Java 8 provide a good way to repeat a value or function?","l":"http://stackoverflow.com/questions/18532488/does-java-8-provide-a-good-way-to-repeat-a-value-or-function","q":"\n\n<p>In many other languages, eg. Haskell, it is easy to repeat a value or function multiple times, eg. to get a list of 8 copies of the value 1:</p>\n\n<pre><code>take 8 (repeat 1)\n</code></pre>\n\n<p>but I haven't found this yet in Java 8.  Is there such a function in Java 8's JDK?</p>\n\n<p>Or alternatively something equivalent to a range like</p>\n\n<pre><code>[1..8]\n</code></pre>\n\n<p>It would seem an obvious replacement for a verbose statement in Java like</p>\n\n<pre><code>for (int i = 1; i &lt;= 8; i++) {\n    System.out.println(i);\n}\n</code></pre>\n\n<p>to have something like</p>\n\n<pre><code>Range.from(1, 8).forEach(i -&gt; System.out.println(i))\n</code></pre>\n\n<p>though this particular example doesn't look much more concise actually...  but hopefully it's more readable.</p>\n    ","a":"\n<p>For this specific example, you could do:</p>\n\n<pre><code>IntStream.rangeClosed(1, 8)\n         .forEach(System.out::println);\n</code></pre>\n\n<p>If you need a step different from 1, you can use a mapping function, for example, for a step of 2:</p>\n\n<pre><code>IntStream.rangeClosed(1, 8)\n         .map(i -&gt; 2 * i - 1)\n         .forEach(System.out::println);\n</code></pre>\n\n<p>Or build a custom iteration and limit the size of the iteration:</p>\n\n<pre><code>IntStream.iterate(1, i -&gt; i + 2)\n         .limit(8)\n         .forEach(System.out::println);\n</code></pre>\n    "},{"t":"How to negate a method reference predicate","l":"http://stackoverflow.com/questions/21488056/how-to-negate-a-method-reference-predicate","q":"\n\n<p>In Java 8, you can use a method reference to filter a stream, for example:</p>\n\n<pre><code>Stream&lt;String&gt; s = ...;\nint emptyStrings = s.filter(String::isEmpty).count();\n</code></pre>\n\n<p>Is there a way to create a method reference that is the negation of an existing one, i.e. something like:</p>\n\n<pre><code>int nonEmptyStrings = s.filter(not(String::isEmpty)).count();\n</code></pre>\n\n<p>I could create the <code>not</code> method like below but I was wondering if the JDK offered something similar.</p>\n\n<pre><code>static &lt;T&gt; Predicate&lt;T&gt; not(Predicate&lt;T&gt; p) { return o -&gt; !p.test(o); }\n</code></pre>\n    ","a":"\n<p>There is no way to compose a method reference that is the opposite of a current method reference. However, it is not too troublesome to do it some other ways.</p>\n\n<p>The opposite of this:</p>\n\n<pre><code>Stream&lt;String&gt; s = ...;\nint emptyStrings = s.filter(String::isEmpty).count();\n</code></pre>\n\n<p>is this:</p>\n\n<pre><code>Stream&lt;String&gt; s = ...;\nint notEmptyStrings = s.filter( it -&gt; !it.isEmpty() ).count();\n</code></pre>\n\n<p>or make a predicate and reuse it:</p>\n\n<pre><code>Predicate&lt;String&gt; notEmpty = (String it) -&gt; !it.isEmpty();\n\nStream&lt;String&gt; s = ...;\nint emptyStrings = s.filter(notEmpty).count();\n</code></pre>\n\n<p>or just use a for-loop which is a lot faster to run and has less overhead:</p>\n\n<pre><code>int notEmpty = 0;\nfor(String s : list) if(!s.isEmpty()) notEmpty++;\n</code></pre>\n    "},{"t":"Zipping streams using JDK8 with lambda (java.util.stream.Streams.zip)","l":"http://stackoverflow.com/questions/17640754/zipping-streams-using-jdk8-with-lambda-java-util-stream-streams-zip","q":"\n\n<p>In JDK 8 with lambda b93 there was a class <a href=\"http://download.java.net/lambda/b93/docs/api/java/util/stream/Streams.html\">java.util.stream.Streams.zip in b93</a> which could be used to zip streams (this is illustrated in the tutorial <a href=\"http://blog.dhananjaynene.com/2013/02/exploring-java-8-lambdas-part-1/\">Exploring Java8 Lambdas. Part 1 by Dhananjay Nene</a>). This function :</p>\n\n<blockquote>\n  <p>Creates a lazy and sequential combined Stream whose elements are the\n  result of combining the elements of two streams.</p>\n</blockquote>\n\n<p>However in b98 this has disappeared. Infact the <code>Streams</code> class is not even accessible in <a href=\"http://download.java.net/lambda/b98/docs/api/java/util/stream/package-summary.html\">java.util.stream in b98</a>. </p>\n\n<p><strong>Has this functionality been moved, and if so how do I zip streams concisely using b98?</strong> </p>\n\n<p>The application I have in mind is <a href=\"https://github.com/hraberg/Shen.java/commit/e260f6a6c4f4012642b44c9a93c4a761cef18aa0#diff-0\">in this java implementation of Shen</a>, where I replaced the zip functionality in the </p>\n\n<ul>\n<li><code>static &lt;T&gt; boolean every(Collection&lt;T&gt; c1, Collection&lt;T&gt; c2, BiPredicate&lt;T, T&gt; pred)</code></li>\n<li><code>static &lt;T&gt; T find(Collection&lt;T&gt; c1, Collection&lt;T&gt; c2, BiPredicate&lt;T, T&gt; pred)</code></li>\n</ul>\n\n<p>functions with rather verbose code (which doesn't use functionality from b98).</p>\n    ","a":"\n<p>I needed this as well so I just took the source code from b93 and put it in a \"util\" class. I had to modify it slightly to work with the current API. </p>\n\n<p>For reference here's the working code (take it at your own risk...):</p>\n\n<pre><code>public static&lt;A, B, C&gt; Stream&lt;C&gt; zip(Stream&lt;? extends A&gt; a,\n                                     Stream&lt;? extends B&gt; b,\n                                     BiFunction&lt;? super A, ? super B, ? extends C&gt; zipper) {\n    Objects.requireNonNull(zipper);\n    @SuppressWarnings(\"unchecked\")\n    Spliterator&lt;A&gt; aSpliterator = (Spliterator&lt;A&gt;) Objects.requireNonNull(a).spliterator();\n    @SuppressWarnings(\"unchecked\")\n    Spliterator&lt;B&gt; bSpliterator = (Spliterator&lt;B&gt;) Objects.requireNonNull(b).spliterator();\n\n    // Zipping looses DISTINCT and SORTED characteristics\n    int both = aSpliterator.characteristics() &amp; bSpliterator.characteristics() &amp;\n            ~(Spliterator.DISTINCT | Spliterator.SORTED);\n    int characteristics = both;\n\n    long zipSize = ((characteristics &amp; Spliterator.SIZED) != 0)\n            ? Math.min(aSpliterator.getExactSizeIfKnown(), bSpliterator.getExactSizeIfKnown())\n            : -1;\n\n    Iterator&lt;A&gt; aIterator = Spliterators.iterator(aSpliterator);\n    Iterator&lt;B&gt; bIterator = Spliterators.iterator(bSpliterator);\n    Iterator&lt;C&gt; cIterator = new Iterator&lt;C&gt;() {\n        @Override\n        public boolean hasNext() {\n            return aIterator.hasNext() &amp;&amp; bIterator.hasNext();\n        }\n\n        @Override\n        public C next() {\n            return zipper.apply(aIterator.next(), bIterator.next());\n        }\n    };\n\n    Spliterator&lt;C&gt; split = Spliterators.spliterator(cIterator, zipSize, characteristics);\n    return (a.isParallel() || b.isParallel())\n           ? StreamSupport.stream(split, true)\n           : StreamSupport.stream(split, false);\n}\n</code></pre>\n    "},{"t":"How do I convert a Java 8 IntStream to a List?","l":"http://stackoverflow.com/questions/23674624/how-do-i-convert-a-java-8-intstream-to-a-list","q":"\n\n<p>I'm looking at the docs for the <code>IntStream</code>, and I see an <code>toArray</code> method, but no way to go directly to a <code>List&lt;Integer&gt;</code></p>\n\n<p>Surely there is a way to convert a <code>Stream</code> to a <code>List</code>?</p>\n    ","a":"\n<p><code>IntStream.boxed</code> turns an <code>IntStream</code> into a <code>Stream&lt;Integer&gt;</code>, which you can then <code>collect</code> into a list:</p>\n\n<pre><code>theIntStream.boxed().collect(Collectors.toList())\n</code></pre>\n    "},{"t":"Has anybody yet backported Lambda Expressions to Java 7?","l":"http://stackoverflow.com/questions/17756604/has-anybody-yet-backported-lambda-expressions-to-java-7","q":"\n\n<p>Reading about <a href=\"http://eng.wealthfront.com/2013/04/i-can-haz-lambda-on-java-7.html\">what kind of bytecode Java 8 produces from lambdas</a>, it came to my mind the time when Java 5 was released. Back then there was <a href=\"http://retroweaver.sourceforge.net/\">Retroweaver</a> and <a href=\"http://en.wikipedia.org/wiki/Java_backporting_tools\">other tools</a> for converting bytecode compiled with JDK 5 to run on JRE 1.4.</p>\n\n<p><strong>Has anybody yet created such a backporting tool for Java 8 lambdas?</strong> It would let Java developers start using lambdas already today on production-quality Java 7 JREs, without having to wait 6-12 months for Java 8's GA release.</p>\n\n<p>Here is my analysis of why such as backporter should be implementable relatively easily:</p>\n\n<p>Java 8 lambdas don't seem to use any JVM features that Java 7 wouldn't have (e.g. <code>invokedynamic</code>), and the <code>java.lang.invoke.LambdaMetafactory</code> class and its dependencies look like pure Java, so it should be possible to implement them in a 3rd-party library. Thus bytecode compiled with JDK 8 could be made to run on JRE 7 by adding a 3rd-party library with a copy of LambdaMetafactory (under a different package) and by transforming the bytecode to use that metafactory instead. Maybe also generate some synthetic classes and methods to bypass accessibility checks, as <code>java.lang.invoke.MagicLambdaImpl</code> seems to imply. Or then generate anonymous inner classes for all lambdas, like some of the first lambda-enabled Early Access JDKs did.</p>\n    ","a":"\n<p>There is now <a href=\"https://github.com/orfjackal/retrolambda\">Retrolambda</a> for converting Java 8 bytecode, which uses lambda expressions and method references, to work on Java 7, 6 or 5. (Java 1.4 gave verify errors; did not investigate further.)</p>\n    "},{"t":"Understanding Spliterator, Collector and Stream in Java 8","l":"http://stackoverflow.com/questions/19235606/understanding-spliterator-collector-and-stream-in-java-8","q":"\n\n<p>I am having trouble understanding the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\"><code>Stream</code></a> interface in Java 8, especially where it has to do with the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html\"><code>Spliterator</code></a> and <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html\"><code>Collector</code></a> interfaces. My problem is that I simply can't understand yet the <code>Spliterator</code> and the <code>Collector</code> interfaces, and as a result the <code>Stream</code> interface is still somewhat obscure to me.</p>\n\n<p>What exactly is a <code>Spliterator</code> and a <code>Collector</code>, and how can I use them? If I am willing to write my own <code>Spliterator</code> or <code>Collector</code> (and probably my own <code>Stream</code> in that process), what should I do and not do?</p>\n\n<p>I read some examples scattered around the web, but since everything here is stil new and subject to changes, examples and tutorials are still very sparse.</p>\n    ","a":"\n<p>You should almost certainly never have to deal with <code>Spliterator</code> as a user; it should only be necessary if you're writing <code>Collection</code> types yourself and <em>also</em> intending to optimize parallelized operations on them. </p>\n\n<p>For what it's worth, a <code>Spliterator</code> is a way of operating over the elements of a collection in a way that it's easy to split off part of the collection, e.g. because you're parallelizing and want one thread to work on one part of the collection, one thread to work on another part, etc.</p>\n\n<p>You should essentially never be saving values of type <code>Stream</code> to a variable, either.  <code>Stream</code> is sort of like an <code>Iterator</code>, in that it's a one-time-use object that you'll almost always use in a fluent chain, as in the Javadoc example:</p>\n\n<pre><code>int sum = widgets.stream()\n                  .filter(w -&gt; w.getColor() == RED)\n                  .mapToInt(w -&gt; w.getWeight())\n                  .sum();\n</code></pre>\n\n<p><code>Collector</code> is the most generalized, abstract possible version of a \"reduce\" operation a la map/reduce; in particular, it needs to support parallelization and finalization steps.  Examples of <code>Collector</code>s include:</p>\n\n<ul>\n<li>summing, e.g. <code>Collectors.reducing(0, (x, y) -&gt; x + y)</code></li>\n<li>StringBuilder appending, e.g. <code>Collectors.of(StringBuilder::new, StringBuilder::append, StringBuilder::append, StringBuilder::toString)</code></li>\n</ul>\n    "},{"t":"What are the differences between abstract classes and interfaces in Java 8?","l":"http://stackoverflow.com/questions/22591499/what-are-the-differences-between-abstract-classes-and-interfaces-in-java-8","q":"\n\n<p>In Java there used to be a subtle but important difference between abstract classes and interfaces: <a href=\"http://stackoverflow.com/questions/1913098/what-is-the-difference-between-an-interface-and-abstract-class\">default implementations</a>. Abstract classes could have them, interfaces could not. Java 8 though introduces default implementations for interfaces, meaning this is no longer the critical difference between an interface and an abstract class.</p>\n\n<p>So what is?</p>\n\n<p>As best as I can tell, the only remaining difference (besides perhaps some under the hood efficiency stuff) is that abstract classes follow traditional Java single-inheritance, whereas interfaces can have multiple-inheritance (or multiple-implementation if you will). This leads me to another question - </p>\n\n<p>How do the new Java 8 interfaces avoid the <a href=\"http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\">diamond Problem</a>?</p>\n    ","a":"\n<p>Interfaces cannot have state associated with them.</p>\n\n<p>Abstract classes can have state associated with them.</p>\n\n<p>Furthermore, default methods in interfaces need not be implemented. So in this way, it will not break already existing code, as while the interface does receive an update, the implementing class does not need to implement it.<br>\nAs a result you may get suboptimal code, but if you want to have more optimal code, then your job is to override the default implementation.</p>\n\n<p>And lastly, in case a diamond problem occurs, then the compiler will warn you, and <em>you</em> will need to choose which interface you want to implement.</p>\n\n<p>To show more about the diamond problem, consider the following code:</p>\n\n<pre><code>interface A {\n    void method();\n}\n\ninterface B extends A {\n    @Override\n    default void method() {\n        System.out.println(\"B\");\n    }\n}\n\ninterface C extends A { \n    @Override\n    default void method() {\n        System.out.println(\"C\");\n    }\n}\n\ninterface D extends B, C {\n\n}\n</code></pre>\n\n<p>Here I get the compiler error on <code>interface D extends B, C</code>, that:</p>\n\n<p><code>interface D inherits unrelated defaults for method() form types B and C</code></p>\n\n<p>The fix is:</p>\n\n<pre><code>interface D extends B, C {\n    @Override\n    default void method() {\n        B.super.method();\n    }\n}\n</code></pre>\n\n<p>In case I wanted to inherit the <code>method()</code> from <code>B</code>.<br>\nThe same holds for if <code>D</code> were a <code>class</code>.</p>\n\n<p>To show even more about the difference between interfaces and abstract classes in Java 8, consider the following <code>Team</code>:</p>\n\n<pre><code>interface Player {\n\n}\n\ninterface Team {\n    void addPlayer(Player player);\n}\n</code></pre>\n\n<p>You can in theory provide a default implementation of <code>addPlayer</code> such that you can add players to for example a list of players.<br>\nBut wait...?<br>\nHow do I store the list of players?<br>\nThe answer is that you cannot do that in an interface, even if you have default implementations available.</p>\n    "},{"t":"_ (underscore) is a reserved keyword","l":"http://stackoverflow.com/questions/23523946/underscore-is-a-reserved-keyword","q":"\n\n<p>I've just replaced <code>s</code> in the following lambda expression by <code>_</code></p>\n\n<pre><code>s-&gt;Integer.parseInt(s)\n</code></pre>\n\n<p>Eclipse compiler says: <code>'_' should not be used as an identifier, since it is a reserved keyword from source level 1.8 on</code>.</p>\n\n<p>I haven't found any explanation in the <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.9\">JLS §3.9</a> Lexical Structure / Keywords.</p>\n    ","a":"\n<p>The place to look is <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.1\">JLS §15.27.1. Lambda Parameters</a></p>\n\n<blockquote>\n  <p><strong>It is a compile-time error if a lambda parameter has the name _ (that is, a single underscore character).</strong></p>\n  \n  <p><sup>The use of the variable name _ in any context is discouraged. Future versions of the Java programming language may reserve this name as a keyword and/or give it special semantics.\n  </sup></p>\n</blockquote>\n\n<p>So the Eclipse message is misleading, especially as the same message is used for both cases, when an error is generated for a lambda parameter or when a warning is generated for any other <code>_</code> identifier.</p>\n    "},{"t":"Why is String.chars() a stream of ints in Java 8?","l":"http://stackoverflow.com/questions/22435833/why-is-string-chars-a-stream-of-ints-in-java-8","q":"\n\n<p>In Java 8, there is a new method <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html#chars--\"><code>String.chars()</code></a> which returns a stream of <code>int</code>s (<code>IntStream</code>) that represent the character codes. I guess many people would expect a stream of <code>char</code>s here instead. What was the motivation to design the API this way?</p>\n    ","a":"\n<p>As others have already mentioned, the design decision behind this was to prevent the explosion of methods and classes.</p>\n\n<p>Still, personally I think this was a very bad decision, and there should, given they do not want to make <code>CharStream</code>, which is reasonable, different methods instead of <code>chars()</code>, I would think of:</p>\n\n<ul>\n<li><code>Stream&lt;Character&gt; chars()</code>, that gives a stream of boxes characters, which will have some light performance penalty.</li>\n<li><code>IntStream unboxedChars()</code>, which would to be used for performance code.</li>\n</ul>\n\n<p><strong>However</strong>, instead of focusing on <em>why</em> it is done this way currently, I think this answer should focus on showing a way to do it with the API that we have gotten with Java 8.</p>\n\n<p>In Java 7 I would have done it like this:</p>\n\n<pre><code>for (int i = 0; i &lt; hello.length(); i++) {\n    System.out.println(hello.charAt(i));\n}\n</code></pre>\n\n<p>And I think a reasonable method to do it in Java 8 is the following:</p>\n\n<pre><code>hello.chars()\n        .mapToObj(i -&gt; (char)i)\n        .forEach(System.out::println);\n</code></pre>\n\n<p>Here I obtain an <code>IntStream</code> and map it to an object via the lambda <code>i -&gt; (char)i</code>, this will automatically box it into a <code>Stream&lt;Character&gt;</code>, and then we can do what we want, and still use method references as a plus.</p>\n\n<p><strong>Be aware</strong> though that you <em>must</em> do <code>mapToObj</code>, if you forget and use <code>map</code>, then nothing will complain, but you will still end up with an <code>IntStream</code>, and you might be left off wondering why it prints the integer values instead of the strings representing the characters.</p>\n\n<p><strong>Other ugly alternatives for Java 8:</strong></p>\n\n<p>By remaining in an <code>IntStream</code> and wanting to print them ultimately, you cannot use method references anymore for printing:</p>\n\n<pre><code>hello.chars()\n        .forEach(i -&gt; System.out.println((char)i));\n</code></pre>\n\n<p>Moreover, using method references to your own method do not work anymore! Consider the following:</p>\n\n<pre><code>private void print(char c) {\n    System.out.println(c);\n}\n</code></pre>\n\n<p>and then</p>\n\n<pre><code>hello.chars()\n        .forEach(this::print);\n</code></pre>\n\n<p>This will give a compile error, as there possibly is a lossy conversion.</p>\n\n<p><strong>Conclusion:</strong></p>\n\n<p>The API was designed this way because of not wanting to add <code>CharStream</code>, I personally think that the method should return a <code>Stream&lt;Character&gt;</code>, and the workaround currently is to use <code>mapToObj(i -&gt; (char)i)</code> on an <code>IntStream</code> to be able to work properly with them.</p>\n    "},{"t":"Explicitly calling a default method in Java","l":"http://stackoverflow.com/questions/19976487/explicitly-calling-a-default-method-in-java","q":"\n\n<p>Java 8 introduces <a href=\"http://cr.openjdk.java.net/~dlsmith/jsr335-0.6.2/H.html\">default methods</a> to provide the ability to extend interfaces without the need to modify existing implementations.</p>\n\n<p>I wonder if it's possible to explicitly invoke the default implementation of a method when that method has been overridden or is not available because of conflicting default implementations in different interfaces.</p>\n\n<pre><code>interface A {\n    default void foo() {\n        System.out.println(\"A.foo\");\n    }\n}\n\nclass B implements A {\n    @Override\n    public void foo() {\n        System.out.println(\"B.foo\");\n    }\n    public void afoo() {\n        // how to invoke A.foo() here?\n    }\n}\n</code></pre>\n\n<p>Considering the code above, how would you call <code>A.foo()</code> from a method of class B?</p>\n    ","a":"\n<p>As per <a href=\"http://zeroturnaround.com/rebellabs/java-8-explained-default-methods/\" rel=\"nofollow\">this article</a> you access default method in interface <code>A</code> using</p>\n\n<pre><code>A.super.foo();\n</code></pre>\n\n<p>This could be used as follows (assuming interfaces <code>A</code> and <code>C</code> both have default methods <code>foo()</code>)</p>\n\n<pre><code>public class ChildClass implements A, C {\n    public void foo() {\n       doSomethingElse();\n       //or manage conflicts between the same method foo() in both A and C\n       A.super.foo();\n    }\n    public void bah() {\n       A.super.foo(); //original foo() from A accessed\n       C.super.foo(); //original foo() from C accessed\n    }\n}\n</code></pre>\n\n<p><code>A</code> and <code>C</code> can both have <code>.foo()</code> methods and the specific default implementation can be chosen or you can use one (or both) as part of your new <code>foo()</code> method. You can also use the same syntax to access the default versions in other methods in your implementing class.</p>\n    "},{"t":"Why there is no BooleanConsumer in Java 8?","l":"http://stackoverflow.com/questions/27698911/why-there-is-no-booleanconsumer-in-java-8","q":"\n\n<p>I'm afraid that this is somewhat a silly question.</p>\n\n<p>Is there anybody can tell me why there is no <code>BooleanConsumer</code> opposite to <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/BooleanSupplier.html\" rel=\"nofollow\"><code>BooleanSupplier</code></a>?</p>\n\n<p>Is there any reason other than \"because simply there isn't\"?</p>\n\n<p>Should I create my own one? Or am I missing something else?</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>public interface BooleanConsumer {\n\n    void accept(boolean value);\n\n    default BooleanConsumer andThen(final BooleanConsumer after) {\n        return v -&gt; {\n            accept(v);\n            after.accept(v);\n        }\n    }\n}\n</code></pre>\n\n<h3>Update</h3>\n\n<p>Where to use? I'm writing a library that uses much of consumers and suppliers. I successfully wrote a line with <code>LongConsumer</code> and I encountered a situation that expecting a consumer accepting a boolean value which is from a method result. Say <code>Files.deleteIfExist</code>? </p>\n    ","a":"\n<p><code>IntConsumer</code> and <code>LongConsumer</code> are needed to avoid the overhead autoboxing every value. It is much more efficent to be working on raw primitives.\nHowever, for Boolean and Byte every possible object is cached so there is little reason to avoid using <code>Consumer&lt;Boolean&gt;</code> or <code>Consumer&lt;Byte&gt;</code></p>\n    "},{"t":"Java 8 Distinct by property","l":"http://stackoverflow.com/questions/23699371/java-8-distinct-by-property","q":"\n\n<p>In Java 8 how can I filter a collection using the <code>Stream</code> API by checking the distinctness of a property of each object?</p>\n\n<p>For example I have a list of <code>Person</code> object and I want to remove people with the same name,</p>\n\n<pre><code>persons.stream().distinct();\n</code></pre>\n\n<p>Will use the default equality check for a <code>Person</code> object, so I need something like,</p>\n\n<pre><code>persons.stream().distinct(p -&gt; p.getName());\n</code></pre>\n\n<p>Unfortunately the <code>distinct()</code> method has no such overload. Without modifying the equality check inside the <code>Person</code> class is it possible to do this succinctly?</p>\n    ","a":"\n<p>I finally figured out a nice way to do this. Consider <code>distinct</code> to be a <em>stateful filter</em>. Write function that returns a predicate that also maintains state about what it's seen previously, and returns whether the given element was seen for the first time:</p>\n\n<pre><code>public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T,Object&gt; keyExtractor) {\n    Map&lt;Object,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();\n    return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;\n}\n</code></pre>\n\n<p>Then you can write:</p>\n\n<pre><code>persons.stream().filter(distinctByKey(p -&gt; p.getName());\n</code></pre>\n\n<p>Note: this is essentially the same as <a href=\"http://stackoverflow.com/a/27872086/1441122\">my answer</a> to this <a href=\"http://stackoverflow.com/questions/27870136/java-lambda-stream-distinct-on-arbitrary-key\">other, similar question</a>.</p>\n    "},{"t":"Lambda expression and method overloading doubts","l":"http://stackoverflow.com/questions/23430854/lambda-expression-and-method-overloading-doubts","q":"\n\n<p>OK, so method overloading is-a-bad-thing™. Now that this has been settled, let's assume I actually <em>want</em> to overload a method like this:</p>\n\n<pre><code>static void run(Consumer&lt;Integer&gt; consumer) {\n    System.out.println(\"consumer\");\n}\n\nstatic void run(Function&lt;Integer, Integer&gt; function) {\n    System.out.println(\"function\");\n}\n</code></pre>\n\n<p>In Java 7, I could call them easily with non-ambiguous anonymous classes as arguments:</p>\n\n<pre><code>run(new Consumer&lt;Integer&gt;() {\n    public void accept(Integer integer) {}\n});\n\nrun(new Function&lt;Integer, Integer&gt;() {\n    public Integer apply(Integer o) { return 1; }\n});\n</code></pre>\n\n<p>Now in Java 8, I'd like to call those methods with lambda expressions of course, and I can!</p>\n\n<pre><code>// Consumer\nrun((Integer i) -&gt; {});\n\n// Function\nrun((Integer i) -&gt; 1);\n</code></pre>\n\n<p>Since the compiler <em>should</em> be able to infer <code>Integer</code>, why don't I leave <code>Integer</code> away, then?</p>\n\n<pre><code>// Consumer\nrun(i -&gt; {});\n\n// Function\nrun(i -&gt; 1);\n</code></pre>\n\n<p>But this doesn't compile. The compiler (javac, jdk1.8.0_05) doesn't like that:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Test.java:63: error: reference to run is ambiguous\n        run(i -&gt; {});\n        ^\n  both method run(Consumer&lt;Integer&gt;) in Test and \n       method run(Function&lt;Integer,Integer&gt;) in Test match\n</code></pre>\n\n<p>To me, intuitively, this doesn't make sense. There is absolutely no ambiguity between a lambda expression that yields a return value (\"value-compatible\") and a lambda expression that yields <code>void</code> (\"void-compatible\"), as set out in the <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27\">JLS §15.27</a>.</p>\n\n<p>But of course, the JLS is deep and complex and we inherit 20 years of backwards compatibility history, and there are new things like:</p>\n\n<blockquote>\n  <p>Certain argument expressions that contain <strong><em>implicitly typed lambda expressions</em></strong> (<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.1\">§15.27.1</a>) or inexact method references (<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.13.1\">§15.13.1</a>) are ignored by the applicability tests, because their meaning cannot be determined until a target type is selected.</p>\n  \n  <p><em><a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2\">from JLS §15.12.2</a></em></p>\n</blockquote>\n\n<p>The above limitation is probably related to the fact that <a href=\"http://openjdk.java.net/jeps/101\">JEP 101</a> wasn't implemented all the way, as can be seen <a href=\"http://blog.jooq.org/2013/11/25/a-lesser-known-java-8-feature-generalized-target-type-inference/\">here</a> and <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2013-July/010531.html\">here</a>.</p>\n\n<h3>Question:</h3>\n\n<p>Who can tell me exactly what parts of the JLS specifies this compile-time ambiguity (or is it a compiler bug)?</p>\n\n<p>Bonus: Why were things decided this way?</p>\n\n<h3>Update:</h3>\n\n<p>With jdk1.8.0_40, the above compiles and works fine</p>\n    ","a":"\n<p>I think you found <a href=\"https://bugs.openjdk.java.net/browse/JDK-8029718\" rel=\"nofollow\">this bug in the compiler: JDK-8029718</a> (<a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=434642\" rel=\"nofollow\">or this similar one in Eclipse: 434642</a>).</p>\n\n<p>Compare to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.1\" rel=\"nofollow\">JLS §15.12.2.1. Identify Potentially Applicable Methods</a>:</p>\n\n<blockquote>\n  <p>…</p>\n  \n  <ul>\n  <li><p>A lambda expression (§15.27) is potentially compatible with a functional interface type (§9.8) if all of the following are true:</p>\n  \n  <ul>\n  <li><p>The arity of the target type's function type is the same as the arity of the lambda expression.</p></li>\n  <li><p>If the target type's function type has a void return, then the lambda body is either a statement expression (§14.8) or a void-compatible block (§15.27.2).</p></li>\n  <li><p>If the target type's function type has a (non-void) return type, then the lambda body is either an expression or a value-compatible block (§15.27.2).</p></li>\n  </ul></li>\n  </ul>\n</blockquote>\n\n<p>Note the clear distinction between “<code>void</code> compatible blocks” and “value-compatible blocks”. While a block might be both in certain cases, the section <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.2\" rel=\"nofollow\">§15.27.2. Lambda Body</a> clearly states that an expression like <code>() -&gt; {}</code> is a “<code>void</code> compatible block”, as it completes normally without returning a value. And it should be obvious that <code>i -&gt; {}</code> is a “<code>void</code> compatible block” too.</p>\n\n<p>And according to the section cited above, the combination of a lambda with a block that is not value-compatible and target type with a (non-<code>void</code>) return type is not a potential candidate for the method overload resolution. So your intuition is right, there should be no ambiguity here.</p>\n\n<p>Examples for ambiguous blocks are</p>\n\n<pre><code>() -&gt; { throw new RuntimeException(); }\n() -&gt; { while (true); }\n</code></pre>\n\n<p>as they don’t complete normally, but this is not the case in your question.</p>\n    "},{"t":"Should I return a Collection or a Stream?","l":"http://stackoverflow.com/questions/24676877/should-i-return-a-collection-or-a-stream","q":"\n\n<p>Suppose I have a method that returns a read-only view into a member list:</p>\n\n<pre><code>class Team\n{\n    private List&lt;Player&gt; players = new ArrayList&lt;&gt;();\n\n    // ...\n\n    public List&lt;Player&gt; getPlayers()\n    {\n        return Collections.unmodifiableList(players);\n    }\n}\n</code></pre>\n\n<p>Further suppose that all the client does is iterate over the list once, immediately. Maybe to put the players into a JList or something. The client does <em>not</em> store a reference to the list for later inspection!</p>\n\n<p>Given this common scenario, should I return a stream instead?</p>\n\n<pre><code>    public Stream&lt;Player&gt; getPlayers()\n    {\n        return players.stream();\n    }\n</code></pre>\n\n<p>Or is returning a stream non-idiomatic in Java? Were streams designed to always be \"terminated\" inside the same expression they were created in?</p>\n    ","a":"\n<p>The answer is, as always, \"it depends\".  It depends on how big the returned collection will be.  It depends on whether the result changes over time, and how important consistency of the returned result is.  And it depends very much on how the user is likely to use the answer.  </p>\n\n<p>First, note that you can always get a Collection from a Stream, and vice versa:</p>\n\n<pre><code>// If API returns Collection, convert with stream()\ngetFoo().stream()...\n\n// If API returns Stream, use collect()\nCollection&lt;T&gt; c = getFooStream().collect(toList());\n</code></pre>\n\n<p>So the question is, which is more useful to your callers.  </p>\n\n<p>If your result might be infinite, there's only one choice: Stream.</p>\n\n<p>If your result might be very large, you probably prefer Stream, since there may not be any value in materializing it all at once, and doing so could create significant heap pressure.</p>\n\n<p>If all the caller is going to do is iterate through it (search, filter, aggregate), you should prefer Stream, since Stream has these built-in already and there's no need to materialize a collection (especially if the user might not process the whole result.)  This is a very common case.  </p>\n\n<p>Even if you know that the user will iterate it multiple times or otherwise keep it around, you still may want to return a Stream instead, for the simple fact that whatever Collection you choose to put it in (e.g., ArrayList) may not be the form they want, and then the caller has to copy it anyway.  if you return a stream, they can do <code>collect(toCollection(factory))</code> and get it in exactly the form they want.</p>\n\n<p>The above \"prefer Stream\" cases mostly derive from the fact that Stream is more flexible; you can late-bind to how you use it without incurring the costs and constraints of materializing it to a Collection.  </p>\n\n<p>The one case where you must return a Collection is when there are strong consistency requirements, and you have to produce a consistent snapshot of a moving target.  Then, you will want put the elements into a collection that will not change.</p>\n\n<p>So I would say that most of the time, Stream is the right answer -- it is more flexible, it doesn't impose usually-unnecessary materialization costs, and can be easily turned into the Collection of your choice if needed.  But sometimes, you may have to return a Collection (say, due to strong consistency requirements), or you may want to return Collection because you know how the user will be using it and know this is the most convenient thing for them.  </p>\n    "},{"t":"Swing rendering appears broken in JDK 1.8, correct in JDK 1.7","l":"http://stackoverflow.com/questions/22737535/swing-rendering-appears-broken-in-jdk-1-8-correct-in-jdk-1-7","q":"\n\n<p>today i installed IntelliJ IDEA (13.1.1 #IC-135.480) and JDK 1.8.0 (x64) and i generated some GUI with the GUI Form designer. </p>\n\n<p>Then I ran the code and realized that something is not alright. </p>\n\n<p>Here is a Screenshot of my GUI:\n<img src=\"http://i.stack.imgur.com/zZwGe.png\" alt=\"Buggy Rendering JDK 1.8.0\"></p>\n\n<p>The rendering of the Font seems to be not OK. Additionally the Button looses its Text, when i move my mouse over it.</p>\n\n<p>So i installed JDK 1.7.0_40 (x64), recompiled the Project and ran it again.</p>\n\n<p>The following Form appears, when i use JDK 1.7:\n<img src=\"http://i.stack.imgur.com/lNXc0.png\" alt=\"Rendering OK JDB 1.7.0_40\"></p>\n\n<p>The Rendering seems to be OK and the Button is also OK.</p>\n\n<p>So I installed the newest Graphics and Chipset drivers and much more, but the problem still exists.\nHave you ever had such problems with Java Swing UIs? Could you help me to fix my problems? \nAny help would be greatly appreciated.</p>\n\n<hr>\n\n<h2>UPDATE:</h2>\n\n<p>I created a small Project with only 1 JTextArea and 1 JButton and i have the same rendering problems.</p>\n\n<p>According to Andrew Thompson i changed the setSize() and I start from EDT. The Example below:</p>\n\n<pre><code>package at.maeh.java.client.simpleTextClient;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class SimpleClient extends JFrame {\n    private JPanel panel1;\n    private JTextArea textArea1 = new JTextArea();\n    private JButton button1 = new JButton();\n\n    public SimpleClient() {\n        super(\"SimpleClient\");\n\n        // Panel\n        panel1 = new JPanel();\n        panel1.setLayout(new FlowLayout());\n\n        // BUtton\n        button1.setText(\"TestButton\");\n\n        // TextArea\n        textArea1.setColumns(40);\n        textArea1.setRows(15);\n\n        // Add Components\n        panel1.add(textArea1);\n        panel1.add(button1);\n\n        // Add to Frame\n        this.getContentPane().add(panel1);\n\n        // pack and set Visible\n        pack();\n        setVisible(true);\n\n        System.out.println(\"Constructor EDT: \" + SwingUtilities.isEventDispatchThread());\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(SimpleClient::new);\n\n        System.out.println(\"Main EDT: \" + SwingUtilities.isEventDispatchThread());\n    }\n}\n</code></pre>\n\n<p>The result is a simple JFrame with the Components in it.</p>\n\n<p><img src=\"http://i.stack.imgur.com/xUSEs.png\" alt=\"SimpleClient -> Screenshot immediately after Start\"></p>\n\n<p>When I write some Text, or moove my mousePointer over the Button the components get rendered like this (Text: testsentence.123; Button-Label: TestButton)</p>\n\n<p><img src=\"http://i.stack.imgur.com/ulOpJ.png\" alt=\"after writing - or mouse over\"></p>\n    ","a":"\n<p>Finally I found the solution for my problem. I had to change the energy control settings of my NVIDIA GeForce 620M to maximum performance. </p>\n    "},{"t":"Can an interface method have a body?","l":"http://stackoverflow.com/questions/22713652/can-an-interface-method-have-a-body","q":"\n\n<p>I know that an interface is like a 100% pure abstract class. So, it can't have method implementation in it. But, I saw a strange code. Can anyone explain it?</p>\n\n<p><strong>Code Snippet:</strong></p>\n\n<pre><code> interface Whoa {\n        public static void doStuff() {\n            System.out.println(\"This is not default implementation\");\n        }\n }\n</code></pre>\n\n<p><strong>EDIT:</strong></p>\n\n<p>My IDE is Intellij Idea 13.1. The project SDK is java 7 &lt;1.7.0_25&gt;. The IDE is not showing any compiler error. But, When I compile the code at command line I am getting the following message. </p>\n\n<blockquote>\n<pre><code>Whoa.java:2: error: modifier static not allowed here\n    public static void doStuff() {\n                       ^\n</code></pre>\n</blockquote>\n    ","a":"\n<p>From <strong>Java 8</strong> you can define static methods in interfaces in addition to default methods. </p>\n\n<ul>\n<li><p>A static method is a method that is associated with the class in which it is defined rather than with any object. Every instance of the class shares its static methods.</p></li>\n<li><p>This makes it easier for you to organize helper methods in your libraries; you can keep static methods specific to an interface in the same interface rather than in a separate class.</p></li>\n<li><p>The following example defines a static method that retrieves a <code>ZoneId</code> object corresponding to a time zone identifier; it uses the system default time zone if there is no <code>ZoneId</code> object corresponding to the given identifier. (As a result, you can simplify the method <code>getZonedDateTime</code>)</p></li>\n</ul>\n\n<p>Here is code :</p>\n\n<pre><code>public interface TimeClient {\n   // ...\n    static public ZoneId getZoneId (String zoneString) {\n        try {\n            return ZoneId.of(zoneString);\n        } catch (DateTimeException e) {\n            System.err.println(\"Invalid time zone: \" + zoneString +\"; using default time zone instead.\");\n            return ZoneId.systemDefault();\n        }\n    }\n\n   default public ZonedDateTime getZonedDateTime(String zoneString) {\n      return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));\n   }    \n}\n</code></pre>\n\n<h2>See also</h2>\n\n<ul>\n<li><p><a href=\"http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html\">Oracle docs for interface methods</a></p></li>\n<li><p>For all interesting things in Java 8 read <a href=\"http://www.techempower.com/blog/2013/03/26/everything-about-java-8/\">Everything about Java 8</a></p></li>\n</ul>\n    "},{"t":"Splitting List into sublists along elements","l":"http://stackoverflow.com/questions/29095967/splitting-list-into-sublists-along-elements","q":"\n\n<p>I have this list (<code>List&lt;String&gt;</code>):</p>\n\n<pre><code>[\"a\", \"b\", null, \"c\", null, \"d\", \"e\"]\n</code></pre>\n\n<p>And I'd like something like this:</p>\n\n<pre><code>[[\"a\", \"b\"], [\"c\"], [\"d\", \"e\"]]\n</code></pre>\n\n<p>In other words I want to split my list in sublists using the <code>null</code> value as separator, in order to obtain a list of lists (<code>List&lt;List&lt;String&gt;&gt;</code>). I'm looking for a Java 8 solution. I've tried with <code>Collectors.partitioningBy</code> but I'm not sure it is what I'm looking for. Thanks!</p>\n    ","a":"\n<p>The only solution I come up with for the moment is by implementing your own custom collector. </p>\n\n<p>Before reading the solution, I want to add a few notes about this. I took this question more as a programming exercise, I'm not sure if it can be done with a parallel stream. </p>\n\n<p>So you have to be aware that it'll <strong>silently break</strong> if the pipeline is run in <strong>parallel</strong>. </p>\n\n<p>This is <strong>not</strong> a desirable behavior and should be <strong>avoided</strong>. This is why I throw an exception in the combiner part (instead of <code>(l1, l2) -&gt; {l1.addAll(l2); return l1;}</code>), as it's used in parallel when combining the two lists, so that you have an exception instead of a wrong result.</p>\n\n<p>Also this is not very efficient due to list copying (although it uses a native method to copy the underlying array).</p>\n\n<p>So here's the collector implementation:</p>\n\n<pre><code>private static Collector&lt;String, List&lt;List&lt;String&gt;&gt;, List&lt;List&lt;String&gt;&gt;&gt; splitBySeparator(Predicate&lt;String&gt; sep) {\n    final List&lt;String&gt; current = new ArrayList&lt;&gt;();\n    return Collector.of(() -&gt; new ArrayList&lt;List&lt;String&gt;&gt;(),\n                        (l, elem) -&gt; {if(sep.test(elem)){l.add(new ArrayList&lt;&gt;(current)); current.clear();} else current.add(elem);},\n                        (l1, l2) -&gt; {throw new RuntimeException(\"Should not run this in parallel\");},\n                        l -&gt; {if(current.size() != 0) l.add(current); return l;});\n}\n</code></pre>\n\n<p>and how to use it:</p>\n\n<pre><code>List&lt;List&lt;String&gt;&gt; ll = list.stream().collect(splitBySeparator(Objects::isNull));\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>[[a, b], [c], [d, e]]\n</code></pre>\n\n<p></p><hr>\nAs the <a href=\"http://stackoverflow.com/a/29098447/1587046\">answer of Joop Eggen is out</a>, it appears that it can be done in parallel (give him credit for that!). With that it reduces the custom collector implementation to:<p></p>\n\n<pre><code>private static Collector&lt;String, List&lt;List&lt;String&gt;&gt;, List&lt;List&lt;String&gt;&gt;&gt; splitBySeparator(Predicate&lt;String&gt; sep) {\n    return Collector.of(() -&gt; new ArrayList&lt;List&lt;String&gt;&gt;(Arrays.asList(new ArrayList&lt;&gt;())),\n                        (l, elem) -&gt; {if(sep.test(elem)){l.add(new ArrayList&lt;&gt;());} else l.get(l.size()-1).add(elem);},\n                        (l1, l2) -&gt; {l1.get(l1.size() - 1).addAll(l2.remove(0)); l1.addAll(l2); return l1;});\n}\n</code></pre>\n\n<p>which let the paragraph about parallelism a bit obsolete, however I let it as it can be a good reminder.</p>\n\n<hr>\n\n<p>Note that the Stream API is not always a substitute. There are tasks that are easier and more suitable using the streams and there are tasks that are not. In your case, you could also create a utility method for that:</p>\n\n<pre><code>private static &lt;T&gt; List&lt;List&lt;T&gt;&gt; splitBySeparator(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate) {\n    final List&lt;List&lt;T&gt;&gt; finalList = new ArrayList&lt;&gt;();\n    int fromIndex = 0;\n    int toIndex = 0;\n    for(T elem : list) {\n        if(predicate.test(elem)) {\n            finalList.add(list.subList(fromIndex, toIndex));\n            fromIndex = toIndex + 1;\n        }\n        toIndex++;\n    }\n    if(fromIndex != toIndex) {\n        finalList.add(list.subList(fromIndex, toIndex));\n    }\n    return finalList;\n}\n</code></pre>\n\n<p>and call it like <code>List&lt;List&lt;String&gt;&gt; list = splitBySeparator(originalList, Objects::isNull);</code>. </p>\n\n<p>It can be improved for checking edge-cases. </p>\n    "},{"t":"Why are new java.util.Arrays methods in Java 8 not overloaded for all the primitive types?","l":"http://stackoverflow.com/questions/22918847/why-are-new-java-util-arrays-methods-in-java-8-not-overloaded-for-all-the-primit","q":"\n\n<p>I'm reviewing the API changes for Java 8 and I noticed that the new methods in <code>java.util.Arrays</code> are not overloaded for all primitives. The methods I noticed are:</p>\n\n<ul>\n<li><a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#parallelSetAll-T:A-java.util.function.IntFunction-\">parallelSetAll</a></li>\n<li><a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#parallelPrefix-T:A-java.util.function.BinaryOperator-\">parallelPrefix</a></li>\n<li><a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#spliterator-T:A-\">spliterator</a></li>\n<li><a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#stream-T:A-\">stream</a></li>\n</ul>\n\n<p>Currently these new methods only handle <code>int</code>, <code>long</code>, and <code>double</code> primitives. </p>\n\n<p><code>int</code>, <code>long</code>, and <code>double</code> are probably the most widely used primitives so it makes sense that if they had to limit the API that they would choose those three, but why did they have to limit the API?</p>\n    ","a":"\n<p>To address the questions as whole, and not just this particular scenario, I think we all want to know....</p>\n\n<h1>Why There's Interface Pollution in Java 8</h1>\n\n<p>For instance, in a language like C#, there is a set of predefined function types accepting any number of arguments with an optional return type (<a href=\"http://msdn.microsoft.com/en-us/library/bb534960%28v=vs.110%29.aspx\">Func</a> and <a href=\"http://msdn.microsoft.com/en-us/library/018hxwa8%28v=vs.110%29.aspx\">Action</a> each one going up to 16 parameters of different types <code>T1</code>, <code>T2</code>, <code>T3</code>, ..., <code>T16</code>), but in the JDK 8 what we have is a set of different functional interfaces, with <em>different</em> names and <em>different method</em> names, and whose abstract methods represent a subset of well known <a href=\"http://en.wikipedia.org/wiki/Arity\">function arities</a> (i.e. nullary, unary, binary, ternary, etc). And then we have an explosion of cases dealing with primitive types, and there are even other scenarios causing explosion of more functional interfaces.</p>\n\n<h2> The Type Erasure Issue</h2>\n\n<p>So, in a way, both languages suffer from some form of interface pollution (or delegate pollution in C#). The only difference is that in C# they all have the same name. In Java, unfortunately, due to <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6\">type erasure</a>, there is no difference between <code>Function&lt;T1,T2&gt;</code> and <code>Function&lt;T1,T2,T3&gt;</code> or <code>Function&lt;T1,T2,T3,...Tn&gt;</code>, so evidently, we couldn't simply name them all the same way and we had to come up with creative names for all possible types of function combinations.</p>\n\n<p>Don't think the expert group did not struggle with this problem. In the words of Brian Goetz in the <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2011-August/003877.html\">lambda mailing list</a>:</p>\n\n<blockquote>\n  <p>[...] As a single example, let's take function types.  The lambda\n  strawman offered at devoxx had function types.  I insisted we remove\n  them, and this made me unpopular.  But my objection to function types\n  was not that I don't like function types -- I love function types --\n  but that function types fought badly with an existing aspect of the\n  Java type system, erasure.  Erased function types are the worst of\n  both worlds. So we removed this from the design.</p>\n  \n  <p>But I am unwilling to say \"Java never will have function types\"\n  (though I recognize that Java may never have function types.)  I\n  believe that in  order to get to function types, we have to first deal\n  with erasure. That may, or may not be possible.  But in a world of\n  reified structural types, function types start to make a lot more\n  sense [...]</p>\n</blockquote>\n\n<p>An advantage of this approach is that we can define our own interface types with methods accepting as many arguments as we would like, and we could use them to create lambda expressions and method references as we see fit. In other words, we have <em>the power to pollute the world</em> with yet even more new functional interfaces. Also we can create lambda expressions even for interfaces in earlier versions of the JDK or for earlier versions of our own APIs that defined SAM types like these. And so now we have the power to use <code>Runnable</code> and <code>Callable</code> as functional interfaces.</p>\n\n<p>However, these interfaces become more difficult to memorize since they all have different names and methods. </p>\n\n<p>Still, I am one of those wondering why they didn't solve the problem as in Scala, defining interfaces like <code>Function0</code>, <code>Function1</code>, <code>Function2</code>, ..., <code>FunctionN</code>. Perhaps, the only argument I can come up with against that is that they wanted to maximize the possibilities of defining lambda expressions for interfaces in earlier versions of the APIs as mentioned before.</p>\n\n<h2>Lack of Value Types Issue</h2>\n\n<p>So, evidently type erasure is one driving force here. But if you are one of those wondering why we also need all these additional functional interfaces with similar names and method signatures and whose only difference is the use of a primitive type, then let me remind you that in Java we <em>also</em> <a href=\"http://en.wikipedia.org/wiki/Value_type\">lack of value types</a> like those in a language like C#. This means that the generic types used in our generic classes can only be reference types, and not primitive types. </p>\n\n<p>In other words, we can't do this:</p>\n\n<pre><code>List&lt;int&gt; numbers = asList(1,2,3,4,5);\n</code></pre>\n\n<p>But we can indeed do this:</p>\n\n<pre><code>List&lt;Integer&gt; numbers = asList(1,2,3,4,5);\n</code></pre>\n\n<p>The second example, though, incurs in the cost of boxing and unboxing of the wrapped objects back and forth from/to primitive types. This can become really expensive in operations dealing with collections of primitive values. So, the expert group decided to create this <em>explosion of interfaces</em> to deal with the different scenarios. To make things \"less worse\" they decided to only deal with three basic types: int, long and double.</p>\n\n<p>Quoting the words of Brian Goetz in the <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-November/006750.html\">lambda mailing list</a>:</p>\n\n<blockquote>\n  <p>[...] More generally: the philosophy behind having specialized\n  primitive streams (e.g., IntStream) is fraught with nasty tradeoffs.\n  On the one hand, it's lots of ugly code duplication, interface\n  pollution, etc. On the other hand, any kind of arithmetic on boxed ops\n  sucks, and having no story for reducing over ints would be terrible.\n  So we're in a tough corner, and we're trying to not make it worse.</p>\n  \n  <p>Trick #1 for not making it worse is: we're not doing all eight\n  primitive types. We're doing int, long, and double; all the others\n  could be simulated by these. Arguably we could get rid of int too, but\n  we don't think most Java developers are ready for that. Yes, there\n  will be calls for Character, and the answer is \"stick it in an int.\"\n  (Each specialization is projected to ~100K to the JRE footprint.)</p>\n  \n  <p>Trick #2 is: we're using primitive streams to expose things that are\n  best done in the primitive domain (sorting, reduction) but not trying\n  to duplicate everything you can do in the boxed domain. For example,\n  there's no IntStream.into(), as Aleksey points out. (If there were,\n  the next question(s) would be \"Where is IntCollection? IntArrayList?\n  IntConcurrentSkipListMap?) The intention is many streams may start as\n  reference streams and end up as primitive streams, but not vice versa.\n  That's OK, and that reduces the number of conversions needed (e.g., no\n  overload of map for int -&gt; T, no specialization of Function for int\n  -&gt; T, etc.) [...]</p>\n</blockquote>\n\n<p>We can see that this was a difficult decision for the expert group. I think few would agree that this is cool, and most of us would most likely agree it was necessary.</p>\n\n<h2>The Checked Exceptions Issue</h2>\n\n<p>There was a third driving force that <em>could have made things even worse</em>, and it is the fact that Java supports two type of exceptions: checked and unchecked. The compiler requires that we handle or explicitly declare checked exceptions, but it requires nothing for unchecked ones. So, this creates an interesting problem, because the method signatures of most of the functional interfaces do not declare to throw any exceptions. So, for instance, this is not possible:</p>\n\n<pre><code>Writer out = new StringWriter();\nConsumer&lt;String&gt; printer = s -&gt; out.write(s); //oops! compiler error\n</code></pre>\n\n<p>It cannot be done because the <code>write</code> operation throws a checked exception (i.e. <code>IOException</code>) but the signature of the <code>Consumer</code> method does not declare it throws any exception at all. So, the only solution to this problem would have been to create even more interfaces, some declaring exceptions and some not (or come up with yet another mechanism at the language level for <a href=\"https://blogs.oracle.com/briangoetz/entry/exception_transparency_in_java\">exception transparency</a>. Again, to make things \"less worse\" the expert group decided to do nothing in this case.</p>\n\n<p>In the words of Brian Goetz in the <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2013-January/007662.html\">lambda mailing list</a>:</p>\n\n<blockquote>\n  <p>[...] Yes, you'd have to provide your own exceptional SAMs.  But then\n  lambda conversion would work fine with them.</p>\n  \n  <p>The EG discussed additional language and library support for this\n  problem, and in the end felt that this was a bad cost/benefit\n  tradeoff.</p>\n  \n  <p>Library-based solutions cause a 2x explosion in SAM types (exceptional\n  vs not), which interact badly with existing combinatorial explosions\n  for primitive specialization.</p>\n  \n  <p>The available language-based solutions were losers from a\n  complexity/value tradeoff.  Though there are some alternative\n  solutions we are going to continue to explore -- though clearly not\n  for 8 and probably not for 9 either.</p>\n  \n  <p>In the meantime, you have the tools to do what you want.  I get that\n  you prefer we provide that last mile for you (and, secondarily, your\n  request is really a thinly-veiled request for \"why don't you just give\n  up on checked exceptions already\"), but I think the current state lets\n  you get your job done. [...]</p>\n</blockquote>\n\n<p>So, it's up to us, the developers, to craft <em>yet even more interface explosions</em> to deal with these in a case-by-case basis:</p>\n\n<pre><code>interface IOConsumer&lt;T&gt; {\n   void accept(T t) throws IOException;\n}\n\nstatic&lt;T&gt; Consumer&lt;T&gt; exceptionWrappingBlock(IOConsumer&lt;T&gt; b) {\n   return e -&gt; {\n    try { b.accept(e); }\n    catch (Exception ex) { throw new RuntimeException(ex); }\n   };\n}\n</code></pre>\n\n<p>In order to do:</p>\n\n<pre><code>Writer out = new StringWriter();\nConsumer&lt;String&gt; printer = exceptionWrappingBlock(s -&gt; out.write(s));\n</code></pre>\n\n<p>Probably, in the future (maybe JDK 9) when we get <a href=\"http://openjdk.java.net/jeps/169\">Support for Value Types in Java</a> and Reification, we will be able to get rid of (or at least no longer need to use anymore) some of these multiple interfaces.</p>\n\n<p>In summary, we can see that the expert group struggled with several design issues. The need, requirement or constraint to keep backwards compatibility made things difficult, then we have other important conditions like the lack of value types, type erasure and checked exceptions. If Java had the first and lacked of the other two the design of JDK 8 would probably have been different. So, we all must understand that these were difficult problems with lots of tradeoffs and the EG had to draw a line somewhere and make a decisions.</p>\n    "},{"t":"Is `1/0` a constant expression in Java?","l":"http://stackoverflow.com/questions/31206740/is-1-0-a-constant-expression-in-java","q":"\n\n<p>As far as I understand the Java 8 <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.28\">JLS</a> the expression <code>(1/0)</code> is considered a constant expression, but when I try to compile the following program with OpenJDK 8 I get an error</p>\n\n<pre><code>public class Switch {\n    public static void main(String[] args) {\n        switch(42) {\n            case (1/0):\n                return;\n            default:\n                return;\n        }\n    }\n}\n</code></pre>\n\n<p>The error says <code>(1/0)</code> isn't a constant expression</p>\n\n<pre><code>Switch.java:4: error: constant expression required\n            case (1/0):\n                 ^\n1 error\n</code></pre>\n\n<p>Am I missing something? Or is it a bug in OpenJDK 8?</p>\n    ","a":"\n<p>The compiler is doing constant folding (precomputing trivial literal expressions). This is a case where the expression \"completes abruptly\", to use the JLS verbiage, disqualifying it from meeting the definition of \"constant expression\". So it's not a bug, it's consistent with the JLS.</p>\n\n<p>And yes, the expression doesn't evaluate to a value either (warning the user trying to do something like this that the result will not be a constant expression), but the compiler doesn't know that until it tries. Not evaluating to a value and completing abruptly would seem to go hand-in-hand.</p>\n\n<p>Adding a variable declaration like</p>\n\n<pre><code>int x = 1 / 0;\n</code></pre>\n\n<p>doesn't cause a compiler error, it's the switch that forces the expression to be evaluated at compile time.</p>\n\n<p>By the way I checked that this happens for version 7 of the Oracle and IBM JDKs too, it's not OpenJDK or JDK8 specific.</p>\n    "},{"t":"Java 8: Mandatory checked exceptions handling in lambda expressions. Why mandatory, not optional?","l":"http://stackoverflow.com/questions/14039995/java-8-mandatory-checked-exceptions-handling-in-lambda-expressions-why-mandato","q":"\n\n<p>I'm playing with the new lambda features in Java 8, and found that the practices offered by Java 8 are really useful. However, I'm wondering is there a <em>good</em> way to make a work-around for the following scenario. Suppose you have an object pool wrapper that requires some kind of a factory to fill the object pool, for example (using <code>java.lang.functions.Factory</code>):</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {\n\n    public ConnectionPool(int maxConnections, String url) {\n        super(new Factory&lt;Connection&gt;() {\n            @Override\n            public Connection make() {\n                try {\n                    return DriverManager.getConnection(url);\n                } catch ( SQLException ex ) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }, maxConnections);\n    }\n\n}\n</code></pre>\n\n<p>After transforming the functional interface into lambda expression, the code above becomes like that:</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {\n\n    public ConnectionPool(int maxConnections, String url) {\n        super(() -&gt; {\n            try {\n                return DriverManager.getConnection(url);\n            } catch ( SQLException ex ) {\n                throw new RuntimeException(ex);\n            }\n        }, maxConnections);\n    }\n\n}\n</code></pre>\n\n<p>Not so bad indeed, but the checked exception <code>java.sql.SQLException</code> requires a <code>try</code>/<code>catch</code> block inside the lambda. At my company we use two interfaces for long time:</p>\n\n<ul>\n<li><code>IOut&lt;T&gt;</code> that is an equivalent to <code>java.lang.functions.Factory</code>;</li>\n<li>and a special interface for the cases that usually require checked exceptions propagation: <code>interface IUnsafeOut&lt;T, E extends Throwable&gt; { T out() throws E; }</code>.</li>\n</ul>\n\n<p>Both <code>IOut&lt;T&gt;</code> and <code>IUnsafeOut&lt;T&gt;</code> are supposed to be removed during migration to Java 8, however there is no exact match for <code>IUnsafeOut&lt;T, E&gt;</code>. If the lambda expressions could deal with checked exceptions like they were unchecked, it could be possible to use simply like the following in the constructor above:</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>super(() -&gt; DriverManager.getConnection(url), maxConnections);\n</code></pre>\n\n<p>That looks much cleaner. I see that I can rewrite the <code>ObjectPool</code> super class to accept our <code>IUnsafeOut&lt;T&gt;</code>, but as far as I know, Java 8 is not finished yet, so could be there some changes like:</p>\n\n<ul>\n<li>implementing something similar to <code>IUnsafeOut&lt;T, E&gt;</code>? (to be honest, I consider that dirty - the subject must choose what to accept: either <code>Factory</code> or \"unsafe factory\" that cannot have compatible method signatures)</li>\n<li>simply ignoring checked exceptions in lambdas, so no need in <code>IUnsafeOut&lt;T, E&gt;</code> surrogates? (why not? e.g. another important change: OpenJDK, that I use, <code>javac</code> now does not require variables and parameters to be declared as <code>final</code> to be captured in an anonymous class [functional interface] or lambda expression)</li>\n</ul>\n\n<p>So the question is generally is: is there a way to bypass checked exceptions in lambdas or is it planned in the future until Java 8 is finally released?</p>\n\n<hr>\n\n<p>Update 1</p>\n\n<p>Hm-m-m, as far as I understand what we currently have, it seems there is no way at the moment, despite the referenced article is dated from 2010: <a href=\"https://blogs.oracle.com/briangoetz/entry/exception_transparency_in_java\">Brian Goetz explains exception transparency in Java</a>. If nothing changed much in Java 8, this could be considered an answer. Also Brian says that <code>interface ExceptionalCallable&lt;V, E extends Exception&gt;</code> (what I mentioned as <code>IUnsafeOut&lt;T, E extends Throwable&gt;</code> out of our code legacy) is pretty much useless, and I agree with him.</p>\n\n<p>Do I still miss something else?</p>\n    ","a":"\n<p>Not sure I really answer your question, but couldn't you simply use something like that?</p>\n\n<pre><code>public final class SupplierUtils {\n    private SupplierUtils() {\n    }\n\n    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {\n        return () -&gt; {\n            try {\n                return callable.call();\n            }\n            catch (RuntimeException e) {\n                throw e;\n            }\n            catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        };\n    }\n}\n\npublic class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {\n\n    public JdbcConnectionPool(int maxConnections, String url) {\n        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);\n    }\n}\n</code></pre>\n    "},{"t":"Java 8 Unsafe: xxxFence() instructions","l":"http://stackoverflow.com/questions/23603304/java-8-unsafe-xxxfence-instructions","q":"\n\n<p>In Java 8 three memory barrier instructions were added to <code>Unsafe</code> class (<a href=\"http://openjdk.java.net/jeps/171\">source</a>):</p>\n\n<pre><code>/**\n * Ensures lack of reordering of loads before the fence\n * with loads or stores after the fence.\n */\nvoid loadFence();\n\n/**\n * Ensures lack of reordering of stores before the fence\n * with loads or stores after the fence.\n */\nvoid storeFence();\n\n/**\n * Ensures lack of reordering of loads or stores before the fence\n * with loads or stores after the fence.\n */\nvoid fullFence();\n</code></pre>\n\n<p>If we define memory barrier with the following way (which I consider more or less easy to understand):</p>\n\n<blockquote>\n  <p>Consider X and Y to be operation types/classes that are subject for reordering,</p>\n  \n  <p><strong><code>X_YFence()</code> is a memory barrier instruction that ensures that all operations of type X before the barrier completed before any operation of type Y after the barrier is started.</strong></p>\n</blockquote>\n\n<p>We can now \"map\" barrier names from <code>Unsafe</code> to this terminology:</p>\n\n<ul>\n<li><code>loadFence()</code> becomes <code>load_loadstoreFence()</code>;</li>\n<li><code>storeFence()</code> becomes <code>store_loadStoreFence()</code>;</li>\n<li><code>fullFence()</code> becomes <code>loadstore_loadstoreFence()</code>;</li>\n</ul>\n\n<p>Finally, <strong>my question is</strong> - why don't we have <code>load_storeFence()</code>, <code>store_loadFence()</code>, <code>store_storeFence()</code> and <code>load_loadFence()</code>?</p>\n\n<p>My guess would be - they are not really neccesary, but I do not understand why at the moment. So, I'd like to know reasons for not adding them. Guesses about that are welcome too (hope this doesn't cause this question to be offtopic as opinion-based, though).</p>\n\n<p>Thanks in advance.</p>\n    ","a":"\n<h2>Summary</h2>\n\n<p>CPU cores have special memory ordering buffers to assist them with out-of-order execution. These can (and are) typically separate for loading and storing: LOBs for load-order buffers and SOBs for store-order buffers.</p>\n\n<p>The fencing operations chosen for the Unsafe API are were selected based on the following <em>assumption</em>: underlying processors will have separate load-order buffers (for reordering loads), store-order buffers (for reordering stores).</p>\n\n<p>Therefore, based on this assumption, from a software point of view, you can request one of three things from the CPU:</p>\n\n<ol>\n<li>Empty the LOBs (loadFence): means that no other instructions will start executing on this core, until ALL entries the LOBs have been processed. In x86 this is an LFENCE. </li>\n<li>Empty the SOBs (storeFence): means that no other instructions will start executing on this core, until ALL entries in the SOBs have been processed. In x86 this is an SFENCE. </li>\n<li>Empty both LOBs and SOBs(fullFence): means both of the above. In x86 this is an MFENCE.</li>\n</ol>\n\n<p>In reality, each specific processor architecture provides different memory ordering guarantees, which may be more stringent, or more flexible than the above. For example, SPARC architecture can reorder load-store and store-load sequences, whereas x86 will not do that. Furthermore, architectures exist where LOBs and SOBs cannot be controlled individually (i.e. only full-fence is possible). In both cases however:</p>\n\n<ul>\n<li><p>when the architecture is more flexible, the API simply does not provide access to the \"laxer\" sequencing combinations as a matter of choise</p></li>\n<li><p>when the architecture is more stringent, the API simply implements the more stringent sequencing guarantee in all cases (e.g. all 3 calls actually and up being implemented as a full fence)</p></li>\n</ul>\n\n<p>The reason for the particular API choices is explained in the JEP as per the answer assylias provides which is 100% on-the-spot. If you know about memory ordering and cache coherence, assylias' answer should suffice. I think the fact that they match the standardized instruction in the C++ API was a major factor (simplifies JVM implementation a lot): <a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\">http://en.cppreference.com/w/cpp/atomic/memory_order</a> In all likelihood, actual implementation will call into the respective C++ API instead of using some special instruction.</p>\n\n<p>Below I have a detailed explanation with x86-based examples, which will provide all the context necessary to understand these things. In fact, the demarcated (section below answers another question: \"Can you provide basic examples of how memory fences work to control cache coherence in the x86 architecture?\"</p>\n\n<p>The reason for this is that I myself (coming from a software developer and not hardware designer) had trouble understanding what memory reordering is, until I learned specific examples of how cache coherence actually works in x86. This provides invaluable context for discussing memory fences in general (for other architectures as well). At the end I discuss SPARC a bit using the knowledge gained from the x86 examples</p>\n\n<p>The reference [1] is an even more detailed explanation and has a separate section for discussing each of: x86, SPARC, ARM and PowerPC, so it is an excellent read if you are interested in more details.</p>\n\n<hr>\n\n<h2>x86 architecture example</h2>\n\n<p>x86 provides 3 types of fencing instructions: LFENCE (load fence), SFENCE (store fence) and MFENCE (load-store fence), so it maps 100% to the Java API.</p>\n\n<p>This is because x86 has separate load-order buffers (LOBs) and store-order buffers (SOBs), so indeed LFENCE/SFENCE instructions apply to the respective buffer, whereas MFENCE applies to both.</p>\n\n<p>SOBs are used to store an outgoing value (from processor to cache system) while the cache coherence protocol works to acquire permission to write to the cache line. LOBs are used to store invalidation requests so that invalidation can execute asynchronously (reduces stalling on the receiving side in the hope that the code executing there will not actually need that value).</p>\n\n<h2>Out-of-order stores and SFENCE</h2>\n\n<p>Suppose you have a dual processor system with its two CPUs, 0 and 1, executing the routines below. Consider the case where the cache line holding <code>failure</code> is initially owned by CPU 1, whereas the cache line holding <code>shutdown</code> is initially owned by CPU 0.</p>\n\n<pre><code>// CPU 0:\nvoid shutDownWithFailure(void)\n{\n  failure = 1; // must use SOB as this is owned by CPU 1\n  shutdown = 1; // can execute immediately as it is owned be CPU 0\n}\n// CPU1:\nvoid workLoop(void)\n{\n  while (shutdown == 0) { ... }\n  if (failure) { ...}\n}\n</code></pre>\n\n<p>In the absence of a store fence, CPU 0 may signal a shutdown due to failure, but CPU 1 will exit the loop and NOT got into the failure-handling if block.</p>\n\n<p>This is because CPU0 will write the value 1 for <code>failure</code> to a store-order buffer, also sending out a cache coherence message to acquire exclusive access to the cache line. It will then proceed to the next instruction (while waiting for exclusive access) and update the <code>shutdown</code> flag immediately (this cache line is owned exclusively by CPU0 already so no need to negotiate with other cores). Finally, when it later receives an invalidation confirmation message from CPU1 (regarding <code>failure</code>) it will proceed to process the SOB for <code>failure</code> and write the value to the cache (but the order is by now reversed). </p>\n\n<p>Inserting a storeFence() will fix things:</p>\n\n<pre><code>// CPU 0:\nvoid shutDownWithFailure(void)\n{\n  failure = 1; // must use SOB as this is owned by CPU 1\n  SFENCE // next instruction will execute after all SOBs are processed\n  shutdown = 1; // can execute immediately as it is owned be CPU 0\n}\n// CPU1:\nvoid workLoop(void)\n{\n  while (shutdown == 0) { ... }\n  if (failure) { ...}\n}\n</code></pre>\n\n<p>A final aspect that deserves mention is that x86 has store-forwarding: when a CPU writes a value which gets stuck in an SOB (due to cache coherence), it may subsequently attempt to execute a load instruction for the same address BEFORE the SOB is processed and delivered to the cache. CPUs will therefore consult the SOBs PRIOR to accessing the cache, so the value retrieved in this case is the last-written value from the SOB. <em>this means that stores from THIS core can never be reordered with subsequent loads from THIS core no matter what</em>.</p>\n\n<h2>Out-of-order loads and LFENCE</h2>\n\n<p>Now, assume you have the store fence in place and are happy that <code>shutdown</code> cannot overtake <code>failure</code> on its way to CPU 1, and focus on the other side. Even in the presence of the store fence, there are scenarios where the wrong thing happens. Consider the case where <code>failure</code> is in both caches (shared) whereas <code>shutdown</code> is only present in and owned exclusively by the cache of CPU0. Bad things can happen as follows:</p>\n\n<ol>\n<li>CPU0 writes 1 to <code>failure</code>; <em>It also sends a message to CPU1 to invalidate its copy of the shared cache line as part of the cache coherence protocol</em>.</li>\n<li>CPU0 executes the SFENCE and stalls, waiting for the SOB used for <code>failure</code> to commit.</li>\n<li>CPU1 checks <code>shutdown</code> due to the while loop and (realizing it is missing the value) sends a cache coherence message to read the value.</li>\n<li>CPU1 receives the message from CPU0 in step 1 to invalidate <code>failure</code>, sending an immediate acknowledgement for it. <em>NOTE: this is implemented using the invalidation queue, so in fact it simply enters a note (allocates an entry in its LOB) to later do the invalidation, but does not actually perform it before sending out the acknowledgement.</em></li>\n<li>CPU0 receives the acknowledgement for <code>failure</code> and proceeds past the SFENCE to the next instruction</li>\n<li>CPU0 writes 1 to shutdown without using a SOB, because it already owns the cache line exclusively. <em>no extra message for invalidation is sent as the cache line is exclusive to CPU0</em></li>\n<li>CPU1 receives the <code>shutdown</code> value and commits it to its local cache, proceeding to the next line.</li>\n<li>CPU1 checks the <code>failure</code> value for the if statement, but since the invalidate queue (LOB note) is not yet processed, it uses the value 0 from its local cache (does not enter if block).</li>\n<li>CPU1 processes the invalidate queue and update <code>failure</code> to 1, but it is already too late...</li>\n</ol>\n\n<p>What we refer to as load order buffers, is actaully the queueing of invalidation requests, and the above can be fixed with:</p>\n\n<pre><code>// CPU 0:\nvoid shutDownWithFailure(void)\n{\n  failure = 1; // must use SOB as this is owned by CPU 1\n  SFENCE // next instruction will execute after all SOBs are processed\n  shutdown = 1; // can execute immediately as it is owned be CPU 0\n}\n// CPU1:\nvoid workLoop(void)\n{\n  while (shutdown == 0) { ... }\n  LFENCE // next instruction will execute after all LOBs are processed\n  if (failure) { ...}\n}\n</code></pre>\n\n<h2>Your question on x86</h2>\n\n<p>Now that you know what SOBs/LOBs do, think about the combinations you mentioned:</p>\n\n<pre><code>loadFence() becomes load_loadstoreFence();\n</code></pre>\n\n<p>No, a load fence waits for LOBs to be processed, essentially emptying the invalidation queue. This means that all subsequent loads will see up-to-date data (no re-ordering), as they will  be fetched from the cache sub-system (which is coherent). Stores CANNNOT be reordered with subsequent loads, because they do not go through the LOB. (and furthermore store forwarding takes care of locally-modified cachce lines) From the perspective of THIS particular core (the one executing the load fence), a store that follows the load fence will execute AFTER all registers have the data loaded. There is no way around it.</p>\n\n<pre><code>load_storeFence() becomes ???\n</code></pre>\n\n<p>There is no need for a load_storeFence as it does not make sense. To store something you must calculate it using input. To fetch input you must execute loads. The stores will occur using the data fetched from loads. If you want to make sure you see up-to-date values from all OTHER processors when loading use a loadFence. For loads after the fence store-forwarding takes care of consistent ordering.</p>\n\n<p>All other cases are similar.</p>\n\n<hr>\n\n<h2>SPARC</h2>\n\n<p>SPARC is even more flexible and can reorder stores with subsequent loads (and loads with subsequent stores). I was not as familiar with SPARC, so my <em>GUESS</em> was that there is no store-forwarding (SOBs are not consulted when reloading an address) so \"dirty reads\" are possible. In fact I was wrong: I found the SPARC architecture in [3] and the reality is that store-forwarding is threaded. From section 5.3.4:</p>\n\n<p>All loads check the store buffer (same thread only) for read after write (RAW) hazards. A full RAW occurs when the dword address of the load matches that of a store in the STB and all bytes of the load are valid in the store buffer. A partial RAW occurs when the dword addresses match, but all bytes are not valid in the store buffer. (Ex., a ST (word store) followed by an LDX (dword load) to the same address results in a partial RAW, because the full dword is not in the store buffer entry.)</p>\n\n<p>So, different threads consult different store-order buffers hence the possibility for dirty reads after stores.</p>\n\n<hr>\n\n<h2>References</h2>\n\n<p>[1] Memory Barriers: a Hardware View for Software Hackers, Linux Technology Center, IBM Beaverton\n<a href=\"http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf\">http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf</a></p>\n\n<p>[2] Intel® 64 and IA-32 ArchitecturesSoftware Developer’s Manual, Volume 3A \n<a href=\"http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf\">http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf</a></p>\n\n<p>[3] OpenSPARC T2 Core Microarchitecture Specification <a href=\"http://www.oracle.com/technetwork/systems/opensparc/t2-06-opensparct2-core-microarch-1537749.html\">http://www.oracle.com/technetwork/systems/opensparc/t2-06-opensparct2-core-microarch-1537749.html</a></p>\n    "},{"t":"Which GoF Design pattern will be changed or influenced by the introduction of lambdas in Java8?","l":"http://stackoverflow.com/questions/17012159/which-gof-design-pattern-will-be-changed-or-influenced-by-the-introduction-of-la","q":"\n\n<p>Many claims that the biggest part of the GoF design patterns are just workarounds for the absence of first class functions. Now that Java is about to get lambda expressions, which of those patterns will be influenced by them? Which ones can be dramatically simplified or generalized? And which ones will basically remain the same? Any practical example is welcome.</p>\n    ","a":"\n<p>I think your will see the most changes in Behavioral patterns. </p>\n\n<p><strong>Template Method</strong> - Template methods will be more and more seldomly used, and instead we will see objects pass functions to the AbstractTemplate instead of subclassing the AbstractTemplate. I blogged about this a loooong time ago here: <a href=\"http://hamletdarcy.blogspot.ch/2007/11/groovy-closures-end-of-template-method.html\">http://hamletdarcy.blogspot.ch/2007/11/groovy-closures-end-of-template-method.html</a></p>\n\n<p><strong>Observer Pattern</strong> - Observer becomes simplified because you no longer need to keep a list of observers that get updated on new events, but instead keep a list of functions that need to be called back on new events. So there is no more Observer interface and just function objects. </p>\n\n<p><strong>State/Strategy Pattern</strong> - I group these together because they are structurally equivalent, just different in intent. Strategy usage become much more common because it is easier to implement. You don't need a parent strategy and strategy subclasses, you just need functions. So it is simple to just pass a function as a parameter, which in effect is using the strategy pattern. </p>\n\n<p>Overall, I think any pattern that requires a one-method interface becomes easier to implement. This will have the two effects. 1) We will use these functional patterns more, and 2) we will stop referring to them as patterns but just as \"passing a function\". </p>\n\n<p>You do what you want, but I think \"JavaScript the Good Parts\" gives a pretty nice introduction to leveraging functions in a language. You might pick it up and read it! </p>\n    "},{"t":"Java 8: Formatting lambda with newlines and indentation","l":"http://stackoverflow.com/questions/24649971/java-8-formatting-lambda-with-newlines-and-indentation","q":"\n\n<p>What I would like to achieve with lambda indentation is the following:</p>\n\n<p>Multi-line statement:</p>\n\n<pre><code>String[] ppl = new String[] { \"Karen (F)\", \"Kevin (M)\", \"Lee (M)\", \"Joan (F)\", \"Des (M)\", \"Rick (M)\" };\nList&lt;String&gt; strings = Arrays.stream(ppl)\n                         .filter(\n                             (x) -&gt; \n                             {\n                                 return x.contains(\"(M)\");\n                             }\n                         ).collect(Collectors.toList());\nstrings.stream().forEach(System.out::println);\n</code></pre>\n\n<p>Single-line statement:</p>\n\n<pre><code>List&lt;String&gt; strings = Arrays.stream(ppl)\n                         .map((x) -&gt; x.toUpperCase())\n                         .filter((x) -&gt; x.contains(\"(M)\"))\n                         .collect(Collectors.toList());\n</code></pre>\n\n<p><br><br>\nCurrently, Eclipse is auto-formatting to the following:</p>\n\n<p>Multi-line statement:</p>\n\n<pre><code>String[] ppl = new String[] { \"Karen (F)\", \"Kevin (M)\", \"Lee (M)\", \"Joan (F)\", \"Des (M)\", \"Rick (M)\" };\nList&lt;String&gt; strings = Arrays.stream(ppl).filter((x) -&gt;\n{\n    return x.contains(\"(M)\");\n}).collect(Collectors.toList());\nstrings.stream().forEach(System.out::println);\n</code></pre>\n\n<p>Single-line statement:</p>\n\n<pre><code>String[] ppl = new String[] { \"Karen (F)\", \"Kevin (M)\", \"Lee (M)\", \"Joan (F)\", \"Des(M)\", \"Rick (M)\" };\nList&lt;String&gt; strings = Arrays.stream(ppl).map((x) -&gt; x.toUpperCase())\n        .filter((x) -&gt; x.contains(\"(M)\")).collect(Collectors.toList());\nstrings.stream().forEach(System.out::println);\n</code></pre>\n\n<p>And I find this really messy, because of how the <code>collect</code> call is directly underneath the <code>return</code> and there's no space inbetween at all. I would prefer it if I could start the lambda in a new line indented, and so that the <code>.filter(</code> call would be right above the <code>.collect(</code> call. However, the only thing that can be customized with standard Java-8 Eclipse Formatter is the brace at the start of the lambda body, but nothing for the <code>()</code> brackets beforehand, nor the indentation. </p>\n\n<p>And in the case of single-line calls, it just uses the basic line-wrap and makes it be a chained mess. I don't think I need to explain why this is hard to decrypt afterwards.</p>\n\n<p>Is there any way to somehow customize the formatting more and achieve the first formatting type in Eclipse? (Or, optionally, in another IDE like IntelliJ IDEA.)</p>\n\n<p><br><br>\nEDIT: The closest I could get was with IntelliJ IDEA 13 Community Edition (read: free edition :P) which was the following (defined by continuous indentation which in this case is 8):</p>\n\n<pre><code>public static void main(String[] args)\n{\n    int[] x = new int[] {1, 2, 3, 4, 5, 6, 7};\n    int sum = Arrays.stream(x)\n            .map((n) -&gt; n * 5)\n            .filter((n) -&gt; {\n                System.out.println(\"Filtering: \" + n);\n                return n % 3 != 0;\n            })\n            .reduce(0, Integer::sum);\n\n    List&lt;Integer&gt; list = Arrays.stream(x)\n            .filter((n) -&gt; n % 2 == 0)\n            .map((n) -&gt; n * 4)\n            .boxed()\n            .collect(Collectors.toList());\n    list.forEach(System.out::println);\n    System.out.println(sum);    \n</code></pre>\n\n<p>It also allows to \"align\" the chained method invocation like this:</p>\n\n<pre><code>    int sum = Arrays.stream(x)\n                    .map((n) -&gt; n * 5)\n                    .filter((n) -&gt; {\n                        System.out.println(\"Filtering: \" + n);\n                        return n % 3 != 0;\n                    })\n                    .reduce(0, Integer::sum);\n\n\n    List&lt;Integer&gt; list = Arrays.stream(x)\n                               .filter((n) -&gt; n % 2 == 0)\n                               .map((n) -&gt; n * 4)\n                               .boxed()\n                               .collect(Collectors.toList());\n    list.forEach(System.out::println);\n    System.out.println(sum);\n}\n</code></pre>\n\n<p>I personally find that while it makes more sense, the second version pushes it far too away, so I prefer the first one.</p>\n\n<p>The setup responsible for the first setup is the following:</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;code_scheme name=\"Zhuinden\"&gt;\n  &lt;option name=\"JD_ALIGN_PARAM_COMMENTS\" value=\"false\" /&gt;\n  &lt;option name=\"JD_ALIGN_EXCEPTION_COMMENTS\" value=\"false\" /&gt;\n  &lt;option name=\"JD_ADD_BLANK_AFTER_PARM_COMMENTS\" value=\"true\" /&gt;\n  &lt;option name=\"JD_ADD_BLANK_AFTER_RETURN\" value=\"true\" /&gt;\n  &lt;option name=\"JD_P_AT_EMPTY_LINES\" value=\"false\" /&gt;\n  &lt;option name=\"JD_PARAM_DESCRIPTION_ON_NEW_LINE\" value=\"true\" /&gt;\n  &lt;option name=\"WRAP_COMMENTS\" value=\"true\" /&gt;\n  &lt;codeStyleSettings language=\"JAVA\"&gt;\n    &lt;option name=\"KEEP_FIRST_COLUMN_COMMENT\" value=\"false\" /&gt;\n    &lt;option name=\"BRACE_STYLE\" value=\"2\" /&gt;\n    &lt;option name=\"CLASS_BRACE_STYLE\" value=\"2\" /&gt;\n    &lt;option name=\"METHOD_BRACE_STYLE\" value=\"2\" /&gt;\n    &lt;option name=\"ELSE_ON_NEW_LINE\" value=\"true\" /&gt;\n    &lt;option name=\"WHILE_ON_NEW_LINE\" value=\"true\" /&gt;\n    &lt;option name=\"CATCH_ON_NEW_LINE\" value=\"true\" /&gt;\n    &lt;option name=\"FINALLY_ON_NEW_LINE\" value=\"true\" /&gt;\n    &lt;option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" /&gt;\n    &lt;option name=\"SPACE_WITHIN_BRACES\" value=\"true\" /&gt;\n    &lt;option name=\"SPACE_BEFORE_IF_PARENTHESES\" value=\"false\" /&gt;\n    &lt;option name=\"SPACE_BEFORE_WHILE_PARENTHESES\" value=\"false\" /&gt;\n    &lt;option name=\"SPACE_BEFORE_FOR_PARENTHESES\" value=\"false\" /&gt;\n    &lt;option name=\"SPACE_BEFORE_TRY_PARENTHESES\" value=\"false\" /&gt;\n    &lt;option name=\"SPACE_BEFORE_CATCH_PARENTHESES\" value=\"false\" /&gt;\n    &lt;option name=\"SPACE_BEFORE_SWITCH_PARENTHESES\" value=\"false\" /&gt;\n    &lt;option name=\"SPACE_BEFORE_SYNCHRONIZED_PARENTHESES\" value=\"false\" /&gt;\n    &lt;option name=\"SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE\" value=\"true\" /&gt;\n    &lt;option name=\"METHOD_PARAMETERS_WRAP\" value=\"1\" /&gt;\n    &lt;option name=\"EXTENDS_LIST_WRAP\" value=\"1\" /&gt;\n    &lt;option name=\"THROWS_LIST_WRAP\" value=\"1\" /&gt;\n    &lt;option name=\"EXTENDS_KEYWORD_WRAP\" value=\"1\" /&gt;\n    &lt;option name=\"THROWS_KEYWORD_WRAP\" value=\"1\" /&gt;\n    &lt;option name=\"METHOD_CALL_CHAIN_WRAP\" value=\"2\" /&gt;\n    &lt;option name=\"BINARY_OPERATION_WRAP\" value=\"1\" /&gt;\n    &lt;option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" /&gt;\n    &lt;option name=\"ASSIGNMENT_WRAP\" value=\"1\" /&gt;\n    &lt;option name=\"IF_BRACE_FORCE\" value=\"3\" /&gt;\n    &lt;option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" /&gt;\n    &lt;option name=\"WHILE_BRACE_FORCE\" value=\"3\" /&gt;\n    &lt;option name=\"FOR_BRACE_FORCE\" value=\"3\" /&gt;\n    &lt;option name=\"PARAMETER_ANNOTATION_WRAP\" value=\"1\" /&gt;\n    &lt;option name=\"VARIABLE_ANNOTATION_WRAP\" value=\"1\" /&gt;\n    &lt;option name=\"ENUM_CONSTANTS_WRAP\" value=\"2\" /&gt;\n  &lt;/codeStyleSettings&gt;\n&lt;/code_scheme&gt;\n</code></pre>\n\n<p>I tried to make sure everything is reasonable, but I might have messed something up, so it might need minor adjustments.</p>\n\n<p>If you're Hungarian like me and you're using a Hungarian layout, then this keymap might be of use to you, so that you don't end up not being able to use AltGR+F, AltGR+G, AltGR+B, AltGR+N and AltGR+M (which correspond to Ctrl+Alt).</p>\n\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;keymap version=\"1\" name=\"Default copy\" parent=\"$default\"&gt;\n  &lt;action id=\"ExtractMethod\"&gt;\n    &lt;keyboard-shortcut first-keystroke=\"shift control M\" /&gt;\n  &lt;/action&gt;\n  &lt;action id=\"GotoImplementation\"&gt;\n    &lt;mouse-shortcut keystroke=\"control alt button1\" /&gt;\n  &lt;/action&gt;\n  &lt;action id=\"GotoLine\"&gt;\n    &lt;keyboard-shortcut first-keystroke=\"shift control G\" /&gt;\n  &lt;/action&gt;\n  &lt;action id=\"Inline\"&gt;\n    &lt;keyboard-shortcut first-keystroke=\"shift control O\" /&gt;\n  &lt;/action&gt;\n  &lt;action id=\"IntroduceField\"&gt;\n    &lt;keyboard-shortcut first-keystroke=\"shift control D\" /&gt;\n  &lt;/action&gt;\n  &lt;action id=\"Mvc.RunTarget\"&gt;\n    &lt;keyboard-shortcut first-keystroke=\"shift control P\" /&gt;\n  &lt;/action&gt;\n  &lt;action id=\"StructuralSearchPlugin.StructuralReplaceAction\" /&gt;\n  &lt;action id=\"Synchronize\"&gt;\n    &lt;keyboard-shortcut first-keystroke=\"shift control Y\" /&gt;\n  &lt;/action&gt;\n&lt;/keymap&gt;\n</code></pre>\n\n<p>While IntelliJ doesn't seem to provide a way to put the opening brace of the lambda in a new line, otherwise it's a fairly reasonable way of formatting, so I'll mark this as accepted.</p>\n    ","a":"\n<p>Out of the box IntelliJ 13 will probably work for you.</p>\n\n<p>If I write it this way:</p>\n\n<pre><code>// Mulit-Line Statement\nString[] ppl = new String[] { \"Karen (F)\", \"Kevin (M)\", \"Lee (M)\", \"Joan (F)\", \"Des (M)\", \"Rick (M)\" };\nList&lt;String&gt; strings = Arrays.stream(ppl)\n        .filter(\n                (x) -&gt;\n                {\n                    return x.contains(\"(M)\");\n                }\n        ).collect(Collectors.toList());\nstrings.stream().forEach(System.out::println);\n</code></pre>\n\n<p>And then apply the auto formatter (no changes):</p>\n\n<pre><code>// Mulit-Line Statement\nString[] ppl = new String[]{\"Karen (F)\", \"Kevin (M)\", \"Lee (M)\", \"Joan (F)\", \"Des (M)\", \"Rick (M)\"};\nList&lt;String&gt; strings = Arrays.stream(ppl)\n        .filter(\n                (x) -&gt;\n                {\n                    return x.contains(\"(M)\");\n                }\n        ).collect(Collectors.toList());\nstrings.stream().forEach(System.out::println);\n</code></pre>\n\n<p>The same is true for your single line statement. It has been my experience that IntelliJ is more flexible in how its auto formatting is applied. IntelliJ is less likely to remove or add line returns, if you put it there then it assumes you meant to put it there. IntelliJ will happily adjust your tab-space for you.</p>\n\n<hr>\n\n<p>IntelliJ can also be configured to do some of this for you. Under \"settings\" -&gt; \"code style\" -&gt; \"java\", in the \"Wrapping and Braces\" tab you can set \"chain method calls\" to \"wrap always\".</p>\n\n<p>Before Auto-Formatting </p>\n\n<pre><code>// Mulit-Line Statement\nList&lt;String&gt; strings = Arrays.stream(ppl).filter((x) -&gt; { return x.contains(\"(M)\"); }).collect(Collectors.toList());\n\n// Single-Line Statement\nList&lt;String&gt; strings = Arrays.stream(ppl).map((x) -&gt; x.toUpperCase()).filter((x) -&gt; x.contains(\"(M)\")).collect(Collectors.toList());\n</code></pre>\n\n<p>After Auto-Formatting </p>\n\n<pre><code>// Mulit-Line Statement\nList&lt;String&gt; strings = Arrays.stream(ppl)\n        .filter((x) -&gt; {\n            return x.contains(\"(M)\");\n        })\n        .collect(Collectors.toList());\n\n// Single-Line Statement\nList&lt;String&gt; strings = Arrays.stream(ppl)\n        .map((x) -&gt; x.toUpperCase())\n        .filter((x) -&gt; x.contains(\"(M)\"))\n        .collect(Collectors.toList());\n</code></pre>\n    "},{"t":"How can I create a stream from an array?","l":"http://stackoverflow.com/questions/27888429/how-can-i-create-a-stream-from-an-array","q":"\n\n<p>Currently whenever I need to create stream from an array, I do</p>\n\n<pre><code>String[] array = {\"x1\", \"x2\"};\nArrays.asList(array).stream();\n</code></pre>\n\n<p>Is there some direct way to create stream from an array?</p>\n    ","a":"\n<p>You can use Arrays.stream E.g.</p>\n\n<pre><code>Arrays.stream(array);\n</code></pre>\n\n<p>You can also use <code>Stream.of</code> as mentioned by @fge , which looks like</p>\n\n<pre><code>public static&lt;T&gt; Stream&lt;T&gt; of(T... values) {\n    return Arrays.stream(values);\n}\n</code></pre>\n\n<p>But note <code>Stream.of(intArray)</code> will return <code>Stream&lt;int[]&gt;</code> whereas <code>Arrays.stream(intArr)</code> will return <code>IntStream</code> providing you pass an array of type <code>int[]</code>. So in a nutshell for primitives type you can observe the difference between 2 methods E.g.</p>\n\n<pre><code>int[] arr = {1, 2};\nStream&lt;int[]&gt; arr1 = Stream.of(arr);\n\nIntStream stream2 = Arrays.stream(arr); \n</code></pre>\n\n<p>When you pass primitive array to <code>Arrays.stream</code>, the following code is invoked</p>\n\n<pre><code>public static IntStream stream(int[] array) {\n    return stream(array, 0, array.length);\n}\n</code></pre>\n\n<p>and when you pass primitive array to <code>Stream.of</code> the following code is invoked</p>\n\n<pre><code> public static&lt;T&gt; Stream&lt;T&gt; of(T t) {\n     return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false);\n }\n</code></pre>\n\n<p>Hence you get different results.</p>\n\n<p><strong>Updated</strong>: As mentioned by <a href=\"http://stackoverflow.com/users/1441122/stuart-marks\">Stuart Marks</a> comment\nThe subrange overload of <code>Arrays.stream</code> is preferable to using <code>Stream.of(array).skip(n).limit(m)</code> because the former results in a SIZED stream whereas the latter does not. The reason is that <code>limit(m)</code> doesn't know whether the size is m or less than m, whereas <code>Arrays.stream</code> does range checks and knows the exact size of the stream\nYou can read the source code for stream implementation returned by <code>Arrays.stream(array,start,end)</code>  <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ReferencePipeline.java#ReferencePipeline.Head\">here</a>, whereas for stream implementation returned by <code>Stream.of(array).skip().limit()</code> is within <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/SliceOps.java#SliceOps.makeRef%28java.util.stream.AbstractPipeline%2Clong%2Clong%29\">this method</a>.</p>\n    "},{"t":"Adding two Java 8 streams, or an extra element to a stream","l":"http://stackoverflow.com/questions/22740464/adding-two-java-8-streams-or-an-extra-element-to-a-stream","q":"\n\n<p>I can add streams or extra elements, like this:</p>\n\n<pre><code>Stream stream = Stream.concat(stream1, Stream.concat(stream2, Stream.of(element));\n</code></pre>\n\n<p>And I can add new stuff as I go, like this:</p>\n\n<pre><code>Stream stream = Stream.concat(\n                       Stream.concat(\n                              stream1.filter(x -&gt; x!=0), stream2)\n                              .filter(x -&gt; x!=1),\n                                  Stream.of(element))\n                                  .filter(x -&gt; x!=2);\n</code></pre>\n\n<p>But this is ugly, because <code>concat</code> is static. If <code>concat</code> were an instance method, the above examples would be much easier to read:</p>\n\n<pre><code> Stream stream = stream1.concat(stream2).concat(element);\n</code></pre>\n\n<p>And</p>\n\n<pre><code> Stream stream = stream1\n                 .filter(x -&gt; x!=0)\n                 .concat(stream2)\n                 .filter(x -&gt; x!=1)\n                 .concat(element)\n                 .filter(x -&gt; x!=2);\n</code></pre>\n\n<p>My question is:</p>\n\n<p>1) Is there any good reason why <code>concat</code> is static? Or is there some equivalent instance method I'm missing?</p>\n\n<p>2) In any case, is there a better way of doing this?</p>\n    ","a":"\n<p>If you add <em>static imports</em> for <em>Stream.concat</em> and <em>Stream.of</em>, the first example could be written as follows:</p>\n\n<pre><code>Stream&lt;Foo&gt; stream = concat(stream1, concat(stream2, of(element)));\n</code></pre>\n\n<p>It's a bad idea to import <em>static methods</em> with names, that are used for different purposes. So it might be better to create your own <em>static methods</em> with more meaningful names. However, for demonstration I will stick with this name.</p>\n\n<pre><code>public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; lhs, Stream&lt;? extends T&gt; rhs) {\n    return Stream.concat(lhs, rhs);\n}\npublic static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; lhs, T rhs) {\n    return Stream.concat(lhs, Stream.of(rhs));\n}\n</code></pre>\n\n<p>With these to static methods (optionally in combination with static imports), the two examples could be written as follows:</p>\n\n<pre><code>Stream&lt;Foo&gt; stream = concat(stream1, concat(stream2, element));\n\nStream&lt;Foo&gt; stream = concat(\n                         concat(stream1.filter(x -&gt; x!=0), stream2).filter(x -&gt; x!=1),\n                         element)\n                     .filter(x -&gt; x!=2);\n</code></pre>\n\n<p>The code is now significantly shorter. However, I agree that the readability hasn't improved. So I have another solution.</p>\n\n<hr>\n\n<p>In a lot of situations, <em>Collectors</em> can be used to <em>extend</em> the functionality of streams. With the two <em>Collectors</em> at the bottom, the two examples could be written as follows:</p>\n\n<pre><code>Stream&lt;Foo&gt; stream = stream1.collect(concat(stream2)).collect(concat(element));\n\nStream&lt;Foo&gt; stream = stream1\n                     .filter(x -&gt; x!=0)\n                     .collect(concat(stream2))\n                     .filter(x -&gt; x!=1)\n                     .collect(concat(element))\n                     .filter(x -&gt; x!=2);\n</code></pre>\n\n<p>The only difference between your desired syntax and the syntax above is, that you have to replace <em>concat(...)</em> with <em>collect(concat(...))</em>. The two static methods can be implemented as follows (optionally used in combination with static imports):</p>\n\n<pre><code>private static &lt;T,A,R,S&gt; Collector&lt;T,?,S&gt; combine(Collector&lt;T,A,R&gt; collector, Function&lt;? super R, ? extends S&gt; function) {\n    return Collector.of(\n        collector.supplier(),\n        collector.accumulator(),\n        collector.combiner(),\n        collector.finisher().andThen(function));\n}\npublic static &lt;T&gt; Collector&lt;T,?,Stream&lt;T&gt;&gt; concat(Stream&lt;? extends T&gt; other) {\n    return combine(Collectors.toList(),\n        list -&gt; Stream.concat(list.stream(), other));\n}\npublic static &lt;T&gt; Collector&lt;T,?,Stream&lt;T&gt;&gt; concat(T element) {\n    return concat(Stream.of(element));\n}\n</code></pre>\n\n<hr>\n\n<p>Of course there is a drawback with this solution that should be mentioned. <em>collect</em> is a final operation that consumes all elements of the stream. On top of that, the collector <em>concat</em> creates an intermediate <em>ArrayList</em> each time it is used in the chain. Both operations can have a significant impact on the behaviour of your program. However, if <em>readability</em> is more important than <em>performance</em>, it might still be a very helpful approach.</p>\n    "},{"t":"Java 8 Stream and operation on arrays","l":"http://stackoverflow.com/questions/24390463/java-8-stream-and-operation-on-arrays","q":"\n\n<p>I have just discovered the new Java 8 stream capabilities. Coming from python, I was wondering if there was now a neat way to do operations on arrays like summing, multiplying 2 arrays in a \"one line pythonnic\" way ? </p>\n\n<p>Thanks</p>\n    ","a":"\n<p>There are new methods added to <code>java.util.Arrays</code> to convert an array into a Java 8 stream which can then be used for summing etc.</p>\n\n<pre><code>int sum =  Arrays.stream(myIntArray)\n                 .sum();\n</code></pre>\n\n<p>Multiplying 2 arrays is a little more difficult because I can't think of a way to get the value AND the index at the same time as a Stream operation.  This means you probably have to stream over the indexes of the array.</p>\n\n<pre><code>//in this example a[] and b[] are same length\nint[] a = ...\nint[] b = ...\n\nint[] result = new int[a.length];\n\nIntStream.range(0, a.length)\n        .forEach( i-&gt; result[i] = a[i]* b[i]);\n</code></pre>\n\n<p><strong>EDIT</strong>\n  Commented Holger points out you can use the <code>map</code> method instead of <code>forEach</code> like this:</p>\n\n<pre><code>int[] result = IntStream.range(0, a.length).map( i-&gt;a[i]* b[i]).toArray();\n</code></pre>\n    "},{"t":"Using Java 8's Optional with Stream::flatMap","l":"http://stackoverflow.com/questions/22725537/using-java-8s-optional-with-streamflatmap","q":"\n\n<p>The new Java 8 stream framework and friends make for some very concise java code, but I have come across a seemingly-simple situation that is tricky to do concisely.</p>\n\n<p>Consider a <code>List&lt;Thing&gt; things</code> and method <code>Optional&lt;Other&gt; resolve(Thing thing)</code>. I want to map the <code>Thing</code>s to <code>Optional&lt;Other&gt;</code>s and get the first <code>Other</code>. The obvious solution would be to use <code>things.stream().flatMap(this::resolve).findFirst()</code>, but <code>flatMap</code> requires that you return a stream, and <code>Optional</code> doesn't have a <code>stream()</code> method (or is it a <code>Collection</code> or provide a method to convert it to or view it as a <code>Collection</code>).</p>\n\n<p>The best I can come up with is this:</p>\n\n<pre><code>things.stream()\n    .map(this::resolve)\n    .filter(Optional::isPresent)\n    .map(Optional::get)\n    .findFirst();\n</code></pre>\n\n<p>But that seems awfully long-winded for what seems like a very common case. Anyone have a better idea?</p>\n    ","a":"\n<p>Yes, this does seem to be a small hole in the API, in that it's somewhat inconvenient to turn an Optional into a zero-or-one length Stream. You could do this:</p>\n\n<pre><code>Optional&lt;Other&gt; result =\n    things.stream()\n          .map(this::resolve)\n          .flatMap(o -&gt; o.isPresent() ? Stream.of(o.get()) : Stream.empty())\n          .findFirst();\n</code></pre>\n\n<p>Having the ternary operator inside the flatMap is a bit cumbersome, though, so it might be better to write a little helper function to do this:</p>\n\n<pre><code>/**\n * Turns an Optional&lt;T&gt; into a Stream&lt;T&gt; of length zero or one depending upon\n * whether a value is present.\n */\nstatic &lt;T&gt; Stream&lt;T&gt; streamopt(Optional&lt;T&gt; opt) {\n    if (opt.isPresent())\n        return Stream.of(opt.get());\n    else\n        return Stream.empty();\n}\n\nOptional&lt;Other&gt; result =\n    things.stream()\n          .flatMap(t -&gt; streamopt(resolve(t)))\n          .findFirst();\n</code></pre>\n\n<p>Here, I've inlined the call to resolve() instead of having a separate map() operation, but this is a matter of taste.</p>\n\n<p><strong>UPDATE 2015-02-25</strong></p>\n\n<p><code>Optional.stream</code> has been added to JDK 9: see <a href=\"https://bugs.openjdk.java.net/browse/JDK-8050820\">JDK-8050820</a> and <a href=\"http://hg.openjdk.java.net/jdk9/jdk9/jdk/rev/ed38ff66f7dd\">changeset</a>. This enables the example to be rewritten as follows, without the need of any helper method:</p>\n\n<pre><code>Optional&lt;Other&gt; result =\n    things.stream()\n          .map(this::resolve)\n          .flatMap(Optional::stream)\n          .findFirst();\n</code></pre>\n    "},{"t":"What does the arrow operator, '->', do in Java?","l":"http://stackoverflow.com/questions/15146052/what-does-the-arrow-operator-do-in-java","q":"\n\n<p>While hunting through some code I came across the arrow operator, what exactly does it do? I thought Java did not have an arrow operator.</p>\n\n<pre><code>return (Collection&lt;Car&gt;) CollectionUtils.select(listOfCars, (arg0) -&gt; {\n        return Car.SEDAN == ((Car)arg0).getStyle();\n});\n</code></pre>\n\n<p><em><strong>Details</strong>: Java 6, Apache Commons Collection, IntelliJ 12</em> </p>\n\n<p><em><strong>Update/Answer:</strong> It turns out that IntelliJ 12 supports Java 8, which supports lambdas, and is \"folding\" Predicates and displaying them as lambdas. Below is the \"un-folded\" code.</em></p>\n\n<pre><code>return (Collection&lt;Car&gt;) CollectionUtils.select(listOfCars, new Predicate() {\n    public boolean evaluate(Object arg0) {\n        return Car.SEDAN == ((Car)arg0).getStyle();\n    }\n});\n</code></pre>\n    ","a":"\n<p>That's part of the syntax of the new lambda expressions, to be introduced in Java 8. There are a couple of online tutorials to get the hang of it, here's a <a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\">link</a> to one. Basically, the <code>-&gt;</code> separates the parameters (left-side) from the actual expression (right side).</p>\n    "},{"t":"How to correctly determine that an object is a lambda?","l":"http://stackoverflow.com/questions/23870478/how-to-correctly-determine-that-an-object-is-a-lambda","q":"\n\n<p>I see that the class of a lambda is <code>isSynthetic() &amp;&amp; !isLocalOrAnonymousClass()</code>, but I presume that the same may be true for proxy classes.</p>\n\n<p>Of course, I could check that <code>getDeclaredMethods().length == 1</code> and apply <code>regexp</code> to the class name.</p>\n\n<p>However I want to know if there is a more elegant and robust option to find out if a given object is a lambda.</p>\n    ","a":"\n<p>There is no official way to do this, by design.  Lambdas are part of the language; and are integrated into the type system through functional interfaces.  There should be no need to distinguish a <code>Runnable</code> that began life as a lambda, a named class, or an inner class -- they're all Runnables.  If you think you have to \"deal with lambda\" by taking apart the class file, you're almost certainly doing something wrong!  </p>\n    "},{"t":"How to create an infinite stream with Java 8","l":"http://stackoverflow.com/questions/22483554/how-to-create-an-infinite-stream-with-java-8","q":"\n\n<p>Is there a easy way to create a infinity stream using <code>Java8</code> without external libraries?</p>\n\n<p>For example in Scala: </p>\n\n<pre><code>Iterator.iterate(0)(_ + 2)\n</code></pre>\n    ","a":"\n<p>Yes, there is an <strong>easy</strong> way:</p>\n\n<pre><code>IntStream.iterate(0, i -&gt; i + 2);\n</code></pre>\n\n<p>With as usecase:</p>\n\n<pre><code>IntStream.iterate(0, i -&gt; i + 2)\n        .limit(100)\n        .forEach(System.out::println);\n</code></pre>\n\n<p>Which prints out 0 to 198 increasing in steps of 2.</p>\n\n<p>The generic method is:</p>\n\n<pre><code>Stream.iterate(T seed, UnaryOperator&lt;T&gt; f);\n</code></pre>\n\n<p>The latter may be more uncommon in usage.</p>\n    "},{"t":"Closures in Scala vs Closures in Java","l":"http://stackoverflow.com/questions/6142068/closures-in-scala-vs-closures-in-java","q":"\n\n<p>Some time ago Oracle decided that adding Closures to Java 8 would be an good idea. I wonder how design problems are solved there in comparison to Scala, which had closures since day one.</p>\n\n<p>Citing the <strong><em>Open Issues</em></strong> from <a href=\"http://www.javac.info/issues-v06a.html\">javac.info</a>:</p>\n\n<ol>\n<li><p><strong>Can Method Handles be used for Function Types?</strong>\nIt isn't obvious how to make that work. One problem is that Method Handles reify type parameters, but in a way that interferes with function subtyping.</p></li>\n<li><p><strong>Can we get rid of the explicit declaration of \"throws\" type parameters?</strong>\nThe idea would be to use disjuntive type inference whenever the declared bound is a checked exception type. This is not strictly backward compatible, but it's unlikely to break real existing code. We probably can't get rid of \"throws\" in the type argument, however, due to syntactic ambiguity.</p></li>\n<li><p><strong>Disallow @Shared on old-style loop index variables</strong></p></li>\n<li><p><strong>Handle interfaces like Comparator that define more than one method,</strong> all but one of which will be implemented by a method inherited from Object.\nThe definition of \"interface with a single method\" should count only methods that would not be implemented by a method in Object and should count multiple methods as one if implementing one of them would implement them all. Mainly, this requires a more precise specification of what it means for an interface to have only a single abstract method.</p></li>\n<li><p><strong>Specify mapping from function types to interfaces:</strong> names, parameters, etc.\nWe should fully specify the mapping from function types to system-generated interfaces precisely.</p></li>\n<li><p><strong>Type inference.</strong> The rules for type inference need to be augmented to accomodate the inference of exception type parameters. Similarly, the subtype relationships used by the closure conversion should be reflected as well.</p></li>\n<li><p><strong>Elided exception type parameters to help retrofit exception transparency.</strong>\nPerhaps make elided exception type parameters mean the bound. This enables retrofitting existing generic interfaces that don't have a type parameter for the exception, such as java.util.concurrent.Callable, by adding a new generic exception parameter.</p></li>\n<li><p><strong>How are class literals for function types formed?</strong>\nIs it #void().class ? If so, how does it work if object types are erased? Is it #?(?).class ?</p></li>\n<li><p><strong>The system class loader should dynamically generate function type interfaces.</strong>\nThe interfaces corresponding to function types should be generated on demand by the bootstrap class loader, so they can be shared among all user code. For the prototype, we may have javac generate these interfaces so prototype-generated code can run on stock (JDK5-6) VMs.</p></li>\n<li><p><strong>Must the evaluation of a lambda expression produce a fresh object each time?</strong>\nHopefully not. If a lambda captures no variables from an enclosing scope, for example, it can be allocated statically. Similarly, in other situations a lambda could be moved out of an inner loop if it doesn't capture any variables declared inside the loop. It would therefore be best if the specification promises nothing about the reference identity of the result of a lambda expression, so such optimizations can be done by the compiler.</p></li>\n</ol>\n\n<p>As far as I understand 2., 6. and 7. aren't a problem in Scala, because Scala doesn't use Checked Exceptions as some sort of \"Shadow type-system\" like Java.</p>\n\n<p>What about the rest?</p>\n    ","a":"\n<p><em>1) Can Method Handles be used for Function Types?</em></p>\n\n<p>Scala targets JDK 5 and 6 which don't have method handles, so it hasn't tried to deal with that issue yet.</p>\n\n<p><em>2) Can we get rid of the explicit declaration of \"throws\" type parameters?</em></p>\n\n<p>Scala doesn't have checked exceptions.</p>\n\n<p><em>3) Disallow @Shared on old-style loop index variables.</em></p>\n\n<p>Scala doesn't have loop index variables.  Still, the same idea can be expressed with a certain kind of while loop .  Scala's semantics are pretty standard here.  Symbols bindings are captured and if the symbol happens to map to a mutable reference cell then on your own head be it.</p>\n\n<p><em>4) Handle interfaces like Comparator that define more than one method all but one of which come from Object</em></p>\n\n<p>Scala users tend to use functions (or implicit functions) to coerce functions of the right type to an interface. e.g.</p>\n\n<pre><code>[implicit] def toComparator[A](f : (A, A) =&gt; Int) = new Comparator[A] { \n    def compare(x : A, y : A) = f(x, y) \n}\n</code></pre>\n\n<p><em>5) Specify mapping from function types to interfaces:</em></p>\n\n<p>Scala's standard library includes FuncitonN traits for 0 &lt;= N &lt;= 22 and the spec says that function literals create instances of those traits</p>\n\n<p><em>6)  Type inference. The rules for type inference need to be augmented to accomodate the inference of exception type parameters.</em></p>\n\n<p>Since Scala doesn't have checked exceptions it can punt on this whole issue</p>\n\n<p><em>7) Elided exception type parameters to help retrofit exception transparency.</em></p>\n\n<p>Same deal, no checked exceptions.</p>\n\n<p><em>8) How are class literals for function types formed?  Is it #void().class ? If so, how does it work if object types are erased? Is it #?(?).class ?</em></p>\n\n<pre><code>classOf[A =&gt; B] //or, equivalently, \nclassOf[Function1[A,B]]\n</code></pre>\n\n<p>Type erasure is type erasure.  The above literals produce scala.lang.Function1 regardless of the choice for A and B. If you prefer, you can write </p>\n\n<pre><code>classOf[ _ =&gt; _ ] // or\nclassOf[Function1[ _,_ ]]\n</code></pre>\n\n<p><em>9) The system class loader should dynamically generate function type interfaces.</em></p>\n\n<p>Scala arbitrarily limits the number of arguments to be at most 22 so that it doesn't have to generate the FunctionN classes dynamically.</p>\n\n<p><em>10) Must the evaluation of a lambda expression produce a fresh object each time?</em></p>\n\n<p>The Scala specification does not say that it must.  But as of 2.8.1 the the compiler does not optimizes the case where a lambda does not capture anything from its environment.  I haven't tested with 2.9.0 yet.</p>\n    "},{"t":"Java 8 Streams FlatMap method example","l":"http://stackoverflow.com/questions/22382453/java-8-streams-flatmap-method-example","q":"\n\n<p>i have checking the upcoming <code>Java update</code> namely <code>Java 8 or JDK 8</code> yes i am impatient there is a lot of new stuff but there is something i dont understand.</p>\n\n<p>some simple code.</p>\n\n<pre><code>final Stream&lt;Integer&gt;stream = Stream.of(1,2,3,4,5,6,7,8,9,10);\nstream.flatMap();\n</code></pre>\n\n<p>the javadocs are</p>\n\n<blockquote>\n  <p><code>public &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code></p>\n  \n  <p>Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.)\n      This is an intermediate operation.  </p>\n</blockquote>\n\n<p>i would like if somebody create some simples real life examples about <code>flatMap</code> how you could code   it in previous java versions <code>Java[6,7]</code> and how you can code the same routines using <code>Java 8</code>.</p>\n\n<p>thanks a lot. </p>\n    ","a":"\n<p>It doesn't make sense to <code>flatMap</code> a <a href=\"http://download.java.net/jdk8/docs/api/java/util/stream/Stream.html\" rel=\"nofollow\">Stream</a> that's already flat, like the <code>Stream&lt;Integer&gt;</code> you've shown in your question.  </p>\n\n<p>However, if you had a <code>Stream&lt;List&lt;Integer&gt;&gt;</code> then it would make sense and you could do this:</p>\n\n<pre><code>Stream&lt;List&lt;Integer&gt;&gt; integerListStream = Stream.of(\n  Arrays.asList(1, 2), \n  Arrays.asList(3, 4), \n  Arrays.asList(5)\n);\n\nStream&lt;Integer&gt; integerStream = integerListStream .flatMap(Collection::stream);\nintegerStream.forEach(System.out::println);\n</code></pre>\n\n<p>Which would print:</p>\n\n<pre><code>1\n2\n3\n4\n5\n</code></pre>\n\n<p>To do this pre-Java 8 you just need a loops:</p>\n\n<pre><code>List&lt;List&lt;Integer&gt;&gt; integerLists = Arrays.asList(\n  Arrays.asList(1, 2), \n  Arrays.asList(3, 4), \n  Arrays.asList(5)\n)\n\nList&lt;Integer&gt; flattened = new ArrayList&lt;&gt;();\n\nfor (List&lt;Integer&gt; integerList : integerLists)\n{\n  flattened.addAll(integerList);\n}\n\nfor (Integer i : flattened)\n{\n  System.out.println(i);\n}\n</code></pre>\n    "},{"t":"Java “lambda expressions not supported at this language level”","l":"http://stackoverflow.com/questions/22703412/java-lambda-expressions-not-supported-at-this-language-level","q":"\n\n<p>I was testing out some new features of Java 8 and copied the example into my IDE (Eclipse originally, then IntelliJ) as shown here:\n<a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/examples/RosterTest.java\">http://docs.oracle.com/javase/tutorial/java/javaOO/examples/RosterTest.java</a></p>\n\n<p>Eclipse offered no support whatsoever for lambda expressions, and IntelliJ kept reporting an error \"Lambda expressions not supported at this language level\".  I would like to know if this is a problem with my install, the code, or support.</p>\n    ","a":"\n<p>In IntelliJ IDEA:</p>\n\n<p>In <code>File Menu</code> → <code>Project Structure</code> → <code>Project</code>, change <code>Project Language Level</code> to <code>8.0 - Lambdas, type annotations etc.</code></p>\n    "},{"t":"How to parse/format dates with LocalDateTime? (Java 8)","l":"http://stackoverflow.com/questions/22463062/how-to-parse-format-dates-with-localdatetime-java-8","q":"\n\n<p>Java 8 added a new API for working with dates and times (JSR 310).</p>\n\n<p>I have date and time as string (e.g. <code>\"2014-04-08 12:30\"</code>). How can I obtain a <a href=\"http://download.java.net/jdk8/docs/api/java/time/LocalDateTime.html\"><code>LocalDateTime</code></a> instance from the given string?</p>\n\n<p>After I finished working with the <code>LocalDateTime</code> object: How can I then convert the <code>LocalDateTime</code> instance back to a string with the same format as shown above?</p>\n    ","a":"\n<p><strong>Parsing date and time</strong></p>\n\n<p>To create a <code>LocalDateTime</code> object from a string you can use the static <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html#parse-java.lang.CharSequence-\"><code>LocalDateTime.parse()</code></a> method. It takes a string and a <a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\"><code>DateTimeFormatter</code></a> as parameter. The <code>DateTimeFormatter</code> is used to specify the date/time pattern.</p>\n\n<pre><code>String str = \"1986-04-08 12:30\";\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\nLocalDateTime dateTime = LocalDateTime.parse(str, formatter);\n</code></pre>\n\n<p><strong>Formatting date and time</strong></p>\n\n<p>To create a formatted string out a <code>LocalDateTime</code> object you can use the <code>format()</code> method.</p>\n\n<pre><code>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\nLocalDateTime dateTime = LocalDateTime.of(1986, Month.APRIL, 8, 12, 30);\nString formattedDateTime = dateTime.format(formatter); // \"1986-04-08 12:30\"\n</code></pre>\n\n<p>Note that there are some commonly used date/time formats predefined as constants in <code>DateTimeFormatter</code>. For example: Using <code>DateTimeFormatter.ISO_DATE_TIME</code> to format the <code>LocalDateTime</code> instance from above would result in the string <code>\"1986-04-08T12:30:00\"</code>.</p>\n\n<p>The <code>parse()</code> and <code>format()</code> methods are available for all date/time related objects (e.g. <code>LocalDate</code> or <code>ZonedDateTime</code>)</p>\n    "},{"t":"Version 1.8 of project facet java does not exist","l":"http://stackoverflow.com/questions/21955207/version-1-8-of-project-facet-java-does-not-exist","q":"\n\n<p>I'm trying to build a <code>Dynamic Web Application</code> in eclipse using Java 8 (and Wildfly appServer if that matters) but I'm unable to make Eclipse Luna M5 use Java 8 (I do have Java 8 BETA support installed and it works on JavaSE projects). </p>\n\n<p>In my POM I set the level to Java 8:</p>\n\n<pre><code>&lt;plugin&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;version&gt;3.1&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;source&gt;1.8&lt;/source&gt;\n        &lt;target&gt;1.8&lt;/target&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>\n\n<p>But after I do <code>maven -&gt; update project</code> I get the following error:</p>\n\n<pre><code>Could not update project ExampleApp configuration\nVersion 1.8 of project facet java does not exist.\n</code></pre>\n\n<p>And indeed there is no java 1.8 project facet under <code>project-&gt;preferences-&gt;project facets-&gt;java</code></p>\n\n<p>Can I manually create such <code>facet</code> and add It to to eclipse or I'll have to wait until java 8 is released and the eclipse guys decide to add it ?</p>\n    ","a":"\n<p>There are additional patches available for Kepler SR2 officially.\nIn ecliplse, go to \"Help\" --&gt; \"Market Place\" --&gt; Search for java 8 kepler.\nThen choose and install the following.</p>\n\n<ul>\n<li>install Java 8 support eclipse kepler sr2,<br></li>\n<li>Java 8 Facets for web tools eclipse kepler sr2<br></li>\n<li>Java 8 support for m2e for Eclipse Kepler SR2  (if required)</li>\n</ul>\n\n<p>Reference: <a href=\"http://www.eclipse.org/downloads/java8/\">http://www.eclipse.org/downloads/java8/</a></p>\n\n<p>After this, my multi-module maven project with java 8 is building fine without any error in eclipse kepler SR2.</p>\n\n<p><strong>UPDATE</strong>: If you are using Spring Tool Suite (STS), then version 3.5.1 has included these features.</p>\n    "},{"t":"Should I use Java8/Guava Optional for every method that may return null?","l":"http://stackoverflow.com/questions/18681243/should-i-use-java8-guava-optional-for-every-method-that-may-return-null","q":"\n\n<p>Optional is used to represent nullable object, Some uses of this class include</p>\n\n<ol>\n<li>As a method return type, as an alternative to returning null to<br>\nindicate that no value was available</li>\n<li>To distinguish between \"unknown\" (for example, not present in a map)\nand \"known to have no value\" (present in the map, with value<br>\nOptional.absent())</li>\n<li>To wrap nullable references for storage in a collection that does not\nsupport null (though there are several other approaches to this that\nshould be considered first)</li>\n</ol>\n\n<p>For the first case, do I need to return Optional in all nullable return method?  </p>\n    ","a":"\n<p><strong>So What’s Wrong with Optional?</strong></p>\n\n<p>The question we face is: will JDK 8 Optional objects get rid of null references? And the answer is an emphatic no! So, detractors immediately question its value asking: then what is it good for that we couldn't already do by other means?</p>\n\n<p>Unlike functional languages like SML o Haskell which never had the concept of null references, in Java we cannot simply get rid of the null references that have historically existed. This will continue to exist, and they arguably have their proper uses (just to mention an example: <a href=\"http://en.wikipedia.org/wiki/Three-valued_logic\">three-valued logic</a>).</p>\n\n<p>I doubt that the intention with the Optional class is to replace every single nullable reference, but to help in the creation of more robust APIs in which just by reading the signature of a method we could tell if we can expect an optional value or not  and force the programmer to use this value accordingly. But ultimately, Optional will be just another reference and subject to the same weaknesses of every other reference in the language (e.g. you could return a null Optional). It is quite evident that Optional is not going to save the day.</p>\n\n<p>How these optional objects are supposed to be used or whether they are valuable or not in Java has been the matter of a <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-October/006365.html\">heated debate</a> in the project lambda mailing list. From the detractors we hear interesting arguments like:</p>\n\n<ul>\n<li>The fact that other alternatives exist ( e.g. IDES like IntelliJ and Eclipse IDE support a set of <a href=\"http://help.eclipse.org/juno/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_null_annotations.htm\">proprietary annotations</a> for static analysis of nullability, the <a href=\"http://jcp.org/en/jsr/detail?id=305\">JSR-305</a> with annotations like @Nullable and @NonNull).</li>\n<li>Some would like it to be usable as in the <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-October/006349.html\">functional world</a>, which is not entirely possible in Java since the language lacks many features existing in functional programming languages like SML or Haskell (e.g. pattern matching).</li>\n<li>Others argue about how it is impossible to <a href=\"http://blog.jooq.org/2013/04/11/on-java-8s-introduction-of-optional/\">retrofit preexisting code</a> to use this idiom (e.g. List.get(Object) which will continue to return null).</li>\n<li>And some complain about the fact that the lack of language support for optional values creates a potential scenario in which Optional could be <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-October/006348.html\">used inconsistently</a> in the APIs, by this creating incompatibilities, pretty much like the ones we will have with the rest of the Java API which cannot be retrofitted to use the new Optional class. This is pretty much your question here. In languages with support for optional types like Ceylon, you would not even question this.</li>\n<li>A compelling argument is that if the programmer invokes the get method in an optional object, if it is empty, it will raise a NoSuchElementException, which is pretty much the same problem that we have with nulls, just with a different exception.</li>\n</ul>\n\n<p>So, it would appear that the benefits of Optional are really questionable and are probably constrained to improving readability and enforcing public interface contracts. </p>\n\n<p>I do believe that the adoption of this Optional functional idiom is likely to make our code safer, less prompt to null dereferencing problems and as a result more robust and less error prone. Of course, it is not a perfect solution because, after all, Optional references can also be erroneously set to null references, but  I would expect that programmers stick to the convention of not passing null references where an optional object is expected, pretty much as we today consider a good practice not to pass a null reference where a collection or an array is expected, in these cases the correct is to pass an empty array or collection. The point here is that now we have a mechanism in the API that we can use to make explicit that for a given reference we may not have a value to assign it and the user is forced, by the API, to verify that.</p>\n\n<p>Quoting <a href=\"https://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained\">Google Guava's article</a> about the use of optional objects: </p>\n\n<blockquote>\n  <p>“Besides the increase in readability that comes from giving null a\n  name, the biggest advantage of Optional is its idiot-proof-ness. It\n  forces you to actively think about the absent case if you want your\n  program to compile at all, since you have to actively unwrap the\n  Optional and address that case”.</p>\n</blockquote>\n\n<p>So, I guess it's up to every API designer to choose how far they want to go in the use of Optional.</p>\n    "},{"t":"Is there a way to compare lambdas?","l":"http://stackoverflow.com/questions/24095875/is-there-a-way-to-compare-lambdas","q":"\n\n<p>Say I have a List of object which were defined using lambda expressions (closures).  Is there a way to inspect them so they can be compared?</p>\n\n<p>The code I am most interested in is</p>\n\n<pre><code>    List&lt;Strategy&gt; strategies = getStrategies();\n    Strategy a = (Strategy) this::a;\n    if (strategies.contains(a)) { // ...\n</code></pre>\n\n<p>The full code is</p>\n\n<pre><code>import java.util.Arrays;\nimport java.util.List;\n\npublic class ClosureEqualsMain {\n    interface Strategy {\n        void invoke(/*args*/);\n        default boolean equals(Object o) { // doesn't compile\n            return Closures.equals(this, o);\n        }\n    }\n\n    public void a() { }\n    public void b() { }\n    public void c() { }\n\n    public List&lt;Strategy&gt; getStrategies() {\n        return Arrays.asList(this::a, this::b, this::c);\n    }\n\n    private void testStrategies() {\n        List&lt;Strategy&gt; strategies = getStrategies();\n        System.out.println(strategies);\n        Strategy a = (Strategy) this::a;\n        // prints false\n        System.out.println(\"strategies.contains(this::a) is \" + strategies.contains(a));\n    }\n\n    public static void main(String... ignored) {\n        new ClosureEqualsMain().testStrategies();\n    }\n\n    enum Closures {;\n        public static &lt;Closure&gt; boolean equals(Closure c1, Closure c2) {\n            // This doesn't compare the contents \n            // like others immutables e.g. String\n            return c1.equals(c2);\n        }\n\n        public static &lt;Closure&gt; int hashCode(Closure c) {\n            return // a hashCode which can detect duplicates for a Set&lt;Strategy&gt;\n        }\n\n        public static &lt;Closure&gt; String asString(Closure c) {\n            return // something better than Object.toString();\n        }\n    }    \n\n    public String toString() {\n        return \"my-ClosureEqualsMain\";\n    }\n}\n</code></pre>\n\n<p>It would appear the only solution is to define each lambda as a field and only use those fields. If you want to print out the method called, you are better off using <code>Method</code>. Is there a better way with lambda expressions?</p>\n\n<p>Also, is it possible to print a lambda and get something human readable?  If you print <code>this::a</code> instead of</p>\n\n<pre><code>ClosureEqualsMain$$Lambda$1/821270929@3f99bd52\n</code></pre>\n\n<p>get something like</p>\n\n<pre><code>ClosureEqualsMain.a()\n</code></pre>\n\n<p>or even use <code>this.toString</code> and the method.</p>\n\n<pre><code>my-ClosureEqualsMain.a();\n</code></pre>\n    ","a":"\n<p>This question could be interpreted relative to the specification or the implementation.  Obviously, implementations could change, but you might be willing to rewrite your code when that happens, so I'll answer at both.</p>\n\n<p>It also depends on what you want to do.  Are you looking to optimize, or are you looking for ironclad guarantees that two instances are (or are not) the same function?  (If the latter, you're going to find yourself at odds with computational physics, in that even problems as simple as asking whether two functions compute the same thing are undecidable.)</p>\n\n<p>From a specification perspective, the language spec promises only that the result of evaluating (not invoking) a lambda expression is an instance of a class implementing the target functional interface.  It makes no promises about the identity, or degree of aliasing, of the result.  This is by design, to give implementations maximal flexibility to offer better performance (this is how lambdas can be faster than inner classes; we're not tied to the \"must create unique instance\" constraint that inner classes are.)  </p>\n\n<p>So basically, the spec doesn't give you much, except obviously that two lambdas that are reference-equal (==) are going to compute the same function.  </p>\n\n<p>From an implementation perspective, you can conclude a little more.  There is (currently, may change) a 1:1 relationship between the synthetic classes that implement lambdas, and the capture sites in the program.  So two separate bits of code that capture \"x -&gt; x + 1\" may well be mapped to different classes.  But if you evaluate the same lambda at the same capture site,  and that lambda is non-capturing, you get the same instance, which can be compared with reference equality.  </p>\n\n<p>If your lambdas are serializable, they'll give up their state more easily, in exchange for sacrificing some performance and security (no free lunch.)  </p>\n\n<p>One area where it might be practical to tweak the definition of equality is with method references, because this would enable them to be used as listeners and be properly unregistered.  This is under consideration.  </p>\n\n<p>I think what you're trying to get to is: if two lambdas are converted to the same functional interface, are represented by the same behavior function, and have identical captured args, they're the same</p>\n\n<p>Unfortunately this is both hard to do (for non-serializable lambdas, you can't get at all the components of that) and not enough (because two separately compiled files could convert the same lambda to the same functional interface type, and you wouldn't be able to tell.)  </p>\n\n<p>The EG discussed whether to expose enough information to be able to make these judgments, as well as discussing whether lambdas should implement more selective equals/hashCode or more descriptive toString.  The conclusion was that we were not willing to pay anything in performance cost to make this information available to the caller (bad tradeoff, punishing 99.99% of users for something that benefits .01%).  </p>\n\n<p>A definitive conclusion on toString was not reached, but left open to be revisited in the future.  However, there were some good arguments made on both sides on this issue; this is not a slam-dunk.  </p>\n    "},{"t":"Java 8 poor GUI performance compared to Java 6","l":"http://stackoverflow.com/questions/28046809/java-8-poor-gui-performance-compared-to-java-6","q":"\n\n<p>In Java 6 below code is running as expected but in Java 8 it is taking much more time. The interesting part is that components use the same method <code>setEnable()</code> for enabling and disabling components, but the disabling call takes much longer than the enabling one, almost twice as much. Disabling in Java 8 is taking much longer than the one in Java 1.6. The question is why does this happen? Is this a performance problem of Java 8?</p>\n\n<p>Here are the results for Java 6:</p>\n\n<pre><code>    Sun Microsystems Inc. 1.6.0_45\n    Initializing GUI\n    GUI initialized in 1105 ms\n    Disabling\n    Disabled in 687 ms\n    Enabling\n    Enabled in 375 ms\n</code></pre>\n\n<p>Here are the results for Java 8:</p>\n\n<pre><code>    Oracle Corporation 1.8.0_25\n    Initializing GUI\n    GUI initialized in 604 ms\n    Disabling\n    Disabled in 6341 ms\n    Enabling\n    Enabled in 370 ms\n</code></pre>\n\n<p>The code:</p>\n\n<pre><code>import java.awt.Component;\nimport java.awt.EventQueue;\nimport java.awt.FlowLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\n\npublic class TestGUI extends JFrame implements ActionListener {\n\n    private static final long serialVersionUID = 1L;\n\n    public TestGUI() {\n        initGUI();\n    }\n\n    public void actionPerformed(ActionEvent e) {\n        String text;\n        if(e.getActionCommand().equals(\"Enable-ALL\")){\n            enableAll();\n            text= \"Disable-ALL\";\n        }\n        else{\n            disableAll();\n            text= \"Enable-ALL\";\n        }\n        ((JButton)e.getSource()).setText(text);\n        ((JButton)e.getSource()).setEnabled(true);\n\n    }\n\n\n    private  void initGUI() {\n        long m = System.currentTimeMillis();\n        System.out.println(\"Initializing GUI\");\n        setTitle(System.getProperty(\"java.vendor\") + \" \" + System.getProperty(\"java.version\"));\n        setLayout(new FlowLayout());\n\n        JButton b = new JButton(\"Disable-ALL \");\n        b.addActionListener(this);\n        add(b);\n\n        for (int i = 1; i &lt; 10001; i++) {\n            b = new JButton(\"Button \" + i);\n            add(b);\n        }\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setSize(600, 600);\n        setVisible(true);\n        m = System.currentTimeMillis() - m;\n        System.out.println(\"GUI initialized in \" + m + \" ms\");\n    }\n\n    private void disableAll() {\n        long m = System.currentTimeMillis();\n        System.out.println(\"Disabling\");\n        for (Component c : getContentPane().getComponents()) {\n            c.setEnabled(false);\n        }\n\n        m = System.currentTimeMillis() - m;\n        System.out.println(\"Disabled in \" + m + \" ms\");\n    }\n\n    private void enableAll() {\n        long m = System.currentTimeMillis();\n        System.out.println(\"Enabling\");\n        for (Component c : getContentPane().getComponents()) {\n            c.setEnabled(true);\n            invalidate();\n        }\n        m = System.currentTimeMillis() - m;\n        System.out.println(\"Enabled in \" + m + \" ms\");\n    }\n\n    public static void main(String[] args) {\n\n        EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                System.out.println(System.getProperty(\"java.vendor\") + \" \"\n                        + System.getProperty(\"java.version\"));\n                new TestGUI();\n            }\n        });\n    }\n}\n</code></pre>\n    ","a":"\n<p>According to my profiler, the operation spends most of the time in the method <code>Thread.holdsLock</code>, which can be indeed a costly operation, which is called by <code>Component.checkTreeLock</code> which is called indirectly by <code>Component.updateCursorImmediately</code>.</p>\n\n<p>Generally, you can avoid costly visual updates when updating multiple components by calling <code>getContentPane().setVisible(false);</code> right before the operation and <code>getContentPane().setVisible(true);</code> right afterwards, e.g.</p>\n\n<pre><code>private void disableAll() {\n    long m = System.currentTimeMillis();\n    System.out.println(\"Disabling\");\n    getContentPane().setVisible(false);\n    for (Component c : getContentPane().getComponents()) {\n        c.setEnabled(false);\n    }\n    getContentPane().setVisible(true);\n\n    m = System.currentTimeMillis() - m;\n    System.out.println(\"Disabled in \" + m + \" ms\");\n}\n</code></pre>\n\n<p>You will see, such problems will vanish, regardless of which kind of visual update causes the problem in detail.</p>\n\n<p>So you don’t need to think about how to benchmark correctly here, not that it matters when the operation takes seconds, but I recommend learning the difference between <code>System.currentTimeMillis()</code> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#nanoTime--\"><code>System.nanoTime()</code></a> as the latter is the right tool for measuring <em>elapsed time</em>.</p>\n    "},{"t":"Uses for Java8 Optional","l":"http://stackoverflow.com/questions/23454952/uses-for-java8-optional","q":"\n\n<p>Having been using <code>Java 8</code> now for 6+ months or so, I'm pretty happy with the new API changes. One area I'm still not confident in is when to use <code>Optional</code>. I seem to swing between wanting to use it everywhere something may be <code>null</code>, and nowhere at all.</p>\n\n<p>There seem to be a lot of situations when I could use it, and I'm never sure if it adds benefit (IE readability / null safety) or just causes additional overhead. </p>\n\n<p>So, I have a few examples, and I'd be interested in the community's thoughts on whether <code>Optional</code> adds benefit. </p>\n\n<p>1 - As a public method return type when the method could return <code>null</code>:</p>\n\n<pre><code>public Optional&lt;Foo&gt; findFoo(String id);\n</code></pre>\n\n<p>2 - As a method parameter when the param may be <code>null</code>:</p>\n\n<pre><code>public Foo doSomething(String id, Optional&lt;Bar&gt; barOptional);\n</code></pre>\n\n<p>3 - As an optional member of a bean:</p>\n\n<pre><code>public class Book {\n\n  private List&lt;Pages&gt; pages;\n  private Optional&lt;Index&gt; index;\n\n}\n</code></pre>\n\n<p>4 - In <code>Collections</code>: </p>\n\n<p>In general I don't think:</p>\n\n<pre><code>List&lt;Optional&lt;Foo&gt;&gt;\n</code></pre>\n\n<p>adds anything - especially since one can use <code>filter()</code> to remove <code>null</code> values etc, but are there any good uses for <code>Optional</code> in collections?</p>\n\n<p>Any cases I've missed?</p>\n    ","a":"\n<p>The main point of <code>Optional</code> is to provide a means for a function returning a value to indicate the absence of a return value. See <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-September/005952.html\">this discussion</a>. This allows the caller to continue a chain of fluent method calls.</p>\n\n<p>This most closely matches use case <strong>#1</strong> in the OP's question. Although, <em>absence of a value</em> is a more precise formulation than <em>null</em> since something like <code>IntStream.findFirst</code> could never return null.</p>\n\n<p>For use case <strong>#2</strong>, passing an optional argument to a method, this could be made to work, but it's rather clumsy. Suppose you have a method that takes a string followed by an optional second string. Accepting an <code>Optional</code> as the second arg would result in code like this:</p>\n\n<pre><code>foo(\"bar\", Optional.of(\"baz\"));\nfoo(\"bar\", Optional.empty());\n</code></pre>\n\n<p>Even accepting null is nicer:</p>\n\n<pre><code>foo(\"bar\", \"baz\");\nfoo(\"bar\", null);\n</code></pre>\n\n<p>Probably the best is to have an overloaded method that accepts a single string argument and provides a default for the second:</p>\n\n<pre><code>foo(\"bar\", \"baz\");\nfoo(\"bar\");\n</code></pre>\n\n<p>This does have limitations, but it's much nicer than either of the above.</p>\n\n<p>Use cases <strong>#3</strong> and <strong>#4</strong>, having an <code>Optional</code> in a class field or in a data structure, is considered a misuse of the API. First, it goes against the main design goal of <code>Optional</code> as stated at the top. Second, it doesn't add any value.</p>\n\n<p>There are three ways to deal with the absence of a value in an <code>Optional</code>: to provide a substitute value, to call a function to provide a substitute value, or to throw an exception. If you're storing into a field, you'd do this at initialization or assignment time. If you're adding values into a list, as the OP mentioned, you have the additional choice of simply not adding the value, thereby \"flattening\" out absent values.</p>\n\n<p>I'm sure somebody could come up with some contrived cases where they really want to store an <code>Optional</code> in a field or a collection, but in general, it is best to avoid doing this.</p>\n    "},{"t":"String Deduplication feature of Java 8","l":"http://stackoverflow.com/questions/27949213/string-deduplication-feature-of-java-8","q":"\n\n<p>Since <code>String</code> in Java (like other languages) consumes a lot of memory because each character consumes two bytes, Java 8 has introduced a new feature called <strong><em>String Deduplication</em></strong> which takes advantage of the fact that the char arrays are internal to strings and final, so the JVM can mess around with them.</p>\n\n<p>I have read <a href=\"https://blog.codecentric.de/en/2014/08/string-deduplication-new-feature-java-8-update-20-2/\">this example</a> so far but since I am not a pro java coder, I am having a hard time grasping the concept.</p>\n\n<p>Here is what it says,</p>\n\n<blockquote>\n  <p>Various strategies for String Duplication have been considered, but\n  the one implemented now follows the following approach: Whenever the\n  garbage collector visits String objects it takes note of the char\n  arrays. It takes their hash value and stores it alongside with a weak\n  reference to the array. As soon as it finds another String which has\n  the same hash code it compares them char by char. If they match as\n  well, one String will be modified and point to the char array of the\n  second String. The first char array then is no longer referenced\n  anymore and can be garbage collected.</p>\n  \n  <p>This whole process of course brings some overhead, but is controlled\n  by tight limits. For example if a string is not found to have\n  duplicates for a while it will be no longer checked.</p>\n</blockquote>\n\n<p><strong>My First question,</strong></p>\n\n<p>There is still a lack of resources on this topic since it is recently added in Java 8 update 20, could anyone here share some practical examples on how it help in reducing the memory consumed by <code>String</code> in Java ?</p>\n\n<p><strong>Edit:</strong></p>\n\n<p>The above link says,</p>\n\n<blockquote>\n  <p>As soon as it finds another String which has the same hash code it\n  compares them char by char</p>\n</blockquote>\n\n<p><strong>My 2nd question,</strong></p>\n\n<p>If hash code of two <code>String</code> are same then the <code>Strings</code> are already the same, then why compare them <code>char</code> by <code>char</code> once it is found that the two <code>String</code> have same hash code ?</p>\n    ","a":"\n<p>Imagine you have a phone book, which contains people, which have a <code>String firstName</code> and a <code>String lastName</code>. And it happens that in your phone book, 100,000 people have the same <code>firstName = \"John\"</code>.</p>\n\n<p>Because you get the data from a database or a file those strings are not interned so your JVM memory contains the char array <code>{'J', 'o', 'h', 'n'}</code> 100 thousand times, one per John string. Each of these arrays takes, say, 20 bytes of memory so those 100k Johns take up 2 MB of memory.</p>\n\n<p>With deduplication, the JVM will realise that \"John\" is duplicated many times and make all those John strings point to the same underlying char array, decreasing the memory usage from 2MB to 20 bytes.</p>\n\n<p>You can find a more detailed explanation in the <a href=\"http://openjdk.java.net/jeps/192\">JEP</a>. In particular:</p>\n\n<blockquote>\n  <p>Many large-scale Java applications are currently bottlenecked on memory. Measurements have shown that roughly 25% of the Java heap live data set in these types of applications is consumed by String objects. Further, roughly half of those String objects are duplicates, where duplicates means <code>string1.equals(string2)</code> is true. Having duplicate String objects on the heap is, essentially, just a waste of memory.</p>\n  \n  <p>[...]</p>\n  \n  <p>The actual expected benefit ends up at around 10% heap reduction. Note that this number is a calculated average based on a wide range of applications. The heap reduction for a specific application could vary significantly both up and down.</p>\n</blockquote>\n    "},{"t":"Monads with Java 8","l":"http://stackoverflow.com/questions/13454347/monads-with-java-8","q":"\n\n<p>In the interests of helping to understand what a monad is, can someone provide an example using java ? Are they possible ?</p>\n\n<p>Lambda expressions are possible using java if you download the pre-release lambda compatible JDK8   from here <a href=\"http://jdk8.java.net/lambda/\">http://jdk8.java.net/lambda/</a></p>\n\n<p>An example of a lambda using this JDK is shown below, can someone provide a comparably simple monad ?</p>\n\n<pre><code>public interface TransformService {\n        int[] transform(List&lt;Integer&gt; inputs);\n    }\n    public static void main(String ars[]) {\n        TransformService transformService = (inputs) -&gt; {\n            int[] ints = new int[inputs.size()];\n            int i = 0;\n            for (Integer element : inputs) {\n                ints[i] = element;\n            }\n            return ints;\n        };\n\n        List&lt;Integer&gt; inputs = new ArrayList&lt;Integer&gt;(5) {{\n            add(10);\n            add(10);\n        }};\n        int[] results = transformService.transform(inputs);\n    }\n</code></pre>\n    ","a":"\n<p>Just FYI:</p>\n\n<p>The proposed <a href=\"http://download.java.net/jdk8/docs/api/java/util/Optional.html\">JDK8 Optional</a> class <strong>does satisfy</strong> the three <a href=\"http://learnyouahaskell.com/a-fistful-of-monads#monad-laws\">Monad laws</a>. Here's a <a href=\"https://gist.github.com/ms-tg/7420496#file-jdk8_optional_monad_laws-java\">gist demonstrating</a> that.</p>\n\n<p>All it takes be a Monad is to provide <strong>two</strong> functions which conform to <strong>three</strong> laws.</p>\n\n<p>The two functions:</p>\n\n<ol>\n<li><p>Place a <em>value into monadic context</em></p>\n\n<ul>\n<li>Haskell's Maybe: <code>return</code> / <code>Just</code></li>\n<li>Scala's Option: <code>Some</code></li>\n<li>Functional Java's Option: <code>Option.some</code></li>\n<li>JDK8's Optional: <code>Optional.of</code></li>\n</ul></li>\n<li><p>Apply a <em>function in monadic context</em></p>\n\n<ul>\n<li>Haskell's Maybe: <code>&gt;&gt;=</code> (aka <code>bind</code>)</li>\n<li>Scala's Option: <code>flatMap</code></li>\n<li>Functional Java's Option: <code>flatMap</code></li>\n<li>JDK8's Optional: <code>flatMap</code></li>\n</ul></li>\n</ol>\n\n<p>Please see the <a href=\"https://gist.github.com/ms-tg/7420496#file-jdk8_optional_monad_laws-java\">above gist</a> for a java demonstration of the three laws. </p>\n\n<p>NOTE: One of the key things to understand is the signature of the <em>function to apply in monadic context</em>: it takes the raw value type, and returns the monadic type. </p>\n\n<p>In other words, if you have an instance of <code>Optional&lt;Integer&gt;</code>, the functions you can pass to its <code>flatMap</code> method will have the signature <code>(Integer) -&gt; Optional&lt;U&gt;</code>, where <code>U</code> is a value type which does not have to be <code>Integer</code>, for example <code>String</code>:</p>\n\n<pre><code>Optional&lt;Integer&gt; maybeInteger = Optional.of(1);\n\n// Function that takes Integer and returns Optional&lt;Integer&gt;\nOptional&lt;Integer&gt; maybePlusOne = maybeInteger.flatMap(n -&gt; Optional.of(n + 1));\n\n// Function that takes Integer and returns Optional&lt;String&gt;\nOptional&lt;String&gt; maybeString = maybePlusOne.flatMap(n -&gt; Optional.of(n.toString));\n</code></pre>\n\n<p>You don't need any sort of Monad Interface to code this way, or to think this way. In Scala, you don't code to a Monad Interface (unless you are using Scalaz library...). It appears that JDK8 will empower Java folks to use this style of <em>chained monadic computations</em> as well.</p>\n\n<p>Hope this is helpful!</p>\n\n<p><strong>Update:</strong> Blogged about this <a href=\"https://devblog.timgroup.com/2013/11/11/does-jdk8s-optional-class-satisfy-the-monad-laws-yes-it-does/\">here</a>.</p>\n    "},{"t":"Java 8 support in GWT","l":"http://stackoverflow.com/questions/15693169/java-8-support-in-gwt","q":"\n\n<p>This seems like a very basic question, but I searched high and low and have found almost no mention of it anywhere. So, I'll ask it here here.</p>\n\n<p><strong>What is the current plan for supporting Java 8's new language constructs in GWT?</strong></p>\n\n<p>In addition, what subset of the proposed Java 8 libraries are slated for client-side emulation? The Stream API? The new Date/Time API?</p>\n\n<p>And finally, where are the discussions relating this important topic taking place? I'm sure there are many of us who would like to participate in, and potentially contribute to, the effort.</p>\n\n<p>The Java 8 betas have been around for a while now, and there are numerous articles discussing the proposed APIs. It is supposed to be related later this year, so it seems past time to at least be discussing how and when the much-desired language features will make their way into GWT.</p>\n\n<p>My apologies if this question is answered somewhere else, or if I missed some important piece of information related to it. This would be a great place to have a link to such information, even if it has been answered. Thanks!</p>\n    ","a":"\n<p><strong>EDIT</strong> as of Feb 2015, basic Java 8 support will appear in GWT 2.8, to be released in the coming weeks/months. You can follow the progress at <a href=\"https://github.com/gwtproject/gwt/labels/java8\" rel=\"nofollow\">https://github.com/gwtproject/gwt/labels/java8</a></p>\n\n<p><strong>EDIT</strong> as of Apr 2014, GWT 2.6 supports Java 7, and work is underway to support Java 8 in GWT 2.7, to be released by the summer 2014. GWT 2.7 is likely to only support Java 8 language constructs though, and not emulate any new API (streams, javax.time, etc.)</p>\n\n<hr>\n\n<p>The plan is to first support Java 7: <a href=\"https://github.com/gwtproject/gwt/labels/java7\" rel=\"nofollow\">https://github.com/gwtproject/gwt/labels/java7</a></p>\n\n<p>This involves updating JDT, and this is being <a href=\"https://gwt-review.googlesource.com/2361\" rel=\"nofollow\">worked on</a> (or alternatively, switch to something else entirely; <a href=\"https://groups.google.com/d/msg/gwt-steering/RnYDFmZk-60/TulG46xrITkJ\" rel=\"nofollow\">JetBrains proposed</a> using their parser which already supports Java 8, but GWT also needs a compiler and I don't know what they provide exactly). The next steps are to map new language constructs to JavaScript (strings-in-switch come to mind, as they could directly map to JavaScript without the <code>hashCode</code>-based desugaring that a Java compiler would be doing).</p>\n\n<p>As long as GWT uses JDT for its Java parsing/munging/compiling, Java 8 can only be supported when JDT will support it (at an acceptable level, which is not yet the case AFAICT).</p>\n    "},{"t":"Trouble using ScrollableResults-backed Stream as return type in Spring MVC","l":"http://stackoverflow.com/questions/26324112/trouble-using-scrollableresults-backed-stream-as-return-type-in-spring-mvc","q":"\n\n<hr>\n\n<h3>Important note: this has been accepted as a <a href=\"https://jira.spring.io/browse/SPR-12349\">Spring issue</a> with a target fix version of 4.1.2.</h3>\n\n<hr>\n\n<p>My goal is to achieve O(1) space complexity when generating an HTTP response from Hibernate's <code>ScrollableResults</code>. I want to keep the standard mechanism where a <code>MessageConverter</code> is dispatched to handle an object returned from a <code>@Controller</code>. I have set up the following:</p>\n\n<ol>\n<li><code>MappingJackson2HttpMessageConverter</code> enriched with a <code>JsonSerializer</code> which handles a Java 8 <code>Stream</code>;</li>\n<li>a custom <code>ScrollableResultSpliterator</code> needed to wrap <code>ScrollableResults</code> into a <code>Stream</code>;</li>\n<li><code>OpenSessionInViewInterceptor</code> needed to keep the Hibernate session open within the <code>MessageConverter</code>;</li>\n<li>set <code>hibernate.connection.release_mode</code> to <code>ON_CLOSE</code>;</li>\n<li>ensure that the JDBC connection has the necessary ResultSet holdability: <code>con.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT)</code></li>\n</ol>\n\n<p>Additionally I need a database which supports that kind of holdability. PostgreSQL is such a database and I have no trouble with this.</p>\n\n<p>The final stumbling point I have encountered is the policy used by <code>HibernateTransactionManager</code> on transaction commit: unless the underlying session is \"Hibernate-managed\", it will <code>disconnect()</code> it, closing my cursor along with everything else. Such a policy is useful in some special scenarios, specifically \"conversation-scoped sessions\", which  are far removed from my requirements.</p>\n\n<p>I have managed to work around this with a bad hack: I had to override the offending method with a method which is efectively a copy-paste of the original except for the removed <code>disconnect()</code> call, but it must resort to reflection to access private API.</p>\n\n<pre><code>public class NoDisconnectHibernateTransactionManager extends HibernateTransactionManager\n{\n  private static final Logger logger = LoggerFactory.getLogger(NoDisconnectHibernateTransactionManager.class);\n\n  public NoDisconnectHibernateTransactionManager(SessionFactory sf) { super(sf); }\n\n  @Override\n  protected void doCleanupAfterCompletion(Object transaction) {\n    final JdbcTransactionObjectSupport txObject = (JdbcTransactionObjectSupport) transaction;\n    final Class&lt;?&gt; c = txObject.getClass();\n    try {\n      // Remove the session holder from the thread.\n      if ((Boolean)jailBreak(c.getMethod(\"isNewSessionHolder\")).invoke(txObject))\n        TransactionSynchronizationManager.unbindResource(getSessionFactory());\n\n      // Remove the JDBC connection holder from the thread, if exposed.\n      if (getDataSource() != null)\n        TransactionSynchronizationManager.unbindResource(getDataSource());\n\n      final SessionHolder sessionHolder = (SessionHolder)jailBreak(c.getMethod(\"getSessionHolder\")).invoke(txObject);\n      final Session session = sessionHolder.getSession();\n      if ((Boolean)jailBreak(HibernateTransactionManager.class.getDeclaredField(\"prepareConnection\")).get(this)\n          &amp;&amp; session.isConnected() &amp;&amp; isSameConnectionForEntireSession(session))\n      {\n        // We're running with connection release mode \"on_close\": We're able to reset\n        // the isolation level and/or read-only flag of the JDBC Connection here.\n        // Else, we need to rely on the connection pool to perform proper cleanup.\n        try {\n          final Connection con = ((SessionImplementor) session).connection();\n          DataSourceUtils.resetConnectionAfterTransaction(con, txObject.getPreviousIsolationLevel());\n        }\n        catch (HibernateException ex) {\n          logger.debug(\"Could not access JDBC Connection of Hibernate Session\", ex);\n        }\n      }\n      if ((Boolean)jailBreak(c.getMethod(\"isNewSession\")).invoke(txObject)) {\n        logger.debug(\"Closing Hibernate Session [{}] after transaction\",  session);\n        SessionFactoryUtils.closeSession(session);\n      }\n      else {\n        logger.debug(\"Not closing pre-bound Hibernate Session [{}] after transaction\", session);\n        if (sessionHolder.getPreviousFlushMode() != null)\n          session.setFlushMode(sessionHolder.getPreviousFlushMode());\n      }\n      sessionHolder.clear();\n    }\n    catch (ReflectiveOperationException e) { throw new RuntimeException(e); }\n  }\n\n  static &lt;T extends AccessibleObject&gt; T jailBreak(T o) { o.setAccessible(true); return o; }\n}\n</code></pre>\n\n<p>Since I regard my approach as \"the right way\" to generate ResultSet-backed responses, and since the Streams API makes this approach very convenient, I would like to solve this in a supported way.</p>\n\n<p>Is there a way to get the same behavior without my hack? If not, would this be a good thing to request via Spring's Jira?</p>\n    ","a":"\n<p>Cleaning up. As Marko Topolnik had said <a href=\"https://jira.spring.io/browse/SPR-12349\" rel=\"nofollow\">here</a> </p>\n\n<blockquote>\n  <p>Yes, I missed this part that the holdability setting is only applied when encountering a pre-existing session. This means that my \"idea\" how it could be done is already the way it is done. It also means that my comment about failures doesn't apply: you either want holdability and skipping the session disconnection — or you don't need either. So if you can't get holdability, there is no reason not to disconnect the session at commit, therefore there's no reason to activate the \"allowResultSetAccessAfterCompletion\" in that case.</p>\n</blockquote>\n    "},{"t":"Java 8: Lambda-Streams, Filter by Method with Exception","l":"http://stackoverflow.com/questions/19757300/java-8-lambda-streams-filter-by-method-with-exception","q":"\n\n<p>I have a problem tryingout the Lambda expressions of Java 8.\nUsually it works fine, but now i have methods that throw IOException's. \nIt's best if you look at the code following:</p>\n\n<pre><code>class Bank{\n    ....\n    public Set&lt;String&gt; getActiveAccountNumbers() throws IOException {\n        Stream&lt;Account&gt; s =  accounts.values().stream();\n        s = s.filter(a -&gt; a.isActive());\n        Stream&lt;String&gt; ss = s.map(a -&gt; a.getNumber());\n        return ss.collect(Collectors.toSet());\n    }\n    ....\n}\n\ninterface Account{\n    ....\n    boolean isActive() throws IOException;\n    String getNumber() throws IOException;\n    ....\n}\n</code></pre>\n\n<p>The problem is, it doesn't compile, because i have to catch the possible exceptions of the isActive- and the getNumber-Methods. But even if i explecitely use a try-catch-Block like below, it still doesn't compile because i don't catch the Exception. So either there is a bug in JDK, or i don't know how to catch these Exceptions.</p>\n\n<pre><code>class Bank{\n    ....\n    //Doesn't compile either\n    public Set&lt;String&gt; getActiveAccountNumbers() throws IOException {\n        try{\n            Stream&lt;Account&gt; s =  accounts.values().stream();\n            s = s.filter(a -&gt; a.isActive());\n            Stream&lt;String&gt; ss = s.map(a -&gt; a.getNumber());\n            return ss.collect(Collectors.toSet());\n        }catch(IOException ex){\n        }\n    }\n    ....\n}\n</code></pre>\n\n<p>How can i get it work? Can someone hint me to the right solution?</p>\n    ","a":"\n<p>You must catch the exception <em>before</em> it escapes the lambda:</p>\n\n<pre><code>s = s.filter(a -&gt; try { return a.isActive(); } \n                  catch (IOException e) { throw new UncheckedIOException(e); }});\n</code></pre>\n\n<p>Consider the fact that the lambda isn't evaluated at the place you write it, but at some completely unrelated place, within a JDK class. So that would be the point where that checked exception would be thrown, and at that place it isn't declared.</p>\n\n<p>Yes, checked exceptions have always been a pain, and now with the sexy and concise lambda syntax, they disrupt the program flow even worse.</p>\n\n<hr>\n\n<p>In my projects I deal with this issue without wrapping; instead I use a method which effectively defuses compiler's checking of exceptions. Needless to say, this should be handled with care and everybody on the project must be aware that a checked exception may appear where it is not declared. This is the plumbing code:</p>\n\n<pre><code>public static &lt;T&gt; T uncheckCall(Callable&lt;T&gt; callable) {\n  try { return callable.call(); }\n  catch (Exception e) { return sneakyThrow(e); }\n}\npublic static void uncheckRun(RunnableExc r) {\n  try { r.run(); } catch (Exception e) { sneakyThrow(e); }\n}\npublic interface RunnableExc { void run() throws Exception; }\n\n\npublic static &lt;T&gt; T sneakyThrow(Throwable e) {\n  return Util.&lt;RuntimeException, T&gt;sneakyThrow0(e);\n}\nprivate static &lt;E extends Throwable, T&gt; T sneakyThrow0(Throwable t) throws E { throw (E)t; }\n</code></pre>\n\n<p>Your example would be written as</p>\n\n<pre><code>return s.filter(a -&gt; uncheckCall(a::isActive))\n        .map(Account::getNumber)\n        .collect(toSet());\n</code></pre>\n\n<p>and you can expect to get an <code>IOException</code> thrown in your face, even though <code>collect</code> does not declare it. In <em>most, but not all</em> real-life cases you would want to just rethrow the exception, anyway, and handle it as a generic failure. In all those cases, nothing is lost in clarity or correctness. Just beware of those other cases, where you would actually want to react to the exception on the spot. The developer will not be made aware by the compiler that there is an <code>IOException</code> to catch there and the compiler will in fact complain if you try to catch it because we have fooled it into believing that no such exception can be thrown.</p>\n    "},{"t":"Java 8 find first element by predicate","l":"http://stackoverflow.com/questions/23696317/java-8-find-first-element-by-predicate","q":"\n\n<p>I've just started playing with Java 8 lambdas and I'm trying to implement some of the things that I'm used to in functional languages.</p>\n\n<p>For example, most functional languages have some kind of find function that operates on sequences, or lists that returns the first element, for which the predicate is <code>true</code>. The only way I can see to achieve this in Java 8 is:</p>\n\n<pre><code>lst.stream()\n    .filter(x -&gt; x &gt; 5)\n    .findFirst()\n</code></pre>\n\n<p>However this seems inefficient to me, as the filter will scan the whole list, at least to my understanding (which could be wrong). Is there a better way?  </p>\n    ","a":"\n<p>No filter does not scan the whole stream. It's an intermediate operation, which returns a lazy stream (actually all intermediate operations return a lazy stream). To convince you, you can simply do:</p>\n\n<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,10,3,7,5));\nint a = list.stream().filter(x -&gt; {System.out.println(\"filtered\"); return x &gt; 5;}).findFirst().get();\nSystem.out.println(a);\n</code></pre>\n\n<p>Which outputs:</p>\n\n<pre><code>filtered\nfiltered\n10\n</code></pre>\n\n<p>You see that only the two first elements of the stream are actually processed.</p>\n\n<p>So you can go with your approach which is perfectly fine.</p>\n    "},{"t":"A program made with Java 8 can be run on Java 7?","l":"http://stackoverflow.com/questions/22610400/a-program-made-with-java-8-can-be-run-on-java-7","q":"\n\n<p>Hi, I am a little confused.</p>\n\n<p>1.- Oracle says Java 8 is highly compatible with Java 7 (backward). But, what possibilities exist that Java 8 program can be run on Java 7 successfully (SE/EE)?</p>\n\n<p>2.- If point one was true, Java 8 applications will be deployed and executed on a Java 7 server support? for example, Tomcat 8 or WildFly?</p>\n    ","a":"\n<p>In general, no.</p>\n\n<p>The backwards compatibility means that you can run Java 7 program on Java 8 runtime, not the other way around.</p>\n\n<p>There are several reasons for that:</p>\n\n<ul>\n<li><p>Bytecode is versioned and JVM checks if it supports the version it finds in .class files. </p></li>\n<li><p>Some language constructs cannot be expressed in previous versions of bytecode.</p></li>\n<li><p>There are new classes and methods in newer JRE's which won't work with older ones.</p></li>\n</ul>\n\n<p>If you really, really want (tip: you don't), you can force the compiler to treat the source as one version of Java and emit bytecode for another, using something like this:</p>\n\n<pre><code>javac -source 1.8 -target 1.7 MyClass.java\n</code></pre>\n\n<p>(<a href=\"http://maven.apache.org/plugins/maven-compiler-plugin/examples/set-compiler-source-and-target.html\">the same for Maven</a>), and compile against JDK7, but in practice it will more often not work than work. <strong>I recommend you don't.</strong> *<em>EDIT:</em>* JDK 8 apparently doesn't support this exact combination, so this won't work. Some other combinations of versions do work.</p>\n\n<p>There are also programs to convert newer Java programs to work on older JVM's. For converting Java 8 to 5-7, you can try <a href=\"https://github.com/orfjackal/retrolambda\">https://github.com/orfjackal/retrolambda</a> To get lower than 5, you can pick one of these: <a href=\"http://en.wikipedia.org/wiki/Java_backporting_tools\">http://en.wikipedia.org/wiki/Java_backporting_tools</a></p>\n\n<p>None of these hacks will give you new Java 8 classes and methods, including functional programming support for collections, streams, time API, unsigned API, and so on. So I'd say it's not worth it.</p>\n\n<p>Or, since you want to run your Java 8 JEE applications on an application server, just run your entire server on Java 8, it may work. </p>\n    "},{"t":"Why is generic of a return type erased when there is an unchecked conversion of a method parameter in Java 8?","l":"http://stackoverflow.com/questions/30918308/why-is-generic-of-a-return-type-erased-when-there-is-an-unchecked-conversion-of","q":"\n\n<p>Consider the following code sample:</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List list = new ArrayList&lt;Integer&gt;();\n        String response = getProducer(list).get();\n    }\n    static Producer&lt;String&gt; getProducer(List&lt;Integer&gt; list) {\n        return new Producer&lt;String&gt;();\n    }\n}\nclass Producer&lt;T&gt; {\n    T get() {\n        return null;\n    }\n}\n</code></pre>\n\n<p>When compiled in Java&nbsp;7 it just produces an expected warning for <code>getProducer(list)</code>:</p>\n\n<blockquote>\n  <p>Warning:(7, 39) java: unchecked conversion\n  required: <code>java.util.List&lt;java.lang.Integer&gt;</code>\n  found:    <code>java.util.List</code></p>\n</blockquote>\n\n<p>However, when compiled in Java&nbsp;8 it produces the following error for the <code>response = getProducer(list).get()</code> assignment:</p>\n\n<blockquote>\n  <p>Error:(7, 48) java: incompatible types: <code>java.lang.Object</code> cannot be converted to <code>java.lang.String</code></p>\n</blockquote>\n\n<p>So apparently the type returned from <code>getProducer(list)</code> is not <code>Producer&lt;String&gt;</code>, but erased <code>Producer</code> (which is also confirmed by means of the 'extract variable' feature in the IDE). This is very puzzling because <code>getProducer</code> method always returns <code>Producer&lt;String&gt;</code>.</p>\n\n<p>Oddly enough it could be fixed by avoiding unchecked conversion while calling <code>getProducer</code> method, either by:</p>\n\n<ul>\n<li>Change parameter type of <code>getProducer</code> from <code>List&lt;Integer&gt;</code> to <code>List</code></li>\n<li>Change type of <code>list</code> variable from <code>List</code> to <code>List&lt;Integer&gt;</code></li>\n</ul>\n\n<h2>Updates</h2>\n\n<ul>\n<li>Java used is Oracle JDK 1.8.0_40</li>\n<li>I have also tried using source and target options from 1.5 through 1.7 with the Java 8 compiler and the result was the same.</li>\n</ul>\n\n<h2>Questions</h2>\n\n<ul>\n<li>How could the generic type of the passed <strong>argument</strong> affect a generic type of the method <strong>return value</strong> while the generic type of the return value is fixed in the method signature?</li>\n<li>Why is there such a backward-incompatible change in behavior between Java&nbsp;7 and Java&nbsp;8?</li>\n</ul>\n    ","a":"\n<p>This looks like a known compatibility issue reported <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8026329\">here</a> and <a href=\"http://www.oracle.com/technetwork/java/javase/8-compatibility-guide-2156366.html#A999198\">here</a>.</p>\n\n<p>From the second link:</p>\n\n<blockquote>\n  <p>The following code which compiled, with warnings, in JDK 7 will not\n  compile in JDK 8:</p>\n</blockquote>\n\n<pre><code>import java.util.List;\nclass SampleClass {\n\n     static class Baz&lt;T&gt; {\n         public static List&lt;Baz&lt;Object&gt;&gt; sampleMethod(Baz&lt;Object&gt; param) {\n             return null;\n         }\n     }\n\n     private static void bar(Baz arg) {\n         Baz element = Baz.sampleMethod(arg).get(0);\n     }\n}\n</code></pre>\n\n<blockquote>\n  <p>Compiling this code in JDK 8 produces the following error:</p>\n  \n  <p>SampleClass.java:12: error:incompatible types: Object cannot be\n  converted to Baz</p>\n\n<pre><code>Baz element = Baz.sampleMethod(arg).get(0);\n</code></pre>\n  \n  <p>Note: SampleClass.java uses unchecked or unsafe operations. Note:\n  Recompile with -Xlint:unchecked for details. 1 error</p>\n</blockquote>\n\n<p>Deriving from this, the OP's code can be fixed by replacing this line (the type declartion on the right hand side threw me off - I read it as a typed array list which it is not):</p>\n\n<pre><code>List list = new ArrayList&lt;Integer&gt;();\n</code></pre>\n\n<p>with</p>\n\n<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n</code></pre>\n\n<p>which will not result in type being being erased from return type of method <code>getProducer(List&lt;Integer&gt; list)</code></p>\n\n<p>Quote from second link again:</p>\n\n<blockquote>\n  <p>In this example, a raw type is being passed to the\n  <code>sampleMethod(Baz&lt;Object&gt;)</code> method which is applicable by subtyping (see\n  the JLS, Java SE 7 Edition, section 15.12.2.2). An unchecked\n  conversion is necessary for the method to be applicable, so its return\n  type is erased (see the JLS, Java SE 7 Edition, section 15.12.2.6). In\n  this case the return type of <code>sampleMethod(Baz&lt;Object&gt;)</code> is\n  <code>java.util.List</code> instead of <code>java.util.List&lt;Baz&lt;Object&gt;&gt;</code> and thus the\n  return type of <code>get(int)</code> is <code>Object</code>, which is not assignment-compatible\n  with <code>Baz</code>.</p>\n</blockquote>\n    "},{"t":"What is difference between Collection.stream().forEach(..) and Collection.forEach(..)","l":"http://stackoverflow.com/questions/23218874/what-is-difference-between-collection-stream-foreach-and-collection-foreac","q":"\n\n<p>I understand that with .stream() I can use chain operations like .filter() or use parallel stream. But what is difference if I need execute one small operation? (for example print)</p>\n\n<pre><code>collection.stream().forEach(System.out::println);\ncollection.forEach(System.out::println);\n</code></pre>\n    ","a":"\n<p>For simple cases such as the one illustrated, they are mostly the same. However, there are a number of subtle differences that might be significant.</p>\n\n<p>One issue is with ordering. With <code>Stream.forEach</code>, the order is <strong>undefined</strong>. It's unlikely to occur with sequential streams, still, it's within the specification for <code>Stream.forEach</code> to execute in some arbitrary order. This does occur frequently in parallel streams. By contrast, <code>Iterable.forEach</code> is always executed in the iteration order of the <code>Iterable</code>, if one is specified.</p>\n\n<p>Another issue is with side effects. The action specified in <code>Stream.forEach</code> is required to be <strong>non-interfering</strong>. (See the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#NonInterference\">java.util.stream package doc</a>.) <code>Iterable.forEach</code> potentially has fewer restrictions. For the collections in <code>java.util</code>, <code>Iterable.forEach</code> will generally use that collection's <code>Iterator</code>, most of which are designed to be <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#fail-fast\">fail-fast</a> and which will throw <code>ConcurrentModificationException</code> if the collection is structurally modified during the iteration. However, modifications that aren't structural <strong>are</strong> allowed during iteration. For example, the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html\">ArrayList class documentation</a> says \"merely setting the value of an element is not a structural modification.\" Thus, the action for <code>ArrayList.forEach</code> is allowed to set values in the underlying <code>ArrayList</code> without problems.</p>\n\n<p>The concurrent collections are yet again different. Instead of fail-fast, they are designed to be <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#Weakly\">weakly consistent</a>. The full definition is at that link. Briefly, though, consider <code>ConcurrentLinkedDeque</code>. The action passed to its <code>forEach</code> method <strong>is</strong> allowed to modify the underlying deque, even structurally, and <code>ConcurrentModificationException</code> is never thrown. However, the modification that occurs might or might not be visible in this iteration. (Hence the \"weak\" consistency.)</p>\n\n<p>Still another difference is visible if <code>Iterable.forEach</code> is iterating over a synchronized collection. On such a collection, <code>Iterable.forEach</code> takes the collection's lock once and holds it across all the calls to the action method. The <code>Stream.forEach</code> call uses the collection's spliterator, which does not lock, and which relies on the prevailing rule of non-interference. The collection backing the stream could be modified during iteration, and if it is, a <code>ConcurrentModificationException</code> or inconsistent behavior could result.</p>\n    "},{"t":"Is this a bug in Files.lines(), or am I misunderstanding something about parallel streams?","l":"http://stackoverflow.com/questions/28259636/is-this-a-bug-in-files-lines-or-am-i-misunderstanding-something-about-paralle","q":"\n\n<p>Environment: Ubuntu x86_64 (14.10), Oracle JDK 1.8u25</p>\n\n<p>I try and use a parallel stream of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-\"><code>Files.lines()</code></a> but I want to <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#skip-long-\"><code>.skip()</code></a> the first line (it's a CSV file with a header). Therefore I try and do this:</p>\n\n<pre><code>try (\n    final Stream&lt;String&gt; stream = Files.lines(thePath, StandardCharsets.UTF_8)\n        .skip(1L).parallel();\n) {\n    // etc\n}\n</code></pre>\n\n<p>But then one column failed to parse to an int...</p>\n\n<p>So I tried some simple code. The file is question is dead simple:</p>\n\n<pre><code>$ cat info.csv \nstartDate;treeDepth;nrMatchers;nrLines;nrChars;nrCodePoints;nrNodes\n1422758875023;34;54;151;4375;4375;27486\n$\n</code></pre>\n\n<p>And the code is equally simple:</p>\n\n<pre><code>public static void main(final String... args)\n{\n    final Path path = Paths.get(\"/home/fge/tmp/dd/info.csv\");\n    Files.lines(path, StandardCharsets.UTF_8).skip(1L).parallel()\n        .forEach(System.out::println);\n}\n</code></pre>\n\n<p>And I <em>systematically</em> get the following result (OK, I have only run it something around 20 times):</p>\n\n<pre><code>startDate;treeDepth;nrMatchers;nrLines;nrChars;nrCodePoints;nrNodes\n</code></pre>\n\n<p>What am I missing here?</p>\n\n<hr>\n\n<p><strong>EDIT</strong> It seems like the problem, or misunderstanding, is much more rooted than that (the two examples below were cooked up by a fellow on FreeNode's ##java):</p>\n\n<pre><code>public static void main(final String... args)\n{\n    new BufferedReader(new StringReader(\"Hello\\nWorld\")).lines()\n        .skip(1L).parallel()\n        .forEach(System.out::println);\n\n    final Iterator&lt;String&gt; iter\n        = Arrays.asList(\"Hello\", \"World\").iterator();\n    final Spliterator&lt;String&gt; spliterator\n        = Spliterators.spliteratorUnknownSize(iter, Spliterator.ORDERED);\n    final Stream&lt;String&gt; s\n        = StreamSupport.stream(spliterator, true);\n\n    s.skip(1L).forEach(System.out::println);\n}\n</code></pre>\n\n<p>This prints:</p>\n\n<pre><code>Hello\nHello\n</code></pre>\n\n<p>Uh.</p>\n\n<p>@Holger suggested that this happens for any stream which is <code>ORDERED</code> and not <code>SIZED</code> with this other sample:</p>\n\n<pre><code>Stream.of(\"Hello\", \"World\")\n    .filter(x -&gt; true)\n    .parallel()\n    .skip(1L)\n    .forEach(System.out::println);\n</code></pre>\n\n<p>Also, it stems from all the discussion which already took place that the problem (if it is one?) is with <code>.forEach()</code> (as <a href=\"http://stackoverflow.com/questions/28259636/is-this-a-bug-in-files-lines-or-am-i-misunderstanding-something-about-paralle#comment44876969_28259636\">@SotiriosDelimanolis first pointed out</a>).</p>\n    ","a":"\n<p>To quickly answer the question: <strong>The observed behavior is intended!</strong> There is no bug and all is happening according to the documentation. But let it be said, that this behavior should be documented and communicated better. It should be made more obvious how <code>forEach</code> ignores ordering.</p>\n\n<p>I'll first cover the <strong>concepts</strong> which allow the observed behavior. This provides the background for dissecting one of the <strong>examples</strong> given in the question. I will do this on a <strong>high level</strong> and then again on a very <strong>low level</strong>.</p>\n\n<p><strong>[TL;DR: Read on its own, the <em>high level</em> explanation will give a rough answer.]</strong></p>\n\n<h2>Concept</h2>\n\n<p>Instead of talking about <code>Stream</code>s, which is the type operated on or returned by stream-related methods, let's talk about <em>stream operations</em> and <em>stream pipelines</em>. The method calls <code>lines</code>, <code>skip</code> and <code>parallel</code> are stream operations which build a stream pipeline[1] and - as others have noted - that pipeline is processed as a whole when the terminal operation <code>forEach</code> is called[2].</p>\n\n<p>A pipeline could be thought of as a series of operations which, one after another, are executed on the whole stream (e.g. filter all elements, map remaining elements to numbers, sum all numbers). <strong>But this is misleading!</strong> A better metaphor is that the terminal operation pulls single elements through each operation[3] (e.g. get the next unfiltered element, map it, add it to sum, request next element). Some intermediate operations may need to traverse several (e.g. <code>skip</code>) or maybe even all (e.g. <code>sort</code>) elements before they can return the requested next element and this is one of the sources for state in an operation.</p>\n\n<p>Each operation signals its characteristics with these <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/StreamOpFlag.java\"><code>StreamOpFlag</code></a>s:</p>\n\n<ul>\n<li><code>DISTINCT</code></li>\n<li><code>SORTED</code></li>\n<li><code>ORDERED</code></li>\n<li><code>SIZED</code></li>\n<li><code>SHORT_CIRCUIT</code></li>\n</ul>\n\n<p>They are combined across the stream source, the intermediate operations and the terminal operation and make up the characteristics of the pipeline (as a whole), which are then used for optimizations[4]. Similarly, whether a pipeline is executed in parallel or not is a property of the entire pipeline[5].</p>\n\n<p>So whenever you are making assumptions regarding these characteristics, you have to look carefully at <strong>all operations building the pipeline, regardless of the order in which they are applied</strong>, and what guarantees they make. When doing so keep in mind how the terminal operation pulls each individual element through the pipeline.</p>\n\n<h2>Example</h2>\n\n<p>Let's look at this special case:</p>\n\n<pre><code>BufferedReader fooBarReader = new BufferedReader(new StringReader(\"Foo\\nBar\"));\nfooBarReader.lines()\n        .skip(1L)\n        .parallel()\n        .forEach(System.out::println);\n</code></pre>\n\n<h3>High Level</h3>\n\n<p>Regardless of whether your stream source is ordered or not (it is), by calling <code>forEach</code> (instead of <code>forEachOrdered</code>) you declare that <strong>order doesn't matter to you</strong>[6], which effectively reduces <code>skip</code> from \"skip the first <em>n</em> elements\" to \"skip any <em>n</em> elements\"[7] (because without order the former becomes meaningless).</p>\n\n<p>So you give the pipeline the right to ignore order if that promises a speedup. For parallel execution it apparently thinks so, which is why you get the observed output. Hence <strong>what you observe is the intended behavior</strong> and no bug.</p>\n\n<p>Note that this <strong>does not conflict</strong> with <code>skip</code> being stateful! As described above, being stateful does not imply that it somehow caches the whole stream (minus the skipped elements) and everything that follows is executed on these elements. It just means that the operation has some state - namely the number of skipped elements (well, it's not actually <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/StreamSpliterators.java#609\">that easy</a> but with my limited understanding of what's going on, I'd say it's a fair simplification).</p>\n\n<h3>Low Level</h3>\n\n<p>Let's look at it in more detail:</p>\n\n<ol>\n<li><code>BufferedReader.lines</code> creates the <code>Stream</code>, lets call it <code>_lines</code>:\n<ul>\n<li><a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/io/BufferedReader.java#590\">creates an ordered <code>Spliterator</code></a></li>\n<li>hands it to <code>StreamSupport.stream</code>, which creates a <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ReferencePipeline.java#ReferencePipeline.Head\"><code>ReferencePipeline.Head</code></a> and transforms the spliterator flag to a stream op flag</li>\n</ul></li>\n<li><code>.skip</code> creates a new <code>Stream</code>, let's call it <code>_skip</code>:\n<ul>\n<li>calls <code>ReferencePipeline.skip</code></li>\n<li>which constructs a \"slice\" operation (generalization of skip &amp; limit) with <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/SliceOps.java#SliceOps.makeRef%28java.util.stream.AbstractPipeline%2Clong%2Clong%29\"><code>SliceOps.makeRef</code></a></li>\n<li>this creates an anonymous instance of <code>ReferencePipeline.StatefulOp</code>, which references <code>_lines</code> as its source</li>\n</ul></li>\n<li><code>.parallel</code> sets the parallel flag for the entire pipeline as described above</li>\n<li><code>.forEach</code> actually starts the execution</li>\n</ol>\n\n<p>So let's see how the pipeline is executed:</p>\n\n<ol>\n<li>Calling <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ReferencePipeline.java#ReferencePipeline.forEach%28java.util.function.Consumer%29\"><code>_skip.forEach</code> </a> creates a <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ForEachOps.java#ForEachOps.ForEachOp\"><code>ForEachOp</code></a> (let's call it <code>_forEach</code>) and hands it to <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/AbstractPipeline.java#AbstractPipeline.evaluate%28java.util.stream.TerminalOp%29\"><code>_skip.evaluate</code></a>, which does two things:\n<ol>\n<li>calls <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/AbstractPipeline.java#AbstractPipeline.sourceSpliterator%28int%29\"><code>sourceSpliterator</code></a> to create a spliterator around the source for this pipeline stage:\n<ul>\n<li>calls <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/SliceOps.java#133\"><code>opEvaluateParallelLazy</code></a> on itself (as it turns out)</li>\n<li>this determines that the stream is unordered and <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/SliceOps.java#129\">creates an <code>UnorderedSliceSpliterator</code></a> (let's call it <code>_sliceSpliterator</code>) with <code>skip = 1</code> and no limit.</li>\n</ul></li>\n<li>calls <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ForEachOps.java#ForEachOps.ForEachOp.evaluateParallel%28java.util.stream.PipelineHelper%2Cjava.util.Spliterator%29\"><code>_forEach.evaluateParallel</code></a> which creates a <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ForEachOps.java#ForEachOps.ForEachTask\"><code>ForEachTask</code></a> (because it is unordered; let's call it <code>_forEachTask</code>) and invokes it</li>\n</ol></li>\n<li>In <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ForEachOps.java#ForEachOps.ForEachTask.compute%28%29\"><code>_forEachTask.compute</code></a> the task splits off the first 1024 lines, creates a new task for it (let's call it <code>_forEachTask2</code>), realizes there are no lines left and finishes.</li>\n<li>Inside the fork join pool, <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ForEachOps.java#ForEachOps.ForEachTask.compute%28%29\"><code>_forEachTask2.compute</code></a> gets called, vainly tries to split again and <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/ForEachOps.java#290\">finally starts copying its elements into the sink</a> (a stream-aware wrapper around the <code>System.out.println</code>) by calling <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/AbstractPipeline.java#AbstractPipeline.copyInto%28java.util.stream.Sink%2Cjava.util.Spliterator%29\"><code>_skip.copyInto</code></a>.</li>\n<li>This essentially delegates the task to the the specified spliterator. <strong>This is <code>_sliceSpliterator</code> which was created above!</strong> So <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/StreamSpliterators.java#1022\"><code>_sliceSpliterator.forEachRemaining</code></a> is responsible for handing the non-skipped elements to the println-sink:\n<ol>\n<li>it gets a chunk (in this case all) of the lines into a buffer and counts them</li>\n<li>it tries to request as many permits (I assume due to parallelization) via <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/StreamSpliterators.java#StreamSpliterators.UnorderedSliceSpliterator.acquirePermits%28long%29\"><code>acquirePermits</code></a></li>\n<li>with two elements in the source and one to be skipped, there is only one permit which it acquires (in general let's say <em>n</em>)</li>\n<li>it lets the buffer put the first <em>n</em> elements (so in this case only the first) into the sink</li>\n</ol></li>\n</ol>\n\n<p><strong>So <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/StreamSpliterators.java#1038\"><code>UnorderedSliceSpliterator.OfRef.forEachRemaining</code></a> is where the order is finally and truly ignored.</strong> I did not compare this to the ordered variant but this are my assumption why it is done this way:</p>\n\n<ul>\n<li>under parallelization shoveling the spliterator's elements into the buffer may interleave with other tasks doing the same</li>\n<li>this will make tracking their order extremely hard</li>\n<li>doing that or preventing interleaving degrades performance and is pointless if order is irrelevant</li>\n<li>if the order is lost, there is little else to do but to process the first <em>n</em> permitted elements</li>\n</ul>\n\n<p>Any questions? ;) Sorry for going on for so long. Maybe I should leave out the details and make a blog post of it....</p>\n\n<h2>Sources</h2>\n\n<p>[1] <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\"><code>java.util.stream</code> - Stream operations and pipelines</a>:</p>\n\n<blockquote>\n  <p>Stream operations are divided into <em>intermediate</em> and <em>terminal</em> operations, and are combined to form <em>stream pipelines</em>.</p>\n</blockquote>\n\n<p>[2] <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\"><code>java.util.stream</code> - Stream operations and pipelines</a>:</p>\n\n<blockquote>\n  <p>Traversal of the pipeline source does not begin until the terminal operation of the pipeline is executed.</p>\n</blockquote>\n\n<p>[3] This metaphor represents my understanding of streams. The main source, beside the code, is this quote from <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\"><code>java.util.stream</code> - Stream operations and pipelines</a> (highlighting mine):</p>\n\n<blockquote>\n  <p>Processing streams lazily allows for significant efficiencies; in a pipeline such as the filter-map-sum example above, filtering, mapping, and summing can be fused into a single pass on the data, with minimal intermediate state. Laziness also allows avoiding examining all the data when it is not necessary; for operations such as \"find the first string longer than 1000 characters\", it is only necessary to examine just enough strings to find one that has the desired characteristics without examining all of the strings available from the source.</p>\n</blockquote>\n\n<p>[4] <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/StreamOpFlag.java\"><code>java.util.stream.StreamOpFlag</code></a>:</p>\n\n<blockquote>\n  <p>At each stage of the pipeline, a combined stream and operation flags can be calculated [... <em>jadda, jadda, jadda about how flags are combined across source, intermediate and terminal operations</em> ...] to produce the flags output from the pipeline. Those flags can then be used to apply optimizations.</p>\n</blockquote>\n\n<p>In code you can see this in <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/AbstractPipeline.java#AbstractPipeline.0combinedFlags\"><code>AbstractPipeline.combinedFlags</code></a>, which is set during construction (and on a few other occurrences) by combining the flag of the previous and the new operation.</p>\n\n<p>[5] <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\"><code>java.util.stream</code> - Parallelism</a> (to which I can not directly link - scroll down a little):</p>\n\n<blockquote>\n  <p>When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the orientation of the stream on which it is invoked.</p>\n</blockquote>\n\n<p>In code you can see this is in <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/AbstractPipeline.java#AbstractPipeline.sequential%28%29\"><code>AbstractPipeline.sequential</code>, <code>parallel</code></a>, and <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/stream/AbstractPipeline.java#AbstractPipeline.isParallel%28%29\"><code>isParallel</code></a>, which set/check a boolean flag on the stream source, making it irrelevant when the setters are called while constructing a stream.</p>\n\n<p>[6] <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-\">java.util.stream.Stream.forEach</a>:</p>\n\n<blockquote>\n  <p>Performs an action for each element of this stream. [...] The behavior of this operation is explicitly nondeterministic.</p>\n</blockquote>\n\n<p>Contrast this with <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEachOrdered-java.util.function.Consumer-\">java.util.stream.Stream.forEachOrdered</a>:</p>\n\n<blockquote>\n  <p>Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order. </p>\n</blockquote>\n\n<p>[7] This is also not clearly documented but my interpretation of this comment on <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#skip-long-\"><code>Stream.skip</code></a> (heavily shortened by me):</p>\n\n<blockquote>\n  <p>[...] skip() [...] can be quite expensive on ordered parallel pipelines [...] since skip(n) is constrained to skip not just any n elements, but the first n elements in the encounter order. [...] [R]emoving the ordering constraint [...] may result in significant speedups of skip() in parallel pipelines</p>\n</blockquote>\n    "},{"t":"Reflection type inference on Java 8 Lambdas","l":"http://stackoverflow.com/questions/21887358/reflection-type-inference-on-java-8-lambdas","q":"\n\n<p>I was experimenting with the new Lambdas in Java 8, and I am looking for a way to use reflection on the lambda classes to get the return type of a lambda function. I am especially interested in cases where the lambda implements a generic superinterface. In the code example below, <code>MapFunction&lt;F, T&gt;</code> is the generic superinterface, and I am looking for a way to find out what type binds to the generic parameter <code>T</code>.</p>\n\n<p>While Java throws away a lot of generic type information after the compiler, subclasses (and anonymous subclasses) of generic superclasses and generic superinterfaces did preserve that type information. Via reflection, these types were accessible. In the example below <em>(case 1)</em>, reflection tells my that the <code>MyMapper</code> implementation of <code>MapFunction</code> binds <code>java.lang.Integer</code> to the generic type parameter <code>T</code>.</p>\n\n<p>Even for subclasses that are themselves generic, there are certain means to find out what binds to a generic parameter, if some others are known. Consider <em>case 2</em> in the example below, the <code>IdentityMapper</code> where both <code>F</code> and <code>T</code> bind to the same type. When we know that, we know the type <code>F</code> if we know the parameter type <code>T</code> (which in my case we do).</p>\n\n<p>The question is now, how can I realize something similar for the Java 8 lambdas? Since they are actually not regular subclasses of the generic superinterface, the above described method does not work.\nSpecifically, can I figure out that the <code>parseLambda</code> binds <code>java.lang.Integer</code> to <code>T</code>, and the <code>identityLambda</code> binds the same to <code>F</code> and <code>T</code>?</p>\n\n<p>PS: In theory it should possible to decompile the lambda code and then use an embedded compiler (like the JDT) and tap into its type inference. I hope that there is a simpler way to do this ;-)</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>/**\n * The superinterface.\n */\npublic interface MapFunction&lt;F, T&gt; {\n\n    T map(F value);\n}\n\n/**\n * Case 1: A non-generic subclass.\n */\npublic class MyMapper implements MapFunction&lt;String, Integer&gt; {\n\n    public Integer map(String value) {\n        return Integer.valueOf(value);\n    }\n}\n\n/**\n * A generic subclass\n */\npublic class IdentityMapper&lt;E&gt; implements MapFunction&lt;E, E&gt; {\n\n    public E map(E value) {\n        return value;\n    }\n\n}\n\n/**\n * Instantiation through lambda\n */\n\npublic MapFunction&lt;String, Integer&gt; parseLambda = (String str) -&gt; { return Integer.valueOf(str); }\n\npublic MapFunction&lt;E, E&gt; identityLambda = (value) -&gt; { return value; }\n\n\npublic static void main(String[] args)\n{\n    // case 1\n    getReturnType(MyMapper.class);    // -&gt; returns java.lang.Integer\n\n    // case 2\n    getReturnTypeRelativeToParameter(IdentityMapper.class, String.class);    // -&gt; returns java.lang.String\n}\n\nprivate static Class&lt;?&gt; getReturnType(Class&lt;?&gt; implementingClass)\n{\n    Type superType = implementingClass.getGenericInterfaces()[0];\n\n    if (superType instanceof ParameterizedType) {\n        ParameterizedType parameterizedType = (ParameterizedType) superType;\n        return (Class&lt;?&gt;) parameterizedType.getActualTypeArguments()[1];\n    }\n    else return null;\n}\n\nprivate static Class&lt;?&gt; getReturnTypeRelativeToParameter(Class&lt;?&gt; implementingClass, Class&lt;?&gt; parameterType)\n{\n    Type superType = implementingClass.getGenericInterfaces()[0];\n\n    if (superType instanceof ParameterizedType) {\n        ParameterizedType parameterizedType = (ParameterizedType) superType;\n        TypeVariable&lt;?&gt; inputType = (TypeVariable&lt;?&gt;) parameterizedType.getActualTypeArguments()[0];\n        TypeVariable&lt;?&gt; returnType = (TypeVariable&lt;?&gt;) parameterizedType.getActualTypeArguments()[1];\n\n        if (inputType.getName().equals(returnType.getName())) {\n            return parameterType;\n        }\n        else {\n            // some logic that figures out composed return types\n        }\n    }\n\n    return null;\n}\n</code></pre>\n    ","a":"\n<p>I have found a way of doing it for serializable lambdas. All my lambdas are serializable, to that works.</p>\n\n<p>Thanks, Holger, for pointing me to the <code>SerializedLambda</code>.</p>\n\n<p>The generic parameters are captured in the lambda's synthetic static method and can be retrieved from there. Finding the static method that implements the lambda is possible with the information from the <code>SerializedLambda</code></p>\n\n<p>The steps are as follows:</p>\n\n<ol>\n<li>Get the SerializedLambda via the write replacement method that is auto-generated for all serializable lambdas</li>\n<li>Find the class that contains the lambda implementation (as a synthetic static method)</li>\n<li>Get the <code>java.lang.reflect.Method</code> for the synthetic static method</li>\n<li>Get generic types from that <code>Method</code></li>\n</ol>\n\n<hr>\n\n<p><strong>UPDATE:</strong> Apparently, this does not work with all compilers. I have tried it with the compiler of Eclipse Luna (works) and the Oracle javac (does not work).</p>\n\n<hr>\n\n<pre><code>// sample how to use\npublic static interface SomeFunction&lt;I, O&gt; extends java.io.Serializable {\n\n    List&lt;O&gt; applyTheFunction(Set&lt;I&gt; value);\n}\n\npublic static void main(String[] args) throws Exception {\n\n    SomeFunction&lt;Double, Long&gt; lambda = (set) -&gt; Collections.singletonList(set.iterator().next().longValue());\n\n    SerializedLambda sl = getSerializedLambda(lambda);      \n    Method m = getLambdaMethod(sl);\n\n    System.out.println(m);\n    System.out.println(m.getGenericReturnType());\n    for (Type t : m.getGenericParameterTypes()) {\n        System.out.println(t);\n    }\n\n    // prints the following\n    // (the method) private static java.util.List test.ClassWithLambdas.lambda$0(java.util.Set)\n    // (the return type, including *Long* as the generic list type) java.util.List&lt;java.lang.Long&gt;\n    // (the parameter, including *Double* as the generic set type) java.util.Set&lt;java.lang.Double&gt;\n</code></pre>\n\n<hr>\n\n<pre><code>// getting the SerializedLambda\npublic static SerializedLambda getSerializedLambda(Object function) {\n    if (function == null || !(function instanceof java.io.Serializable)) {\n        throw new IllegalArgumentException();\n    }\n\n    for (Class&lt;?&gt; clazz = function.getClass(); clazz != null; clazz = clazz.getSuperclass()) {\n        try {\n            Method replaceMethod = clazz.getDeclaredMethod(\"writeReplace\");\n            replaceMethod.setAccessible(true);\n            Object serializedForm = replaceMethod.invoke(function);\n\n            if (serializedForm instanceof SerializedLambda) {\n                return (SerializedLambda) serializedForm;\n            }\n        }\n        catch (NoSuchMethodError e) {\n            // fall through the loop and try the next class\n        }\n        catch (Throwable t) {\n            throw new RuntimeException(\"Error while extracting serialized lambda\", t);\n        }\n    }\n\n    throw new Exception(\"writeReplace method not found\");\n}\n</code></pre>\n\n<hr>\n\n<pre><code>// getting the synthetic static lambda method\npublic static Method getLambdaMethod(SerializedLambda lambda) throws Exception {\n    String implClassName = lambda.getImplClass().replace('/', '.');\n    Class&lt;?&gt; implClass = Class.forName(implClassName);\n\n    String lambdaName = lambda.getImplMethodName();\n\n    for (Method m : implClass.getDeclaredMethods()) {\n        if (m.getName().equals(lambdaName)) {\n            return m;\n        }\n    }\n\n    throw new Exception(\"Lambda Method not found\");\n}\n</code></pre>\n    "},{"t":"Should I always use a parallel stream when possible?","l":"http://stackoverflow.com/questions/20375176/should-i-always-use-a-parallel-stream-when-possible","q":"\n\n<p>With Java 8 and lambdas it's easy to iterate over collections as streams. Two examples from <a href=\"http://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html\">the docs</a>, the second one using parallelStream:</p>\n\n<pre><code>myShapesCollection.stream()\n.filter(e -&gt; e.getColor() == Color.RED)\n.forEach(e -&gt; System.out.println(e.getName()));\n\nmyShapesCollection.parallelStream()\n.filter(e -&gt; e.getColor() == Color.RED)\n.forEach(e -&gt; System.out.println(e.getName()));\n</code></pre>\n\n<p>As long as I don't care about the order, would it always be beneficial to use the parallel? One would think it is faster dividing the work on more cores.</p>\n\n<p>Are there other considerations? When should parallel stream be used and when should the non-parallel be used?</p>\n    ","a":"\n<p>A parallel stream has a much higher overhead compared to a sequential one. Coordinating the threads takes a significant amount of time. I would use sequential streams by default and only consider parallel ones if</p>\n\n<ul>\n<li>I have a massive amount of items to process (or the processing of each item takes time and is parallelizable)</li>\n<li>I have a performance problem in the first place</li>\n<li>I don't already run the process in a multi-thread environment (for example: in a web container, if I already have many requests to process in parallel, adding an additional layer of parallelism inside each request could have more negative than positive effects)</li>\n</ul>\n\n<p>In your example, the performance will anyway be driven by the synchronized access to <code>System.out.println()</code>, and making this process parallel will have no effect, or even a negative one.\nMoreover, remember that parallel streams don't magically solve all the synchronization problems. If a shared resource is used by the predicates and functions used in the process, you'll have to make sure that everything is thread-safe. In particular, side effects are tings you really have to worry about if you go parallel.</p>\n\n<p>In any case, measure, don't guess! Only a measurement will tell you if the parallelism is worth it or not.</p>\n    "},{"t":"How to break or return from Java8 Lambda forEach?","l":"http://stackoverflow.com/questions/23308193/how-to-break-or-return-from-java8-lambda-foreach","q":"\n\n<p>Prior to Java8 we used to <code>break</code> or <code>return</code> from enhanced for-each loop as:</p>\n\n<pre><code>for(SomeObject obj : someObjects) {\n   if(some_condition_met) {\n      break; // or return obj\n   }\n}\n</code></pre>\n\n<p>How can we <code>break</code> or <code>return</code> in Java8 Lambda expression like:</p>\n\n<pre><code>someObjects.forEach(obj-&gt;{\n   //what to do here?\n})\n</code></pre>\n    ","a":"\n<p>This is not possible with <code>forEach</code>. It looks like you're really looking for something else than <code>forEach</code>.</p>\n\n<p>For example, if the goal of this loop is to find the first element which matches some predicate:</p>\n\n<pre><code>Optional&lt;SomeObject&gt; result =\n    someObjects.stream().filter(obj -&gt; some_condition_met).findFirst();\n</code></pre>\n\n<p>(Note: This will not iterate the whole collection, because streams are lazily evaluated - it will stop at the first object that matches the condition).</p>\n\n<p>If you just want to know if there's an element in the collection for which the condition is true, you could use <code>anyMatch</code>:</p>\n\n<pre><code>boolean result = someObjects.stream().anyMatch(obj -&gt; some_condition_met);\n</code></pre>\n    "},{"t":"How is ArrayOutOfBoundsException possible in String.valueOf(int)?","l":"http://stackoverflow.com/questions/25942010/how-is-arrayoutofboundsexception-possible-in-string-valueofint","q":"\n\n<p>Why does this code sometimes produce ArrayOutOfBoundsException? How is that even possible for <code>String.valueOf(int)</code>?</p>\n\n<pre><code>public static String ipToString(ByteString bs) {\n  if (bs == null || bs.isEmpty()) {\n    return null;\n  } else {\n    StringBuilder sb = new StringBuilder();\n    boolean started = false;\n    for (Byte byt : bs) {\n      if (started) {\n        sb.append(\".\");\n      }\n      sb.append(String.valueOf(byt &amp; 0xFF));\n      started = true;\n    }\n\n    return sb.toString();\n  }\n}\n\n\njava.lang.ArrayIndexOutOfBoundsException: -81914\n  at java.lang.Integer.getChars(Integer.java:458)\n  at java.lang.Integer.toString(Integer.java:402)\n  at java.lang.String.valueOf(String.java:3086)\n  at com.mystuff.mypackage.ipToString(MyCode.java:1325)\n  ...\n  at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n  at java.lang.Thread.run(Thread.java:745)\n</code></pre>\n\n<p><strong>Updates</strong></p>\n\n<p>I don't know the value of the byte when this occurs, but it doesn't seem like it should be possible for any possible value of byte.</p>\n\n<p>Once it happens once, every invocation then errors out with the same exception.</p>\n\n<p>Environment:</p>\n\n<blockquote>\n<pre><code>java version \"1.8.0_20\"\nJava(TM) SE Runtime Environment (build 1.8.0_20-b26)\nJava HotSpot(TM) 64-Bit Server VM (build 25.20-b23, mixed mode)\n</code></pre>\n</blockquote>\n    ","a":"\n<p>This is a JIT compiler bug that has been introduced in JDK 8u20 as a side-effect of another fix:<br>\n<a href=\"https://bugs.openjdk.java.net/browse/JDK-8042786\">JDK-8042786</a></p>\n\n<p>The problem is related to auto-boxing elimination optimization.<br>\nThe work-around is to switch the optimization off by <code>-XX:-EliminateAutoBox</code> JVM flag</p>\n\n<p>Looks like the problem also exists in the most recent JDK 9 source base.<br>\nI've submitted the bug report: <a href=\"https://bugs.openjdk.java.net/browse/JDK-8058847\">https://bugs.openjdk.java.net/browse/JDK-8058847</a> with 100% reproducible minimal test case included.</p>\n    "},{"t":"Eclipse + Java 8 support?","l":"http://stackoverflow.com/questions/15027255/eclipse-java-8-support","q":"\n\n<p>How can I get Java 8 to work with Eclipse? </p>\n\n<p>I have followed <a href=\"http://tuhrig.de/?p=921\">this guide</a> but doesn't work. I've also seen <a href=\"http://wiki.eclipse.org/JDT_Core/Java8\">the Eclipse Java 8 wiki page</a>, but they don't explain what to do with the checked out git repositories. </p>\n    ","a":"\n<p>As written in <a href=\"https://wiki.eclipse.org/JDT_Core/Java8\" rel=\"nofollow\">https://wiki.eclipse.org/JDT_Core/Java8</a> :</p>\n\n<p>\"Starting with I20140318-0830 all our Luna (4.4) builds contain the Eclipse support for Java™ 8. For Kepler SR2 (4.3.2) a feature patch is available. \"</p>\n\n<p><img src=\"http://i.stack.imgur.com/QS0lW.gif\" alt=\"enter image description here\"></p>\n\n<p>So right now you need to download a non stable eclipse release.</p>\n\n<p>Go to :\n<a href=\"http://download.eclipse.org/eclipse/downloads/\" rel=\"nofollow\">http://download.eclipse.org/eclipse/downloads/</a> </p>\n\n<p>There download a release older than or equals to I20140318-0830</p>\n\n<p><img src=\"http://i.stack.imgur.com/MQc1c.gif\" alt=\"enter image description here\"></p>\n\n<p>Then you choose your version according to your OS :</p>\n\n<p><img src=\"http://i.stack.imgur.com/fffPC.gif\" alt=\"enter image description here\"></p>\n\n<p>click on the (http) link, the download will start :</p>\n\n<p><img src=\"http://i.stack.imgur.com/Z9IId.gif\" alt=\"enter image description here\"></p>\n\n<p>Note that according to eclipse website :\nJava™ 8 has not yet landed in our standard download packages. But you can add it to your existing Eclipse Kepler SR2 package. It will be included in the Luna packages starting with M7 on May 9/2014.</p>\n\n<p>so after May 9/2014 getting eclipse working with java 8 will be simpler.</p>\n    "},{"t":"Why filter() after flatMap() is “not completely” lazy in Java streams?","l":"http://stackoverflow.com/questions/29229373/why-filter-after-flatmap-is-not-completely-lazy-in-java-streams","q":"\n\n<p>I have the following sample code:</p>\n\n<pre><code>System.out.println(\n       \"Result: \" +\n        Stream.of(1, 2, 3)\n                .filter(i -&gt; {\n                    System.out.println(i);\n                    return true;\n                })\n                .findFirst()\n                .get()\n);\nSystem.out.println(\"-----------\");\nSystem.out.println(\n       \"Result: \" +\n        Stream.of(1, 2, 3)\n                .flatMap(i -&gt; Stream.of(i - 1, i, i + 1))\n                .flatMap(i -&gt; Stream.of(i - 1, i, i + 1))\n                .filter(i -&gt; {\n                    System.out.println(i);\n                    return true;\n                })\n                .findFirst()\n                .get()\n);\n</code></pre>\n\n<p>The output is as follows:</p>\n\n<pre><code>1\nResult: 1\n-----------\n-1\n0\n1\n0\n1\n2\n1\n2\n3\nResult: -1\n</code></pre>\n\n<p>From here I see that in first case <code>stream</code> really behaves lazily - we use <code>findFirst()</code> so once we have first element our filtering lambda is not invoked.\nHowever, in second case which uses <code>flatMaps</code> we see that despite first element which <code>fulfils</code> the filter condition is found (it's just any first element as lambda always returns true) further contents of the stream are still being fed through filtering function.</p>\n\n<p>I am trying to understand why it behaves like this rather than giving up after first element is calculated as in the first case.\nAny helpful information would be appreciated.</p>\n    ","a":"\n<p>When looking into the implementation (<code>ReferencePipeline.java</code>) we see the method [<a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/stream/ReferencePipeline.java#l124\">link</a>]</p>\n\n<pre><code>@Override\nfinal void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {\n    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));\n}\n</code></pre>\n\n<p>which will be invoke for <code>findFirst</code> operation. The special thing to take care about is the <code>sink.cancellationRequested()</code> which allows to end the loop on the first match. Compare to [<a href=\"http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/stream/ReferencePipeline.java#l252\">link</a>]</p>\n\n<pre><code>@Override\npublic final &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super P_OUT, ? extends Stream&lt;? extends R&gt;&gt; mapper) {\n    Objects.requireNonNull(mapper);\n    // We can do better than this, by polling cancellationRequested when stream is infinite\n    return new StatelessOp&lt;P_OUT, R&gt;(this, StreamShape.REFERENCE,\n                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {\n        @Override\n        Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;R&gt; sink) {\n            return new Sink.ChainedReference&lt;P_OUT, R&gt;(sink) {\n                @Override\n                public void begin(long size) {\n                    downstream.begin(-1);\n                }\n\n                @Override\n                public void accept(P_OUT u) {\n                    try (Stream&lt;? extends R&gt; result = mapper.apply(u)) {\n                        // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it\n                        if (result != null)\n                            result.sequential().forEach(downstream);\n                    }\n                }\n            };\n        }\n    };\n}\n</code></pre>\n\n<p>The method for advancing one item ends up calling <code>forEach</code> on the sub-stream without any possibility for earlier termination and the comment at the beginning of the <code>flatMap</code> method even tells about this absent feature.</p>\n\n<p>Since this is more than just an optimization thing as it implies that the code simply breaks when the sub-stream is infinite, I hope that the developers soon prove that they “can do better than this”…</p>\n\n<hr>\n\n<p>To illustrate the implications, while <code>Stream.iterate(0, i-&gt;i+1).findFirst()</code> works as expected, <code>Stream.of(\"\").flatMap(x-&gt;Stream.iterate(0, i-&gt;i+1)).findFirst()</code> will end up in an infinite loop.</p>\n\n<p>Regarding the specification, most of it can be found in the</p>\n\n<p><a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\">chapter “Stream operations and pipelines” of the package specification</a>:</p>\n\n<blockquote>\n  <p>…</p>\n  \n  <p>Intermediate operations return a new stream. They are always <em>lazy</em>;</p>\n  \n  <p>…</p>\n  \n  <p>… Laziness also allows avoiding examining all the data when it is not necessary; for operations such as \"find the first string longer than 1000 characters\", it is only necessary to examine just enough strings to find one that has the desired characteristics without examining all of the strings available from the source. (This behavior becomes even more important when the input stream is infinite and not merely large.)</p>\n  \n  <p>…</p>\n  \n  <p>Further, some operations are deemed <em>short-circuiting</em> operations. An intermediate operation is short-circuiting if, when presented with infinite input, it may produce a finite stream as a result. A terminal operation is short-circuiting if, when presented with infinite input, it may terminate in finite time. Having a short-circuiting operation in the pipeline is a necessary, but not sufficient, condition for the processing of an infinite stream to terminate normally in finite time.</p>\n</blockquote>\n\n<p>It’s clear that a short-circuiting operation doesn’t guaranty a finite time termination, e.g. when a filter doesn’t match any item the processing can’t complete, but an implementation which doesn’t support any termination in finite time by simply ignoring the short-circuiting nature of an operation is far off the specification.</p>\n    "},{"t":"Eclipse Kepler Java 8","l":"http://stackoverflow.com/questions/17619638/eclipse-kepler-java-8","q":"\n\n<p>I want to start using Java 8 with Eclipse but I don't know how to install it - I can't find any tutorials on it. I am using Eclipse Kepler and have added a JRE for JDK 8 to the IDE but it won't let me continue to create the project because of a compliance problem with the JRE versions. How can I use Java 8 with the Eclipse Kepler IDE?</p>\n    ","a":"\n<p>Have a look at <a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=380190\">this bug report</a> from time to time for progress on Java 8 in Eclipse's JDT.</p>\n\n<p>EDIT: For Kepler you need SR2 (4.3.2) and the Java 8 <a href=\"https://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_For_Kepler\">feature patch</a>. Starting with I20140318-0830 all <a href=\"http://download.eclipse.org/eclipse/downloads/\">Luna (4.4) builds</a> contain support for Java 8 \"out-of-the-box\". The final version of Eclipse Luna (4.4) will be released at the end of June 2014.</p>\n    "},{"t":"Referencing non-final variable: why does this code compile?","l":"http://stackoverflow.com/questions/30141767/referencing-non-final-variable-why-does-this-code-compile","q":"\n\n<p>First off, I apologise if this is a duplicate question. I found many similar ones, but none that directly address my question.</p>\n\n<p>In preparation for an upcoming exam, I am doing a past paper. It has a question that gives a code snippet. We have to state if it compiles, and if not, write the line at which the first compiler error occurs and explain it. This is the snippet:</p>\n\n<pre><code>public static void main(String[] args) {\n    JFrame f = new JFrame(\"hi\");\n    JTextField jtf = new JTextField(50);\n\n    jtf.addMouseMotionListener(new MouseMotionAdapter() {\n        public void mouseMoved(MouseEvent evt) {\n            jtf.setText(evt.getLocationOnScreen().toString());\n        }\n    });\n\n    f.add(jtf);\n    f.setVisible(true);\n}\n</code></pre>\n\n<p>I was expecting it not to compile as <code>jtf</code> is not <code>final</code>. I tested my theory by entering the code above in Eclipse, which flagged the expected error, but compiled and ran just fine. It was only after mousing over the <code>JTextField</code> that I got the expected error:</p>\n\n<blockquote>\n  <p>java.lang.Error: Unresolved compilation problem: \n      Cannot refer to the non-final local variable jtf defined in an enclosing scope</p>\n</blockquote>\n\n<p>I did a bit of searching, and discovered that Eclipse uses its own version of the Java compiler. So I remade the file outside of Eclipse and compiled/ran it via the command line. It compiled with no errors or warnings, and when mousing over the text field, displayed the desired <code>java.awt.Point[x=...,y=...]</code>.</p>\n\n<p>My understanding of anonymous inner classes is that they can access:</p>\n\n<ul>\n<li>Fields of the enclosing class</li>\n<li>Methods of the enclosing class</li>\n<li>Local variables of the enclosing scope, provided they are <code>final</code></li>\n</ul>\n\n<p>So what am I missing? According to what I know, this code <em>should not work</em>.</p>\n    ","a":"\n<p>I guess you are compiling with Java 8. Here your <code>jtf</code> variable is effectively final, so it compiles fine. A variable is effectively final if its value is never changed after you initialized it. </p>\n\n<p>See also <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html\">Local Classes</a>:</p>\n\n<blockquote>\n  <p>However, starting in Java SE 8, a local class can access local\n  variables and parameters of the enclosing block that are final or\n  effectively final. A variable or parameter whose value is never\n  changed after it is initialized is effectively final.</p>\n</blockquote>\n\n<p>and</p>\n\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#accessing\">Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class</a></p>\n\n<blockquote>\n  <p>Like local classes, anonymous classes can capture variables; they have\n  the same access to local variables of the enclosing scope:</p>\n  \n  <ul>\n  <li><p>An anonymous class has access to the members of its enclosing class.</p></li>\n  <li><p>An anonymous class cannot access local variables in its enclosing\n  scope that are not declared as final or effectively final.</p></li>\n  </ul>\n  \n  <p>[...]</p>\n</blockquote>\n\n<p>If you tried with:</p>\n\n<pre><code>javac -source 1.7 MyFile.java\n</code></pre>\n\n<p>you'll have your expected error.</p>\n\n<pre><code>.java:13: error: local variable jtf is accessed from within inner class; needs to be declared final\n                jtf.setText(evt.getLocationOnScreen().toString());\n                ^\n1 error\n</code></pre>\n\n<p>So the answer of the exam question is: it compiles only if you're using Java 8+.</p>\n    "},{"t":"Why java.util.Optional is not Serializable, how to serialize the object with such fields","l":"http://stackoverflow.com/questions/24547673/why-java-util-optional-is-not-serializable-how-to-serialize-the-object-with-suc","q":"\n\n<p>The Enum class is Serializable so there is no problem to serialize object with enums. The other case is where class has fields of java.util.Optional class. In this case the following exception is thrown: java.io.NotSerializableException: java.util.Optional</p>\n\n<p>How to deal with such classes, how to serialize them? Is it possible to send such objects to Remote EJB or through RMI?</p>\n\n<p>This is the example:</p>\n\n<pre><code>import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Optional;\n\nimport org.junit.Test;\n\npublic class SerializationTest {\n\n    static class My implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n        Optional&lt;Integer&gt; value = Optional.empty();\n\n        public void setValue(Integer i) {\n            this.i = Optional.of(i);\n        }\n\n        public Optional&lt;Integer&gt; getValue() {\n            return value;\n        }\n    }\n\n    //java.io.NotSerializableException is thrown\n\n    @Test\n    public void serialize() {\n        My my = new My();\n        byte[] bytes = toBytes(my);\n    }\n\n    public static &lt;T extends Serializable&gt; byte[] toBytes(T reportInfo) {\n        try (ByteArrayOutputStream bstream = new ByteArrayOutputStream()) {\n            try (ObjectOutputStream ostream = new ObjectOutputStream(bstream)) {\n                ostream.writeObject(reportInfo);\n            }\n            return bstream.toByteArray();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n</code></pre>\n    ","a":"\n<p>This answer is in response to the question in the title, \"Shouldn't Optional be Serializable?\" The short answer is that the Java Lambda (JSR-335) expert group <a href=\"http://mail.openjdk.java.net/pipermail/jdk8-dev/2013-September/003274.html\">considered and rejected it</a>. That note, and <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-experts/2013-May/001814.html\">this one</a> and <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-September/005952.html\">this one</a> indicate that the primary design goal for <code>Optional</code> is to be used as the return value of functions when a return value might be absent. The intent is that the caller immediately check the <code>Optional</code> and extract the actual value if it's present. If the value is absent, the caller can substitute a default value, throw an exception, or apply some other policy. This is typically done by chaining fluent method calls off the end of a stream pipeline (or other methods) that return <code>Optional</code> values.</p>\n\n<p>It was never intended for <code>Optional</code> to be used other ways, such as for <a href=\"http://stackoverflow.com/a/23464794/1441122\">optional method arguments</a> or to be <a href=\"http://mail.openjdk.java.net/pipermail/jdk8-dev/2013-September/003273.html\">stored as a field in an object</a>. And by extension, making <code>Optional</code> serializable would enable it to be stored persistently or transmitted across a network, both of which encourage uses far beyond its original design goal.</p>\n\n<p>Usually there are better ways to organize the data than to store an <code>Optional</code> in a field. If a getter (such as the <code>getValue</code> method in the question) returns the actual <code>Optional</code> from the field, it forces every caller to implement some policy for dealing with an empty value. This will likely lead to inconsisent behavior across callers. It's often better to have whatever code sets that field apply some policy at the time it's set.</p>\n\n<p>Sometimes people want to put <code>Optional</code> into collections, like <code>List&lt;Optional&lt;X&gt;&gt;</code> or <code>Map&lt;Key,Optional&lt;Value&gt;&gt;</code>. This too is usually a bad idea. It's often better to replace these usages of <code>Optional</code> with <a href=\"http://en.wikipedia.org/wiki/Null_Object_pattern\">Null-Object</a> values (not actual <code>null</code> references), or simply to omit these entries from the collection entirely.</p>\n    "},{"t":"Why can't I map integers to strings when streaming from an array?","l":"http://stackoverflow.com/questions/29028980/why-cant-i-map-integers-to-strings-when-streaming-from-an-array","q":"\n\n<p>This code works (taken in the Javadoc):</p>\n\n<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);\nString commaSeparatedNumbers = numbers.stream()\n    .map(i -&gt; i.toString())\n    .collect(Collectors.joining(\", \"));\n</code></pre>\n\n<p>This one can't be compiled:</p>\n\n<pre><code>int[] numbers = {1, 2, 3, 4};\nString commaSeparatedNumbers = Arrays.stream(numbers)\n    .map((Integer i) -&gt; i.toString())\n    .collect(Collectors.joining(\", \"));\n</code></pre>\n\n<p>IDEA tells me I have an \"incompatible return type String in lambda expression\".</p>\n\n<p>Why ? And how to fix that ?</p>\n    ","a":"\n<p><code>Arrays.stream(int[])</code> creates an <code>IntStream</code>, not a <code>Stream&lt;Integer&gt;</code>. So you need to call <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#mapToObj-java.util.function.IntFunction-\"><code>mapToObj</code></a> instead of just <code>map</code>, when mapping an <code>int</code> to an object.</p>\n\n<p>This should work as expected:</p>\n\n<pre><code>String commaSeparatedNumbers = Arrays.stream(numbers)\n    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer\n    .collect(Collectors.joining(\", \"));\n</code></pre>\n\n<p>which you can also write:</p>\n\n<pre><code>String commaSeparatedNumbers = Arrays.stream(numbers)\n    .mapToObj(Integer::toString)\n    .collect(Collectors.joining(\", \"));\n</code></pre>\n    "},{"t":"Why does Collection.parallelStream() exist when .stream().parallel() does the same thing?","l":"http://stackoverflow.com/questions/24603186/why-does-collection-parallelstream-exist-when-stream-parallel-does-the-sa","q":"\n\n<p>In Java 8, the Collection interface was extended with two methods that return <code>Stream&lt;E&gt;</code>: <code>stream()</code>, which returns a sequential stream, and <code>parallelStream()</code>, which returns a possibly-parallel stream.  Stream itself also has a <code>parallel()</code> method that returns an equivalent parallel stream (either mutating the current stream to be parallel or creating a new stream).</p>\n\n<p>The duplication has obvious disadvantages:</p>\n\n<ul>\n<li><p>It's confusing.  A question asks <a href=\"https://stackoverflow.com/questions/22576855/obtaining-a-parallel-stream-from-a-collection\">whether calling both parallelStream().parallel() is necessary to be sure the stream is parallel</a>, given that parallelStream() may return a sequential stream.  Why does parallelStream() exist if it can't make a guarantee?  The other way around is also confusing -- if parallelStream() returns a sequential stream, there's probably a reason (e.g., an inherently sequential data structure for which parallel streams are a performance trap); what should Stream.parallel() do for such a stream?  (UnsupportedOperationException is not allowed by parallel()'s specification.)</p></li>\n<li><p>Adding methods to an interface risks conflicts if an existing implementation has a similarly-named method with an incompatible return type.  Adding parallelStream() in addition to stream() doubles the risk for little gain.  (Note that parallelStream() was at one point just named parallel(), though I don't know if it was renamed to avoid name clashes or for another reason.)</p></li>\n</ul>\n\n<p>Why does Collection.parallelStream() exist when calling Collection.stream().parallel() does the same thing?</p>\n    ","a":"\n<p>The Javadocs for <code>Collection.(parallelS|s)tream()</code> and <code>Stream</code> itself don't answer the question, so it's off to the mailing lists for the rationale.  I went through the lambda-libs-spec-observers archives and found <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/thread.html#1341\">one thread specifically about Collection.parallelStream()</a> and another thread that touched on whether <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/thread.html#1799\">java.util.Arrays should provide parallelStream()</a> to match (or actually, whether it should be removed).  There was no once-and-for-all conclusion, so perhaps I've missed something from another list or the matter was settled in private discussion.  (Perhaps <a href=\"https://stackoverflow.com/users/3553087/brian-goetz\">Brian Goetz</a>, one of the principals of this discussion, can fill in anything missing.)</p>\n\n<p>The participants made their points well, so this answer is mostly just an organization of the relevant quotes, with a few clarifications in <em>[brackets]</em>, presented in order of importance (as I interpret it).</p>\n\n<h2>parallelStream() covers a very common case</h2>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001362.html\">Brian Goetz</a> in the first thread, explaining why <code>Collections.parallelStream()</code> is valuable enough to keep even after other parallel stream factory methods have been removed:</p>\n\n<blockquote>\n  <p>We do <em>not</em> have explicit parallel versions of each of these <em>[stream factories]</em>; we did \n  originally, and to prune down the API surface area, we cut them on the \n  theory that dropping 20+ methods from the API was worth the tradeoff of \n  the surface yuckiness and performance cost of <code>.intRange(...).parallel()</code>. \n    But we did not make that choice with Collection.</p>\n  \n  <p>We could either remove the <code>Collection.parallelStream()</code>, or we could add \n  the parallel versions of all the generators, or we could do nothing and \n  leave it as is.  I think all are justifiable on API design grounds.</p>\n  \n  <p>I kind of like the status quo, despite its inconsistency.  Instead of \n  having 2N stream construction methods, we have N+1 -- but that extra 1 \n  covers a huge number of cases, because it is inherited by every \n  Collection.  So I can justify to myself why having that extra 1 method \n  is worth it, and why accepting the inconsistency of going no further is \n  acceptable.</p>\n  \n  <p>Do others disagree?  Is N+1 <em>[Collections.parallelStream() only]</em> the practical choice here?  Or should we go \n  for the purity of N <em>[rely on Stream.parallel()]</em>?  Or the convenience and consistency of 2N <em>[parallel versions of all factories]</em>?  Or is \n  there some even better N+3 <em>[Collections.parallelStream() plus other special cases]</em>, for some other specially chosen cases we \n  want to give special support to?</p>\n</blockquote>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001799.html\">Brian Goetz</a> stands by this position in the later discussion about <code>Arrays.parallelStream()</code>:</p>\n\n<blockquote>\n  <p>I still really like Collection.parallelStream; it has huge \n  discoverability advantages, and offers a pretty big return on API \n  surface area -- one more method, but provides value in a lot of places, \n  since Collection will be a really common case of a stream source.</p>\n</blockquote>\n\n<h2>parallelStream() is more performant</h2>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001799.html\">Brian Goetz</a>:</p>\n\n<blockquote>\n  <p>Direct version <em>[parallelStream()]</em> is more performant, in that it requires less wrapping (to \n  turn a stream into a parallel stream, you have to first create the \n  sequential stream, then transfer ownership of its state into a new \n  Stream.)</p>\n</blockquote>\n\n<p>In response to Kevin Bourrillion's skepticism about whether the effect is significant, <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001346.html\">Brian again</a>:</p>\n\n<blockquote>\n  <p>Depends how seriously you are counting.  Doug counts individual object \n  creations and virtual invocations on the way to a parallel operation, \n  because until you start forking, you're on the wrong side of Amdahl's \n  law -- this is all \"serial fraction\" that happens before you can fork \n  any work, which pushes your breakeven threshold further out.  So getting \n  the setup path for parallel ops fast is valuable.</p>\n</blockquote>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001354.html\">Doug Lea follows up</a>, but hedges his position:</p>\n\n<blockquote>\n  <p>People dealing with parallel library support need some attitude\n  adjustment about such things. On a soon-to-be-typical machine,\n  every cycle you waste setting up parallelism costs you say 64 cycles.\n  You would probably have had a different reaction if it required 64\n  object creations to start a parallel computation.</p>\n  \n  <p>That said, I'm always completely supportive of forcing implementors\n  to work harder for the sake of better APIs, so long as the\n  APIs do not rule out efficient implementation. So if killing\n  <code>parallelStream</code> is really important, we'll find some way to\n  turn <code>stream().parallel()</code> into a bit-flip or somesuch.</p>\n</blockquote>\n\n<p>Indeed, the later discussion about <code>Arrays.parallelStream()</code> <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001799.html\">takes notice of lower Stream.parallel() cost</a>.</p>\n\n<h2>stream().parallel() statefulness complicates the future</h2>\n\n<p>At the time of the discussion, switching a stream from sequential to parallel and back could be interleaved with other stream operations.  <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001363.html\">Brian Goetz, on behalf of Doug Lea</a>, explains why sequential/parallel mode switching may complicate future development of the Java platform:</p>\n\n<blockquote>\n  <p>I'll take my best stab at explaining why: because it (like the stateful \n  methods (sort, distinct, limit)) which you also don't like, move us \n  incrementally farther from being able to express stream pipelines in \n  terms of traditional data-parallel constructs, which further constrains \n  our ability to to map them directly to tomorrow's computing substrate, \n  whether that be vector processors, FPGAs, GPUs, or whatever we cook up.</p>\n  \n  <p>Filter-map-reduce map[s] very cleanly to all sorts of parallel computing \n  substrates; filter-parallel-map-sequential-sorted-limit-parallel-map-uniq-reduce \n  does not.</p>\n  \n  <p>So the whole API design here embodies many tensions between making it \n  easy to express things the user is likely to want to express, and doing \n  is in a manner that we can predictably make fast with transparent cost \n  models.</p>\n</blockquote>\n\n<p>This mode switching was <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-experts/2013-March/001504.html\">removed after further discussion</a>.  In the current version of the library, a stream pipeline is either sequential or parallel; last call to <code>sequential()</code>/<code>parallel()</code> wins.  Besides side-stepping the statefulness problem, this change also improved the performance of using <code>parallel()</code> to set up a parallel pipeline from a sequential stream factory.</p>\n\n<h2>exposing parallelStream() as a first-class citizen improves programmer perception of the library, leading them to write better code</h2>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-February/001352.html\">Brian Goetz again</a>, in response to <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-observers/2013-April/001801.html\">Tim Peierls's argument</a> that <code>Stream.parallel()</code> allows programmers to understand streams sequentially before going parallel:</p>\n\n<blockquote>\n  <p>I have a slightly different viewpoint about the value of this sequential \n  intuition -- I view the pervasive \"sequential expectation\" as one if the \n  biggest challenges of this entire effort; people are <em>constantly</em> \n  bringing their incorrect sequential bias, which leads them to do stupid \n  things like using a one-element array as a way to \"trick\" the \"stupid\" \n  compiler into letting them capture a mutable local, or using lambdas as \n  arguments to map that mutate state that will be used during the \n  computation (in a non-thread-safe way), and then, when its pointed out \n  that what they're doing, shrug it off and say \"yeah, but I'm not doing \n  it in parallel.\"</p>\n  \n  <p>We've made a lot of design tradeoffs to merge sequential and parallel \n  streams.  The result, I believe, is a clean one and will add to the \n  library's chances of still being useful in 10+ years, but I don't \n  particularly like the idea of encouraging people to think this is a \n  sequential library with some parallel bags nailed on the side.</p>\n</blockquote>\n    "},{"t":"Java 8 - Best way to transform a list: map or foreach?","l":"http://stackoverflow.com/questions/28319064/java-8-best-way-to-transform-a-list-map-or-foreach","q":"\n\n<p>I have a first list : <code>myListToParse</code> where i want to filter the elements and apply a method on each elements and add the result in another list : <code>myFinalList</code> </p>\n\n<p>With Java 8 I noticed that I can do it in 2 different way, I would like to know the more efficient way between them and understand why one way is better than the other one. </p>\n\n<p>I'm open for any suggestion about a third way.</p>\n\n<p>Method 1:</p>\n\n<pre><code>myListToParse.stream()\n        .filter(elt -&gt; elt != null)\n        .forEach(elt -&gt; myFinalList.add(doSomething(elt)));\n</code></pre>\n\n<p>Method 2:</p>\n\n<pre><code>myFinalList = myListToParse.stream()\n        .filter(elt -&gt; elt != null)\n        .map(elt -&gt; doSomething(elt))\n        .collect(Collectors.toList()); \n</code></pre>\n    ","a":"\n<p>Don't worry about any performance differences, they're going to be minimal in this case normally.</p>\n\n<p>Method 2 is preferable because</p>\n\n<ol>\n<li><p>it doesn't require mutating a collection that exists outside the lambda expression,</p></li>\n<li><p>it's more readable because the different steps that are performed in the collection pipeline are written sequentially (first a filter operation, then a map operation, then collecting the result),\n(for more info on the benefits of collection pipelines, see Martin Fowler's <a href=\"http://martinfowler.com/articles/collection-pipeline/\">excellent article</a>) </p></li>\n<li><p>you can easily change the way values are collected by replacing the <code>Collector</code> that is used.  In some cases you may need to write your own <code>Collector</code>, but then the benefit is that you can easily reuse that.</p></li>\n</ol>\n    "},{"t":"Cake pattern with Java8 possible?","l":"http://stackoverflow.com/questions/14248766/cake-pattern-with-java8-possible","q":"\n\n<p>I just wonder: with Java 8, and the possibility to add implementation in interfaces (a bit like Scala traits), will it be possible to implement the <a href=\"http://stackoverflow.com/questions/5172188/understanding-scalas-cake-pattern\">cake pattern</a>, like we can do in Scala?</p>\n\n<p>If it is, can someone provide a code snippet?</p>\n    ","a":"\n<p>With inspiration from other answers I came up with the following (rough) class hierarchy that is similar to the cake pattern in Scala:  </p>\n\n<pre><code>interface UserRepository {\n    String authenticate(String username, String password);\n}\n\ninterface UserRepositoryComponent {\n    UserRepository getUserRepository();\n}\n\ninterface UserServiceComponent extends UserRepositoryComponent {\n    default UserService getUserService() {\n        return new UserService(getUserRepository());\n    }\n}\n\nclass UserService {\n    private final UserRepository repository;\n\n    UserService(UserRepository repository) {\n        this.repository = repository;\n    }\n\n    String authenticate(String username, String password) {\n        return repository.authenticate(username, password);\n    }\n}\n\ninterface LocalUserRepositoryComponent extends UserRepositoryComponent {\n    default UserRepository getUserRepository() {\n        return new UserRepository() {\n            public String authenticate(String username, String password) {\n                return \"LocalAuthed\";\n            }\n        };\n    }\n}\n\ninterface MongoUserRepositoryComponent extends UserRepositoryComponent {\n    default UserRepository getUserRepository() {\n        return new UserRepository() {\n            public String authenticate(String username, String password) {\n                return \"MongoAuthed\";\n            }\n        };\n    }\n}\n\nclass LocalApp implements UserServiceComponent, LocalUserRepositoryComponent {}\nclass MongoApp implements UserServiceComponent, MongoUserRepositoryComponent {}\n</code></pre>\n\n<p>The above compiles on Java 8 as of Jan.9 2013. </p>\n\n<hr>\n\n<p>So, can Java 8 do a cake-<em>like</em> pattern? <strong>Yes.</strong> </p>\n\n<p>Is it as terse as Scala, or as effective as other patterns in Java (i.e. dependency injection)?\nProbably not, the above sketch required a whole lot of files and is not as terse as Scala.</p>\n\n<p>In summary:</p>\n\n<ul>\n<li>Self-types (as needed for the cake pattern) can be emulated by extending the base interface we expect.</li>\n<li>Interfaces cannot have inner classes (as noted by @Owen), so instead we can use anonymous classes.</li>\n<li><code>val</code> and <code>var</code> can be emulated by using a static hashmap (and lazy initialization), or by the client of the class simply storing the value on their side (like UserService does).</li>\n<li>We can discover our type by using <code>this.getClass()</code> in a default interface method.</li>\n<li>As @Owen notes, path dependent types are impossible using interfaces, so a full cake pattern is inherently impossible. The above shows, however, that one could use it for dependency injection.</li>\n</ul>\n    "},{"t":"Is Java-8's DoubleStream.sum() method stable when run in parallel?","l":"http://stackoverflow.com/questions/23581058/is-java-8s-doublestream-sum-method-stable-when-run-in-parallel","q":"\n\n<p>I'm curious about the following construct in Java 8:</p>\n\n<pre><code>double[] doubles = //...\ndouble sum = DoubleStream.of(doubles).parallel().sum();\n</code></pre>\n\n<p><strong>To cut to the chase:</strong> </p>\n\n<ul>\n<li>Will the value of <code>sum</code> always be the same, e.g. when run on different computers?</li>\n</ul>\n\n<hr>\n\n<p><strong>More background...</strong></p>\n\n<p>Floating point arithmetic is lossy and (unlike real-valued arithmetic) is not associative. So unless care is taken in how the work is divided and reassembled, it could lead to non-deterministic results.</p>\n\n<p>I was happy to discover that the <code>sum()</code> method employs <a href=\"http://en.wikipedia.org/wiki/Kahan_summation_algorithm\">Kahan Summation</a> under the hood. This significantly reduces the error, but does still not give precise* results. </p>\n\n<p>In my testing repeated calls appear to return the same result each time, but I'd like to know how stable we can safely assume it is. e.g.:</p>\n\n<ol>\n<li>Stable in all circumstances?</li>\n<li>Stable across computers with the same number of cores?</li>\n<li>Stable only on a given computer?</li>\n<li>Can't depend on it being stable at all?</li>\n</ol>\n\n<p>I'm happy to assume the same JVM version on each computer.</p>\n\n<p>Here's a test I whipped up:</p>\n\n<pre><code>public static void main(String[] args) {\n    Random random = new Random(42L);\n    for (int j = 1; j &lt; 20; j++) {\n\n        // Stream increases in size and the magnitude of the values at each iteration.\n        double[] doubles = generate(random, j*100, j);\n\n        // Like a simple for loop\n        double sum1 = DoubleStream.of(doubles).reduce(0, Double::sum); \n\n        double sum2 = DoubleStream.of(doubles).sum();\n        double sum3 = DoubleStream.of(doubles).parallel().sum();\n\n        System.out.println(printStats(doubles, sum1, sum2, sum3));\n\n        // Is the parallel computation stable?\n        for (int i = 0; i &lt; 1000; i++) {\n            double sum4 = DoubleStream.of(doubles).parallel().sum();\n            assert sum4 == sum3;\n        }\n        Arrays.sort(doubles);\n    }\n}\n\n/**\n * @param spread When odd, returns a mix of +ve and -ve numbers.\n *               When even, returns only +ve numbers.\n *               Higher values cause a wider spread of magnitudes in the returned values.\n *               Must not be negative.  \n */\nprivate static double[] generate(Random random, int count, int spread) {\n    return random.doubles(count).map(x -&gt; Math.pow(4*x-2, spread)).toArray();\n}\n\nprivate static String printStats(double[] doubles, double sum1, double sum2, double sum3) {\n    DoubleSummaryStatistics stats = DoubleStream.of(doubles).summaryStatistics();\n\n    return String.format(\"-----%nMin: %g, Max: %g, Average: %g%n\"\n            + \"Serial difference:   %g%n\"\n            + \"Parallel difference: %g\",\n            stats.getMin(), stats.getMax(), stats.getAverage(), sum2-sum1, sum3-sum1);\n}\n</code></pre>\n\n<p>When I run this, the first few iterations are:</p>\n\n<pre><code>-----\nMin: -1.89188, Max: 1.90414, Average: 0.0541140\nSerial difference:   -2.66454e-15\nParallel difference: -2.66454e-15\n-----\nMin: 0.000113827, Max: 3.99513, Average: 1.17402\nSerial difference:   1.70530e-13\nParallel difference: 1.42109e-13\n-----\nMin: -7.95673, Max: 7.87757, Average: 0.0658356\nSerial difference:   0.00000\nParallel difference: -7.10543e-15\n-----\nMin: 2.53794e-09, Max: 15.8122, Average: 2.96504\nSerial difference:   -4.54747e-13\nParallel difference: -6.82121e-13\n</code></pre>\n\n<p>Notice that while <code>sum2</code> &amp; <code>sum3</code> can be assumed to be more accurate than <code>sum1</code> - they might not be the same as each other!</p>\n\n<p>I seeded <code>Random</code> with 42, so if anyone gets a different result to me, that would immediately prove some something. :-)</p>\n\n<hr>\n\n<p><code>*</code> <em>For the curious...</em></p>\n\n<ul>\n<li>Here are <a href=\"http://code.activestate.com/recipes/393090/\">some (python) algorithms</a> that give precise results</li>\n<li>The precise-sum algorithm with the best-sounding performance characteristics I've heard of is <a href=\"http://dl.acm.org/citation.cfm?id=1824815\">given here</a> (ACM subscription or fee required). It takes 5 flops per input, but is written (in C) to exploit instruction-level parallelism and only run 2 - 3 times slower than naive summation, which sounds rather good for a precise result. (c.f. Kahan summation at 4 flops per input)</li>\n</ul>\n    ","a":"\n<p>I think the documentation of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/DoubleStream.html#sum--\">DoubleStream::sum</a> is pretty clear about this issue:</p>\n\n<blockquote>\n  <p>[..] The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. [..]</p>\n</blockquote>\n\n<p>That means, you shouldn't rely on stability, in particular not for parallel streams.</p>\n\n<hr>\n\n<p>On the other hand, it's not surprising, that you see the same results for each run. <em>Conceptually</em>, the <em>sum</em> method might be implemented as follows:</p>\n\n<pre><code>double sum(double[] array, int startInclusive, int endExclusive) {\n    int distance = endExclusive - startInclusive;\n    if (distance &lt; 1000) {\n        double total = 0;\n        for (int i = startInclusive; i &lt; endExclusive; ++i) {\n            total += array[i];\n        }\n        return total;\n    } else {\n        int middle = startInclusive + distance / 2;\n        var left = async sum(array, startInclusive, middle);\n        var right = async sum(array, middle, endExclusive);\n        return await left + await right;\n    }\n}\n</code></pre>\n\n<p>Although the scheduling of the asynchronously executed tasks is nondeterminstic, the method always returns the same result, because the order of addition operations is the same (i.e. the <em>parentheses are not rearranged</em>).</p>\n\n<p>However, a more sophisticated implementation might consider the current work load as well as the expected execution time of sub-tasks (in comparison with the costs of asynchronous operations). If that happens, the results might vary.</p>\n    "},{"t":"Why does Stream.allMatch() return true for an empty stream?","l":"http://stackoverflow.com/questions/30223079/why-does-stream-allmatch-return-true-for-an-empty-stream","q":"\n\n<p>My colleague and I had a bug that was due to our assumption that an empty stream calling <code>allMatch()</code> would return <code>false</code>. </p>\n\n<pre><code>if (myItems.allMatch(i -&gt; i.isValid()) { \n    //do something\n}\n</code></pre>\n\n<p>Of course, it is kind of our fault for assuming and not reading documentation. But what I don't understand is why the default <code>allMatch()</code> behavior for an empty stream returns <code>true</code>. What was the reasoning for this? Like the <code>anyMatch()</code> (which contrarily returns false), this operation is used in an imperative way that departs the monad and probably used in an <code>if</code> statement. Considering those facts, is there any reason why having <code>allMatch()</code> default to <code>true</code> on an empty stream be desirable for majority of uses?  </p>\n    ","a":"\n<p>This is known as <a href=\"http://en.wikipedia.org/wiki/Vacuous_truth\">vacuous truth</a>. All members of an empty collection satisfy your condition; after all, can you point to one that doesn't? Similarly, <code>anyMatch</code> returns false, because you can't find an element of your collection that does match the condition. This is confusing to a lot of people, but it turns out to be the most useful and consistent way to define \"any\" and \"all\" for empty sets.</p>\n    "},{"t":"How does Java 8' new default interface model works (incl. diamond, multiple inheritance, and precedence)?","l":"http://stackoverflow.com/questions/16764791/how-does-java-8-new-default-interface-model-works-incl-diamond-multiple-inhe","q":"\n\n<p>How does this new interface model works and what is about</p>\n\n<ul>\n<li>the diamond problem that might arise out of this</li>\n<li>multiple inheritance character of this implementation</li>\n<li>and the precedence with which the interface implementations are used\n?</li>\n</ul>\n    ","a":"\n<p>Here is a detailed explanation for <a href=\"http://blog.loxal.net/2013/05/java-8-default-interface.html\">Java 8' new interface model &amp; the diamond problem of multiple inheritance</a>.</p>\n\n<blockquote>\n  <p>As you might see in this examples, starting with <b>JDK 8</b>, Java\n  has introduced a kind of <b>multiple inheritance</b> as both, the\n  <b><i>class</i></b> and its <b><i>interface</i></b> might contain an\n  <b><i>implementation</i></b> of the same method (same name\n  &amp;&nbsp;signature). To address the diamond\n  problem&nbsp;there is a precedence in which order an\n  implementation is used: only if the <b>class implements all</b> default / optional methods of its\n  interfaces, the code can be compiled and the implementations of this\n  class are used. <b>Otherwise</b> the compiler tries to patch the\n  missing implementation(s) with <i>interface's default\n  implementation</i>. And if there are multiple default implementations\n  of a method, then the&nbsp;diamond\n  problem&nbsp;occurs and the compiler rejects the compilation. <br> Java 8' new interfaces model is the result of\n  approaching&nbsp;<b>backwards compatibility</b>, i. e. to keep\n  existing code that was written against pre Java 8 interfaces\n  compilable.</p>\n</blockquote>\n    "},{"t":"Lambda Expression and generic method","l":"http://stackoverflow.com/questions/22588518/lambda-expression-and-generic-method","q":"\n\n<p>Suppose I've a generic interface:</p>\n\n<pre><code>interface MyComparable&lt;T extends Comparable&lt;T&gt;&gt;  {\n    public int compare(T obj1, T obj2);\n}\n</code></pre>\n\n<p>And a method <code>sort</code>:</p>\n\n<pre><code>public static &lt;T extends Comparable&lt;T&gt;&gt; \n       void sort(List&lt;T&gt; list, MyComparable&lt;T&gt; comp) {\n    // sort the list\n}\n</code></pre>\n\n<p>I can invoke this method and pass a lambda expression as argument:</p>\n\n<pre><code>List&lt;String&gt; list = Arrays.asList(\"a\", \"b\", \"c\");\nsort(list, (a, b) -&gt; a.compareTo(b));\n</code></pre>\n\n<p>That will work fine. </p>\n\n<p>But now if I make the interface non-generic, and the method generic:</p>\n\n<pre><code>interface MyComparable {\n    public &lt;T extends Comparable&lt;T&gt;&gt; int compare(T obj1, T obj2);\n}\n\npublic static &lt;T extends Comparable&lt;T&gt;&gt; \n       void sort(List&lt;T&gt; list, MyComparable comp) {\n}\n</code></pre>\n\n<p>And then invoke this like:</p>\n\n<pre><code>List&lt;String&gt; list = Arrays.asList(\"a\", \"b\", \"c\");\nsort(list, (a, b) -&gt; a.compareTo(b));\n</code></pre>\n\n<p>It doesn't compile. It shows error at lambda expression saying: </p>\n\n<blockquote>\n  <p>\"Target method is generic\"</p>\n</blockquote>\n\n<p>OK, when I compiled it using <code>javac</code>, it shows following error:</p>\n\n<pre><code>SO.java:20: error: incompatible types: cannot infer type-variable(s) T#1\n        sort(list, (a, b) -&gt; a.compareTo(b));\n            ^\n    (argument mismatch; invalid functional descriptor for lambda expression\n      method &lt;T#2&gt;(T#2,T#2)int in interface MyComparable is generic)\n  where T#1,T#2 are type-variables:\n    T#1 extends Comparable&lt;T#1&gt; declared in method &lt;T#1&gt;sort(List&lt;T#1&gt;,MyComparable)\n    T#2 extends Comparable&lt;T#2&gt; declared in method &lt;T#2&gt;compare(T#2,T#2)\n1 error\n</code></pre>\n\n<p>From this error message, it seems like compiler is not able to infer the type arguments. Is that the case? If yes, then why is it happening like this?</p>\n\n<p>I tried various ways, searched through the internet. Then I found <a href=\"http://www.javacodegeeks.com/2012/02/whats-cooking-in-java-8-project-lambda.html\">this JavaCodeGeeks article</a>, which shows a way, so I tried:</p>\n\n<pre><code>sort(list, &lt;T extends Comparable&lt;T&gt;&gt;(a, b) -&gt; a.compareTo(b));\n</code></pre>\n\n<p>which again doesn't work, contrary to what that article claims that it works. Might be possible that it used to work in some initial builds.</p>\n\n<p>So my question is: Is there any way to create lambda expression for a generic method? I can do this using a method reference though, by creating a method:</p>\n\n<pre><code>public static &lt;T extends Comparable&lt;T&gt;&gt; int compare(T obj1, T obj2) {\n    return obj1.compareTo(obj2);\n}\n</code></pre>\n\n<p>in some class say <code>SO</code>, and pass it as:</p>\n\n<pre><code>sort(list, SO::compare);\n</code></pre>\n    ","a":"\n<p>You can't use a <em>lambda expression</em> for a <em>functional interface</em>, if the method in the <em>functional interface</em> has <em>type parameters</em>. See <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3\">section §15.27.3 in JLS8</a>:</p>\n\n<blockquote>\n  <p>A lambda expression is compatible [..] with a target type <em>T</em> if <em>T</em> is a functional interface type (§9.8) and the expression is <strong>congruent</strong> with the function type of [..] T. [..] A lambda expression is <strong>congruent</strong> with a function type if all of the following are\n  true:</p>\n  \n  <ul>\n  <li>The function type has <em>no type parameters</em>.</li>\n  <li>[..]</li>\n  </ul>\n</blockquote>\n    "},{"t":"Java8: ambiguity with lambdas and overloaded methods","l":"http://stackoverflow.com/questions/21905169/java8-ambiguity-with-lambdas-and-overloaded-methods","q":"\n\n<p>I'm playing around with java8 lambdas and I came across a compiler error which I didn't expect.</p>\n\n<p>Say I have a functional <code>interface A</code>, an <code>abstract class B</code> and a <code>class C</code> with overloaded methods that take either <code>A</code> or <code>B</code> as arguments:</p>\n\n<pre><code>public interface A { \n  void invoke(String arg); \n}\n\npublic abstract class B { \n  public abstract void invoke(String arg); \n}\n\npublic class C {\n  public void apply(A x) { }    \n  public B apply(B x) { return x; }\n}\n</code></pre>\n\n<p>Then I can pass a lambda into <code>c.apply</code> and it is correctly resolved to <code>c.apply(A)</code>.</p>\n\n<pre><code>C c = new C();\nc.apply(x -&gt; System.out.println(x));\n</code></pre>\n\n<p>But when I change the overload that takes <code>B</code> as argument to a generic version the compiler reports that the two overloads are ambiguous.</p>\n\n<pre><code>public class C {\n  public void apply(A x) { }    \n  public &lt;T extends B&gt; T apply(T x) { return x; }\n}\n</code></pre>\n\n<p>I thought the compiler would see that <code>T</code> has to be a subclass of <code>B</code> which is not a functional interface. Why can't it resolve the correct method? </p>\n    ","a":"\n<p>There is a lot of complexity at the intersection of overload resolution and type inference. The <a href=\"http://cr.openjdk.java.net/~dlsmith/jsr335-0.9.3.html\">current draft</a> of the lambda specification has all the gory details. Sections F and G cover overload resolution and type inference, respectively. I don't pretend to understand it all. The summary sections in the introduction are fairly understandable, though, and I recommend that people read them, particularly the summaries of sections F and G, to get an idea of what's going on in this area.</p>\n\n<p>To recap the issues briefly, consider a method call with some arguments in the presence of overloaded methods. Overload resolution has to choose the right method to call. The \"shape\" of the method (arity, or number of arguments) is most significant; obviously a method call with one argument can't resolve to a method that takes two parameters. But overloaded methods often have the same number of parameters of different types. In this case, the types start to matter.</p>\n\n<p>Suppose there are two overloaded methods:</p>\n\n<pre><code>    void foo(int i);\n    void foo(String s);\n</code></pre>\n\n<p>and some code has the following method call:</p>\n\n<pre><code>    foo(\"hello\");\n</code></pre>\n\n<p>Obviously this resolves to the second method, based on the type of the argument being passed. But what if we are doing overload resolution, and the argument is a lambda? (Especially one whose types are implicit, that relies on type inference to establish the types.) Recall that a lambda expression's type is inferred from the target type, that is, the type expected in this context. Unfortunately, if we have overloaded methods, we don't have a target type until we've resolved which overloaded method we're going to call. But since we don't yet have a type for the lambda expression, we can't use its type to help us during overload resolution.</p>\n\n<p>Let's look at the example here. Consider interface <code>A</code> and abstract class <code>B</code> as defined in the example. We have class <code>C</code> that contains two overloads, and then some code calls the <code>apply</code> method and passes it a lambda:</p>\n\n<pre><code>    public void apply(A a)    \n    public B apply(B b)\n\n    c.apply(x -&gt; System.out.println(x));\n</code></pre>\n\n<p>Both <code>apply</code> overloads have the same number of parameters. The argument is a lambda, which must match a functional interface. <code>A</code> and <code>B</code> are actual types, so it's manifest that <code>A</code> is a functional interface whereas <code>B</code> is not, therefore the result of overload resolution is <code>apply(A)</code>. At this point we now have a target type <code>A</code> for the lambda, and type inference for <code>x</code> proceeds.</p>\n\n<p>Now the variation:</p>\n\n<pre><code>    public void apply(A a)    \n    public &lt;T extends B&gt; T apply(T t)\n\n    c.apply(x -&gt; System.out.println(x));\n</code></pre>\n\n<p>Instead of an actual type, the second overload of <code>apply</code> is a generic type variable <code>T</code>. We haven't done type inference, so we don't take <code>T</code> into account, at least not until after overload resolution has completed. Thus both overloads are still applicable, neither is most specific, and the compiler emits an error that the call is ambiguous.</p>\n\n<p>You might argue that, since we <em>know</em> that <code>T</code> has a type bound of <code>B</code>, which is a class, not a functional interface, the lambda can't possibly apply to this overload, thus it should be ruled out during overload resolution, removing the ambiguity. I'm not the one to have that argument with. :-) This might indeed be a bug in either the compiler or perhaps even in the specification.</p>\n\n<p>I do know that this area went through a bunch of changes during the design of Java 8. Earlier variations did attempt to bring more type checking and inference information into the overload resolution phase, but they were harder to implement, specify, and understand. (Yes, even harder to understand than it is now.) Unfortunately problems kept arising. It was decided to simplify things by reducing the range of things that can be overloaded. </p>\n\n<blockquote>\n  <p>Type inference and overloading are ever in opposition; many languages with type inference from day 1 prohibit overloading (except maybe on arity.)  So for constructs like implicit lambdas, which require inference, it seems reasonable to give up something in overloading power to increase the range of cases where implicit lambdas can be used.</p>\n</blockquote>\n\n<p>-- <a href=\"http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-August/000340.html\">Brian Goetz, Lambda Expert Group, 9 Aug 2013</a></p>\n\n<p>(This was quite a controversial decision. Note that there were 116 messages in this thread, and there are several other threads that discuss this issue.)</p>\n\n<p>One of the consequences of this decision was that certain APIs had to be changed to avoid overloading, for example, <a href=\"http://mail.openjdk.java.net/pipermail/lambda-libs-spec-experts/2013-August/002206.html\">the Comparator API</a>. Previously, the <code>Comparator.comparing</code> method had four overloads:</p>\n\n<pre><code>    comparing(Function)\n    comparing(ToDoubleFunction)\n    comparing(ToIntFunction)\n    comparing(ToLongFunction)\n</code></pre>\n\n<p>The problem was that these overloads are differentiated only by the lambda return type, and we actually never quite got the type inference to work here with implicitly-typed lambdas. In order to use these one would always have to cast or supply an explicit type argument for the lambda. These APIs were later changed to:</p>\n\n<pre><code>    comparing(Function)\n    comparingDouble(ToDoubleFunction)\n    comparingInt(ToIntFunction)\n    comparingLong(ToLongFunction)\n</code></pre>\n\n<p>which is somewhat clumsy, but it's entirely unambiguous. A similar situation occurs with <code>Stream.map</code>, <code>mapToDouble</code>, <code>mapToInt</code>, and <code>mapToLong</code>, and in a few other places around the API.</p>\n\n<p>The bottom line is that getting overload resolution right in the presence of type inference is very difficult in general, and that the language and compiler designers traded away power from overload resolution in order to make type inference work better. For this reason, the Java 8 APIs avoid overloaded methods where implicitly typed lambdas are expected to be used.</p>\n    "},{"t":"Synchronizing on local variable","l":"http://stackoverflow.com/questions/26482149/synchronizing-on-local-variable","q":"\n\n<p>I noticed a weird construct in <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/concurrent/ConcurrentHashMap.java#1847\"><code>ConcurrentHashMap</code>'s <code>compute</code> and <code>computeIfAbsent</code> methods</a>:</p>\n\n<pre><code>Node&lt;K,V&gt; r = new ReservationNode&lt;K,V&gt;();\nsynchronized (r) {\n  //...\n}\n</code></pre>\n\n<p>What is the point of synchronizing on a local object considering that the JIT will most likely treat it as a no-op?</p>\n    ","a":"\n<p>Right after the code has acquired the object’s monitor, the reference to the object is stored into the <code>tab</code> which is the globally visible array of nodes which make up the contents of the <code>ConcurrentHashMap</code>:</p>\n\n<pre><code>Node&lt;K,V&gt; r = new ReservationNode&lt;K,V&gt;();\nsynchronized (r) {\n    if (casTabAt(tab, i, null, r)) {\n</code></pre>\n\n<p>Right at this point, other threads executing other modification methods on the same <code>ConcurrentHashMap</code> might encounter this incomplete node while traversing the global array, in other words, the <code>Node</code> reference has escaped.</p>\n\n<p>While at the point where the <code>ReservationNode</code> has been constructed, there is no possibility for contention on a newly created object, in the other methods, which are synchronizing on <code>Node</code>s found in the array, there might be contention for exactly that <code>Node</code>.</p>\n\n<p>It’s like a “priority-synchronization”. The creator is synchronizing at a point where the reference has not been escaped yet therefore it is guaranteed to succeed while at the point where the reference escapes, all other threads will have to wait, in the unlikely (but still possible) event that they access exactly that <code>Node</code>.</p>\n    "},{"t":"Java Lambda expressions [closed]","l":"http://stackoverflow.com/questions/16859992/java-lambda-expressions","q":"\n\n<p>Lambda expressions are being added in Java 8. I want to understand why this is important. What does it mean to a Java programmer who is yet to be exposed to functional programming idioms? Does it mean I can write code that performs better or scales massively or does it only make the code less verbose. Or all of it.</p>\n    ","a":"\n<p>Oracle already has <a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\">tutorial</a> up on the topic.  It lists several great uses cases.</p>\n\n<p>Before I found the link, I was going to say that lambda expressions let you pass \"functions\" to code.  So you can write code more easily that we used to need a whole mess of interfaces/abstract classes for.  For example, suppose you have code that has some complex loop/conditional logic or workflow.  At one step you want to do something different.  With lambda expressions, you can just pass in that \"something different.\"  Read the tutorial though.  It's very clear.</p>\n    "},{"t":"Sorting a List in parallel without creating a temporary array in Java 8","l":"http://stackoverflow.com/questions/25961018/sorting-a-list-in-parallel-without-creating-a-temporary-array-in-java-8","q":"\n\n<p>Java 8 provides <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#parallelSort-T:A-\"><code>java.util.Arrays.parallelSort</code></a>, which sorts arrays in parallel using the fork-join framework.  But there's no corresponding <code>Collections.parallelSort</code> for sorting lists.</p>\n\n<p>I can use <code>toArray</code>, sort that array, and store the result back in my list, but that will temporarily increase memory usage, which if I'm using parallel sorting is already high because parallel sorting only pays off for huge lists.  Instead of twice the memory (the list plus parallelSort's working memory), I'm using thrice (the list, the temporary array and parallelSort's working memory).  (Arrays.parallelSort documentation says \"The algorithm requires a working space no greater than the size of the original array\".)</p>\n\n<p>Memory usage aside, Collections.parallelSort would also be more convenient for what seems like a reasonably common operation.  (I tend not to use arrays directly, so I'd certainly use it more often than Arrays.parallelSort.)</p>\n\n<p>The library can test for <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/RandomAccess.html\">RandomAccess</a> to avoid trying to e.g. quicksort a linked list, so that can't a reason for a deliberate omission.</p>\n\n<p><strong>How can I sort a List in parallel without creating a temporary array?</strong></p>\n    ","a":"\n<p>There doesn't appear to be any straightforward way to sort a <code>List</code> in parallel in Java 8. I don't think this is fundamentally difficult; it looks more like an oversight to me.</p>\n\n<p>The difficulty with a hypothetical <code>Collections.parallelSort(list, cmp)</code> is that the <code>Collections</code> implementation knows nothing about the list's implementation or its internal organization. This can be seen by examining the Java 7 implementation of <code>Collections.sort(list, cmp)</code>. As you observed, it has to copy the list elements out to an array, sort them, and then copy them back into the list.</p>\n\n<p>This is the big advantage of the <code>List.sort(cmp)</code> extension method over <code>Collections.sort(list, cmp)</code>. It might seem that this is merely a small syntactic advantage being able to write <code>myList.sort(cmp)</code> instead of <code>Collections.sort(myList, cmp)</code>. The difference is that <code>myList.sort(cmp)</code>, being an interface extension method, <em>can be overridden</em> by the specific <code>List</code> implementation. For example, <code>ArrayList.sort(cmp)</code> sorts the list in-place using <code>Arrays.sort()</code> whereas the default implementation implements the old copyout-sort-copyback technique.</p>\n\n<p>It should be possible to add a <code>parallelSort</code> extension method to the <code>List</code> interface that has similar semantics to <code>List.sort</code> but does the sorting in parallel. This would allow <code>ArrayList</code> to do a straightforward in-place sort using <code>Arrays.parallelSort</code>. (It's not entirely clear to me what the default implementation should do. It might still be worth it to do copyout-parallelSort-copyback.) Since this would be an API change, it can't happen until the next major release of Java SE.</p>\n\n<p>As for a Java 8 solution, there are a couple workarounds, none very pretty (as is typical of workarounds). You could create your own array-based <code>List</code> implementation and override <code>sort()</code> to sort in parallel. Or you could subclass <code>ArrayList</code>, override <code>sort()</code>, grab the <code>elementData</code> array via reflection and call <code>parallelSort()</code> on it. Of course you could just write your own <code>List</code> implementation and provide a <code>parallelSort()</code> method, but the advantage of overriding <code>List.sort()</code> is that this works on the plain <code>List</code> interface and you don't have to modify all the code in your code base to use a different <code>List</code> subclass.</p>\n    "},{"t":"How will Java lambda functions be compiled?","l":"http://stackoverflow.com/questions/16827262/how-will-java-lambda-functions-be-compiled","q":"\n\n<pre><code>Loop.times(5, () -&gt; {\n   System.out.println(\"looping\");\n});\n</code></pre>\n\n<p>Which of these would it effectively compile to?</p>\n\n<pre><code>for(int i = 0; i &lt; 5; i++)\n    System.out.println(\"looping\");\n</code></pre>\n\n<p>or something like</p>\n\n<pre><code>new CallableInterfaceImpl(){\n    public void call(){\n      for(int i = 0; i &lt; 5; i++)\n          System.out.println(\"looping\");\n    }\n}.call();\n</code></pre>\n\n<p>So would it replace (kind of inline), or actually create an anonymous class?</p>\n    ","a":"\n<p>The VM decides how to implement lambda, not a compiler.</p>\n\n<p>See <code>Translation strategy</code> section in <a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html\">Translation of Lambda Expressions</a>. </p>\n\n<blockquote>\n  <p>Instead of generating bytecode to create the object that implements the lambda expression (such as calling a constructor for an inner class), we describe a recipe for constructing the lambda, and delegate the actual construction to the language runtime. That recipe is encoded in the static and dynamic argument lists of an invokedynamic instruction.</p>\n</blockquote>\n\n<p><code>for</code> construction from your example is most effective way in terms of simple compiling or perfomance (but the performance differences are very small, by the tests). </p>\n\n<p><strong>Addon</strong>: </p>\n\n<p>I created and disassemble two examples: </p>\n\n<pre><code>for (String string: Arrays.asList(\"hello\")) {\n    System.out.println(string);\n}\n</code></pre>\n\n<p>Disassembled bytecode, constants and other information: <a href=\"http://pastebin.com/tDY6hVxc\"><code>view listing</code></a></p>\n\n<p>and</p>\n\n<pre><code>Arrays.asList(\"hello\").forEach(p -&gt; {System.out.println(p);});\n</code></pre>\n\n<p>Disassembled bytecode, constants and other inforamtion: <a href=\"http://pastebin.com/fcLGnpZY\"><code>view listing</code></a></p>\n\n<p>Compiler generated class-file is more complicated and larger (771b vs 1262b) for Lambda example.</p>\n    "},{"t":"Is there a type inference regression in JDK 8 update 20?","l":"http://stackoverflow.com/questions/25490581/is-there-a-type-inference-regression-in-jdk-8-update-20","q":"\n\n<p>I have a problem with the following code:</p>\n\n<pre><code>public static &lt;T&gt; T firstNonNull(@Nullable T first, @Nullable T second) {\n    return first != null ? first : second;\n}\n\npublic static Set&lt;String&gt; getStrings() {\n   return new HashSet&lt;&gt;();\n}\n\npublic static Set&lt;String&gt; doesNotCompile = firstNonNull(getStrings(), new HashSet&lt;&gt;());\n</code></pre>\n\n<p>With JDK 8 until update 11, this code compile.\nWith JDK 8 update 20, it does not compile anymore. In the last statement, I have to explicitly specify the <code>String</code> type argument for the last <code>HashSet</code> instantiation.</p>\n\n<p>I was wondering if I am wrong with this code or if it is a regression in the last JDK update.</p>\n    ","a":"\n<p>This is a new bug that exists in the JDK 8u20 update release and in the current JDK 9 development branch. This code worked before, so yes, this would be considered a regression. The JDK langtools team has filed the following bug report:</p>\n\n<blockquote>\n  <p><a href=\"https://bugs.openjdk.java.net/browse/JDK-8055963\">JDK-8055963</a> Inference failure with nested invocation</p>\n</blockquote>\n\n<p>Judging from the comments, it appears that the current behavior actually conforms to the specification (the JLS), but the behavior is clearly wrong, so it might be the case that a clarification to the specification is necessary.</p>\n\n<p>Note that this is a different type inference bug from the one reported in this other StackOverflow question <a href=\"http://stackoverflow.com/questions/25414867/java-1-8-20-compiler-error\">Java 1.8.20 Compiler Error</a>, bug <a href=\"https://bugs.openjdk.java.net/browse/JDK-8051402\">JDK-8051402</a>. That bug has been fixed already, although but the fix isn't in JDK 8u20.</p>\n    "},{"t":"Java 8 method references: provide a Supplier capable of supplying a parameterized result","l":"http://stackoverflow.com/questions/22917138/java-8-method-references-provide-a-supplier-capable-of-supplying-a-parameterize","q":"\n\n<p>I'd like to use </p>\n\n<pre><code>java.util.Optional.orElseThrow()\n</code></pre>\n\n<p>with an Exception type that asks for a constructor parameter. Something like this:</p>\n\n<pre><code>orElseThrow(MyException::new(someArgument)) // obviously NOT working\n</code></pre>\n\n<p>Is there a way to create a Supplier that passes my argument value in?</p>\n    ","a":"\n<p>Sure.  <code>orElseThrow(() -&gt; new MyException(someArgument))</code>.</p>\n    "},{"t":"Java8 Lambdas vs Anonymous classes","l":"http://stackoverflow.com/questions/22637900/java8-lambdas-vs-anonymous-classes","q":"\n\n<p>Since Java8 has been recently released and its brand new lambda expressions looks to be really cool, I was wondering if this means the demise of the Anonymous classes that we were so used to.</p>\n\n<p>I've been researching a bit about this and found some cool examples about how Lambda expressions will systematically replace those classes, such the Collection's sort method, which used to get an Anonymous instance of Comparator to perform the sort: </p>\n\n<pre><code>Collections.sort(personList, new Comparator&lt;Person&gt;(){\n  public int compare(Person p1, Person p2){\n    return p1.firstName.compareTo(p2.firstName);\n  }\n});\n</code></pre>\n\n<p>Now can be done using Lambdas: </p>\n\n<pre><code>Collections.sort(personList, (Person p1, Person p2) -&gt; p1.firstName.compareTo(p2.firstName));\n</code></pre>\n\n<p>And looks surprisingly concise. So my question is, is there any reason to keep using those classes in Java8 instead of Lambdas?</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>Same question but in the opposite direction, what are the benefits of using Lambdas instead of Anonymous classes, since Lambdas can only be used with single method interfaces, is this new feature only a shortcut only used in few cases or is it really useful?</p>\n    ","a":"\n<p>An anonymous inner class (AIC) can be used to create a subclass of an abstract class or a concrete class. An AIC can also provide a concrete implementation of an interface, including the addition of state (fields). An instance of an AIC can be referred to using <code>this</code> in its method bodies, so further methods can be called on it, its state can be mutated over time, etc. None of these apply to lambdas.</p>\n\n<p>I'd guess that the majority of uses of AICs were to provide stateless implementations of single functions and so can be replaced with lambda expressions, but there are other uses of AICs for which lambdas cannot be used. AICs are here to stay.</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>Another difference between AICs and lambda expressions is that AICs introduce a new scope. That is, names are resolved from the AIC's superclasses and interfaces and can shadow names that occur in the lexcially enclosing environment. For lambdas, all names are resolved lexically.</p>\n    "},{"t":"Most efficient way to get the last element of a stream","l":"http://stackoverflow.com/questions/27547519/most-efficient-way-to-get-the-last-element-of-a-stream","q":"\n\n<p>Stream doesn't have a <code>last()</code> method:</p>\n\n<pre><code>Stream&lt;T&gt; stream;\nT last = stream.last(); // I wish\n</code></pre>\n\n<p>so what's the most elegant and or efficient way to get the last element or null for an empty Stream?</p>\n    ","a":"\n<p>Use the <code>reduce()</code> method and keep only the current value:</p>\n\n<pre><code>Stream&lt;T&gt; stream;\nT last = stream.reduce((a, b) -&gt; b);\n</code></pre>\n    "},{"t":"How to specify function types for void (not Void) methods in Java8?","l":"http://stackoverflow.com/questions/14319787/how-to-specify-function-types-for-void-not-void-methods-in-java8","q":"\n\n<p>I'm playing around with Java 8 to find out how functions as first class citizens. I have the following snippet:</p>\n\n<pre><code>package test;\n\nimport java.util.*;\nimport java.util.function.*;\n\npublic class Test {\n\n    public static void myForEach(List&lt;Integer&gt; list, Function&lt;Integer, Void&gt; myFunction) {\n      list.forEach(functionToBlock(myFunction));\n    }\n\n    public static void displayInt(Integer i) {\n      System.out.println(i);\n    }\n\n\n    public static void main(String[] args) {\n      List&lt;Integer&gt; theList = new ArrayList&lt;&gt;();\n      theList.add(1);\n      theList.add(2);\n      theList.add(3);\n      theList.add(4);\n      theList.add(5);\n      theList.add(6);\n      myForEach(theList, Test::displayInt);\n    }\n}\n</code></pre>\n\n<p>What I'm trying to do is pass method <code>displayInt</code> to method <code>myForEach</code> using a method reference. To compiler produces the following error:</p>\n\n<pre><code>src/test/Test.java:9: error: cannot find symbol\n      list.forEach(functionToBlock(myFunction));\n                   ^\n  symbol:   method functionToBlock(Function&lt;Integer,Void&gt;)\n  location: class Test\nsrc/test/Test.java:25: error: method myForEach in class Test cannot be applied to given ty\npes;\n      myForEach(theList, Test::displayInt);\n      ^\n  required: List&lt;Integer&gt;,Function&lt;Integer,Void&gt;\n  found: List&lt;Integer&gt;,Test::displayInt\n  reason: argument mismatch; bad return type in method reference\n      void cannot be converted to Void\n</code></pre>\n\n<p>The compiler complains that <code>void cannot be converted to Void</code>. I don't know how to specify the type of the function interface in the signature of <code>myForEach</code> such that the code compiles. I know I could simply change the return type of <code>displayInt</code> to <code>Void</code> and then return <code>null</code>. However, there may be situations where it's not possible to alter the method I want to pass somewhere else. Is there an easy way to reuse <code>displayInt</code> as it is?</p>\n    ","a":"\n<p>You are trying to use the wrong interface type. The type <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html\">Function</a> is not appropriate in this case because it receives a parameter and has a return value. Instead you should use <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html\">Consumer</a> (formerly known as Block)</p>\n\n<p>The Function type is declared as </p>\n\n<pre><code>interface Function&lt;T,R&gt; {\n  R apply(T t);\n}\n</code></pre>\n\n<p>However, the Consumer type is compatible with that you are looking for:</p>\n\n<pre><code>interface Consumer&lt;T&gt; {\n   void accept(T t);\n}\n</code></pre>\n\n<p>As such, Consumer is compatible with methods that receive a T and return nothing (void). And this is what you want.</p>\n\n<p>For instance, if I wanted to display all element in a list I could simply create a consumer for that with a lambda expression:</p>\n\n<pre><code>List&lt;String&gt; jedis = asList(\"Luke\",\"Obiwan\",\"Quigon\");\njedis.forEach( jedi -&gt; { System.out.println(jedi); } );\n</code></pre>\n\n<p>You can see above that in this case, the lambda expression receives a parameter and has no return value.</p>\n\n<p>Now, if I wanted to use a method reference instead of a lambda expression to create a consume of this type, then I need a method that receives a String and returns void, right?. </p>\n\n<p>I could use different types of method references, but in this case let's take advantage of an object method reference by using the <code>println</code> method in the <code>System.out</code> object, like this:</p>\n\n<pre><code>Consumer&lt;String&gt; block = System.out::println\n</code></pre>\n\n<p>Or I could simply do</p>\n\n<pre><code>jedis.forEach(System.out::println);\n</code></pre>\n\n<p>The <code>println</code> method is appropriate because it receives a value and has a return type void, just like the <code>accept</code> method in Consumer.</p>\n\n<p>So, in your code, you need to change your method signature to somewhat like:</p>\n\n<pre><code>public static void myForEach(List&lt;Integer&gt; list, Consumer&lt;Integer&gt; myBlock) {\n   list.forEach(myBlock);\n}\n</code></pre>\n\n<p>And then you should be able to create a consumer, using a static method reference, in your case by doing:</p>\n\n<pre><code>myForEach(theList, Test::displayInt);\n</code></pre>\n\n<p>Ultimately, you could even get rid of your <code>myForEach</code> method altogether and simply do:</p>\n\n<pre><code>theList.forEach(Test::displayInt);\n</code></pre>\n\n<p><strong>About Functions as First Class Citizens</strong></p>\n\n<p>All been said, the truth is that Java 8 will not have functions as first class citizens since a structural function type will not be added to the language. Java will simply offer syntactic sugar to create implementations of functional interfaces out of lambda expressions and method references. Ultimately lambda expressions and method references will be bound to object references, therefore all we have is objects as first class citizens. The important thing is the the functionality is there, since we can pass objects as parameters, bound them to variable references and return them as values from other methods, then they pretty much serve a similar purpose.</p>\n    "},{"t":"Copy a stream to avoid “stream has already been operated upon or closed” (java 8)","l":"http://stackoverflow.com/questions/23860533/copy-a-stream-to-avoid-stream-has-already-been-operated-upon-or-closed-java-8","q":"\n\n<p>I'd like to duplicate a Java 8 stream so that I can deal with it twice. I can <code>collect</code> as a list and get new streams from that;</p>\n\n<pre><code>// doSomething() returns a stream\nList&lt;A&gt; thing = doSomething().collect(toList());\nthing.stream()... // do stuff\nthing.stream()... // do other stuff\n</code></pre>\n\n<p>but I kind of think there should be a more efficient/elegant way. <strong>Is there a way to copy the stream without turning it into a collection?</strong></p>\n\n<p>I'm actually working with a stream of <code>Either</code>s, so want to process the left projection one way before moving onto the right projection and dealing with that another way. Kind of like this (which, so far, I'm forced to use the <code>toList</code> trick with).</p>\n\n<pre><code>List&lt;Either&lt;Pair&lt;A, Throwable&gt;, A&gt;&gt; results = doSomething().collect(toList());\n\nStream&lt;Pair&lt;A, Throwable&gt;&gt; failures = results.stream().flatMap(either -&gt; either.left());\nfailures.forEach(failure -&gt; ... );\n\nStream&lt;A&gt; successes = results.stream().flatMap(either -&gt; either.right());\nsuccesses.forEach(success -&gt; ... );\n</code></pre>\n    ","a":"\n<p>I think your assumption about efficiency is kind of backwards.  You get this huge efficiency payback if you're only going to use the data once, because you don't have to store it, and streams give you powerful \"loop fusion\" optimizations that let you flow the whole data efficiently through the pipeline.  </p>\n\n<p>If you want to re-use the same data, then by definition you either have to generate it twice (deterministically) or store it.  If it already happens to be in a collection, great; then iterating it twice is cheap.  </p>\n\n<p>We did experiment in the design with \"forked streams\".  What we found was that supporting this had real costs; it burdened the common case (use once) at the expense of the uncommon case.  The big problem was dealing with \"what happens when the two pipelines don't consume data at the same rate.\"  Now you're back to buffering anyway.  This was a feature that clearly didn't carry its weight.  </p>\n\n<p>If you want to operate on the same data repeatedly, either store it, or structure your operations as Consumers and do the following:</p>\n\n<pre><code>stream()...stuff....forEach(e -&gt; { consumerA(e); consumerB(e); });\n</code></pre>\n\n<p>You might also look into the RxJava library, as its processing model lends itself better to this kind of \"stream forking\".</p>\n    "},{"t":"Why is this type inference not working with this Lambda expression scenario?","l":"http://stackoverflow.com/questions/31227149/why-is-this-type-inference-not-working-with-this-lambda-expression-scenario","q":"\n\n<p>I have a weird scenario where type inference isn't working as I'd expect when using a lambda expression. Here's an approximation of my real scenario:</p>\n\n<pre><code>static class Value&lt;T&gt; {\n}\n\n@FunctionalInterface\ninterface Bar&lt;T&gt; {\n  T apply(Value&lt;T&gt; value); // Change here resolves error\n}\n\nstatic class Foo {\n  public static &lt;T&gt; T foo(Bar&lt;T&gt; callback) {\n  }\n}\n\nvoid test() {\n  Foo.foo(value -&gt; true).booleanValue(); // Compile error here\n}\n</code></pre>\n\n<p>The compile error I get on the second to last line is </p>\n\n<blockquote>\n  <p>The method booleanValue() is undefined for the type Object</p>\n</blockquote>\n\n<p>if I cast the lambda to <code>Bar&lt;Boolean&gt;</code>:</p>\n\n<pre><code>Foo.foo((Bar&lt;Boolean&gt;)value -&gt; true).booleanValue();\n</code></pre>\n\n<p>or if I change the method signature of <code>Bar.apply</code> to use raw types:</p>\n\n<pre><code>T apply(Value value);\n</code></pre>\n\n<p>then the problem goes away. The way I'd expect this to work is that:</p>\n\n<ul>\n<li><code>Foo.foo</code> call should infer a return type of <code>boolean</code> </li>\n<li><code>value</code> in the lambda should be inferred to <code>Value&lt;Boolean&gt;</code>. </li>\n</ul>\n\n<p>Why doesn't this inference work as expected and how can I change this API to make it work as expected?</p>\n    ","a":"\n<h2>Under the Hood</h2>\n\n<p>Using some hidden <code>javac</code> features, we can get more information about what's happening:</p>\n\n<pre><code>$ javac -XDverboseResolution=deferred-inference,success,applicable LambdaInference.java \nLambdaInference.java:16: Note: resolving method foo in type Foo to candidate 0\n    Foo.foo(value -&gt; true).booleanValue(); // Compile error here\n       ^\n  phase: BASIC\n  with actuals: &lt;none&gt;\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: &lt;T&gt;foo(Bar&lt;T&gt;)\n        (partially instantiated to: (Bar&lt;Object&gt;)Object)\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: Note: Deferred instantiation of method &lt;T&gt;foo(Bar&lt;T&gt;)\n    Foo.foo(value -&gt; true).booleanValue(); // Compile error here\n           ^\n  instantiated signature: (Bar&lt;Object&gt;)Object\n  target-type: &lt;none&gt;\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: error: cannot find symbol\n    Foo.foo(value -&gt; true).booleanValue(); // Compile error here\n                          ^\n  symbol:   method booleanValue()\n  location: class Object\n1 error\n</code></pre>\n\n<p>This is a lot of information, let's break it down.</p>\n\n<pre><code>LambdaInference.java:16: Note: resolving method foo in type Foo to candidate 0\n    Foo.foo(value -&gt; true).booleanValue(); // Compile error here\n       ^\n  phase: BASIC\n  with actuals: &lt;none&gt;\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: &lt;T&gt;foo(Bar&lt;T&gt;)\n        (partially instantiated to: (Bar&lt;Object&gt;)Object)\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\n</code></pre>\n\n<p>phase: <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.2\" rel=\"nofollow\">method applicability phase</a><br>\nactuals: the actual arguments passed in<br>\ntype-args: explicit type arguments<br>\ncandidates: <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.1\" rel=\"nofollow\">potentially applicable methods</a></p>\n\n<p>actuals is <code>&lt;none&gt;</code> because our implicitly typed lambda is not <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.2\" rel=\"nofollow\">pertinent to applicability</a>.</p>\n\n<p>The compiler resolves your invocation of <code>foo</code> to the only method named <code>foo</code> in <code>Foo</code>. It has been partially instantiated to <code>Foo.&lt;Object&gt; foo</code> (since there were no actuals or type-args), but that can change at the deferred-inference stage.</p>\n\n<pre><code>LambdaInference.java:16: Note: Deferred instantiation of method &lt;T&gt;foo(Bar&lt;T&gt;)\n    Foo.foo(value -&gt; true).booleanValue(); // Compile error here\n           ^\n  instantiated signature: (Bar&lt;Object&gt;)Object\n  target-type: &lt;none&gt;\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\n</code></pre>\n\n<p>instantiated signature: the fully instantiated signature of <code>foo</code>. It is the result of this step (at this point no more type inference will be made on the signature of <code>foo</code>).<br>\ntarget-type: the context the call is being made in. If the method invocation is a part of an assignment, it will be the left hand side. If the method invocation is itself part of a method invocation, it will be the parameter type.</p>\n\n<p>Since your method invocation is dangling, there is no target-type. Since there is no target-type, no more inference can be done on <code>foo</code> and <code>T</code> is inferred to be <code>Object</code>.</p>\n\n<hr>\n\n<h2>Analysis</h2>\n\n<p>The compiler does not use implicitly typed lambdas during inference. To a certain extent, this makes sense. In general, given <code>param -&gt; BODY</code>, you will not be able to compile <code>BODY</code> until you have a type for <code>param</code>. If you did try to infer the type for <code>param</code> from <code>BODY</code>, it might lead to a chicken-and-egg type problem. It's possible that some improvements will be made on this in future releases of Java.</p>\n\n<hr>\n\n<h2>Solutions</h2>\n\n<p><code>Foo.&lt;Boolean&gt; foo(value -&gt; true)</code></p>\n\n<p>This solution provides an explicit type argument to <code>foo</code> (note the <code>with type-args</code> section below). This changes the partial instantiation of the method signature to <code>(Bar&lt;Boolean&gt;)Boolean</code>, which is what you want.</p>\n\n<pre><code>LambdaInference.java:16: Note: resolving method foo in type Foo to candidate 0\n    Foo.&lt;Boolean&gt; foo(value -&gt; true).booleanValue(); // Compile error here\n       ^\n  phase: BASIC\n  with actuals: &lt;none&gt;\n  with type-args: Boolean\n  candidates:\n      #0 applicable method found: &lt;T&gt;foo(Bar&lt;T&gt;)\n        (partially instantiated to: (Bar&lt;Boolean&gt;)Boolean)\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: Note: resolving method booleanValue in type Boolean to candidate 0\n    Foo.&lt;Boolean&gt; foo(value -&gt; true).booleanValue(); // Compile error here\n                                    ^\n  phase: BASIC\n  with actuals: no arguments\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: booleanValue()\n</code></pre>\n\n<hr>\n\n<p><code>Foo.foo((Value&lt;Boolean&gt; value) -&gt; true)</code></p>\n\n<p>This solution explicitly types your lambda, which allows it to be pertinent to applicability (note <code>with actuals</code> below). This changes the partial instantiation of the method signature to <code>(Bar&lt;Boolean&gt;)Boolean</code>, which is what you want.</p>\n\n<pre><code>LambdaInference.java:16: Note: resolving method foo in type Foo to candidate 0\n    Foo.foo((Value&lt;Boolean&gt; value) -&gt; true).booleanValue(); // Compile error here\n       ^\n  phase: BASIC\n  with actuals: Bar&lt;Boolean&gt;\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: &lt;T&gt;foo(Bar&lt;T&gt;)\n        (partially instantiated to: (Bar&lt;Boolean&gt;)Boolean)\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: Note: Deferred instantiation of method &lt;T&gt;foo(Bar&lt;T&gt;)\n    Foo.foo((Value&lt;Boolean&gt; value) -&gt; true).booleanValue(); // Compile error here\n           ^\n  instantiated signature: (Bar&lt;Boolean&gt;)Boolean\n  target-type: &lt;none&gt;\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: Note: resolving method booleanValue in type Boolean to candidate 0\n    Foo.foo((Value&lt;Boolean&gt; value) -&gt; true).booleanValue(); // Compile error here\n                                           ^\n  phase: BASIC\n  with actuals: no arguments\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: booleanValue()\n</code></pre>\n\n<hr>\n\n<p><code>Foo.foo((Bar&lt;Boolean&gt;) value -&gt; true)</code></p>\n\n<p>Same as above, but with a slightly different flavor.</p>\n\n<pre><code>LambdaInference.java:16: Note: resolving method foo in type Foo to candidate 0\n    Foo.foo((Bar&lt;Boolean&gt;) value -&gt; true).booleanValue(); // Compile error here\n       ^\n  phase: BASIC\n  with actuals: Bar&lt;Boolean&gt;\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: &lt;T&gt;foo(Bar&lt;T&gt;)\n        (partially instantiated to: (Bar&lt;Boolean&gt;)Boolean)\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: Note: Deferred instantiation of method &lt;T&gt;foo(Bar&lt;T&gt;)\n    Foo.foo((Bar&lt;Boolean&gt;) value -&gt; true).booleanValue(); // Compile error here\n           ^\n  instantiated signature: (Bar&lt;Boolean&gt;)Boolean\n  target-type: &lt;none&gt;\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: Note: resolving method booleanValue in type Boolean to candidate 0\n    Foo.foo((Bar&lt;Boolean&gt;) value -&gt; true).booleanValue(); // Compile error here\n                                         ^\n  phase: BASIC\n  with actuals: no arguments\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: booleanValue()\n</code></pre>\n\n<hr>\n\n<p><code>Boolean b = Foo.foo(value -&gt; true)</code></p>\n\n<p>This solution provides an explicit target for your method call (see <code>target-type</code> below). This allows the deferred-instantiation to infer that the type parameter should be <code>Boolean</code> instead of <code>Object</code> (see <code>instantiated signature</code> below).</p>\n\n<pre><code>LambdaInference.java:16: Note: resolving method foo in type Foo to candidate 0\n    Boolean b = Foo.foo(value -&gt; true);\n                   ^\n  phase: BASIC\n  with actuals: &lt;none&gt;\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: &lt;T&gt;foo(Bar&lt;T&gt;)\n        (partially instantiated to: (Bar&lt;Object&gt;)Object)\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: Note: Deferred instantiation of method &lt;T&gt;foo(Bar&lt;T&gt;)\n    Boolean b = Foo.foo(value -&gt; true);\n                       ^\n  instantiated signature: (Bar&lt;Boolean&gt;)Boolean\n  target-type: Boolean\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\n</code></pre>\n\n<hr>\n\n<h2>Disclaimer</h2>\n\n<p>This is the behavior that's occurring. I don't know if this is what is specified in the JLS. I could dig around and see if I could find the exact section that specifies this behavior, but <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html\" rel=\"nofollow\">type inference</a> notation gives me a headache.</p>\n\n<p>This also doesn't fully explain why changing <code>Bar</code> to use a raw <code>Value</code> would fix this issue:</p>\n\n<pre><code>LambdaInference.java:16: Note: resolving method foo in type Foo to candidate 0\n    Foo.foo(value -&gt; true).booleanValue();\n       ^\n  phase: BASIC\n  with actuals: &lt;none&gt;\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: &lt;T&gt;foo(Bar&lt;T&gt;)\n        (partially instantiated to: (Bar&lt;Object&gt;)Object)\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: Note: Deferred instantiation of method &lt;T&gt;foo(Bar&lt;T&gt;)\n    Foo.foo(value -&gt; true).booleanValue();\n           ^\n  instantiated signature: (Bar&lt;Boolean&gt;)Boolean\n  target-type: &lt;none&gt;\n  where T is a type-variable:\n    T extends Object declared in method &lt;T&gt;foo(Bar&lt;T&gt;)\nLambdaInference.java:16: Note: resolving method booleanValue in type Boolean to candidate 0\n    Foo.foo(value -&gt; true).booleanValue();\n                          ^\n  phase: BASIC\n  with actuals: no arguments\n  with type-args: no arguments\n  candidates:\n      #0 applicable method found: booleanValue()\n</code></pre>\n\n<p>For some reason, changing it to use a raw <code>Value</code> allows the deferred instantiation to infer that <code>T</code> is <code>Boolean</code>. If I had to speculate, I would guess that when the compiler tries to fit the lambda to the <code>Bar&lt;T&gt;</code>, it can infer that <code>T</code> is <code>Boolean</code> by looking at the body of the lambda. This implies that my earlier analysis is incorrect. The compiler <em>can</em> perform type inference on the body of a lambda, but only on type variables that <em>only</em> appear in the return type.</p>\n    "},{"t":"Is .collect guaranteed to be ordered on parallel streams?","l":"http://stackoverflow.com/questions/29710999/is-collect-guaranteed-to-be-ordered-on-parallel-streams","q":"\n\n<p>Given I have a list of Strings <code>List&lt;String&gt; toProcess</code>. The results have to be in the order the original lines were given.\nI want to utilize the new parallel streams.</p>\n\n<p>Does the following code <strong>guarantee</strong> that the results will be in the same order they were in the original list?</p>\n\n<pre><code>// [\"a\", \"b\", \"c\"]\nList&lt;String&gt; toProcess;\n\n// should be [\"a\", \"b\", \"c\"]\nList&lt;String&gt; results = toProcess.parallelStream()\n                                .map(s -&gt; s)\n                                .collect(Collectors.toList());\n</code></pre>\n    ","a":"\n<h3>Stream.collect() API documentation</h3>\n\n<p>The starting place is to look at what determines whether a reduction is concurrent or not. <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.stream.Collector-\" rel=\"nofollow\"><code>Stream.collect()</code></a>'s description says the following:</p>\n\n<blockquote>\n  <p>If the stream is parallel, and the <code>Collector</code> is <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#CONCURRENT\" rel=\"nofollow\">concurrent</a>, and either the stream is unordered or the collector is <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#UNORDERED\" rel=\"nofollow\">unordered</a>, then a concurrent reduction will be performed (see <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html\" rel=\"nofollow\"><code>Collector</code></a> for details on concurrent reduction.)</p>\n</blockquote>\n\n<p>The first condition is satisfied: the stream is parallel. How about the second and third: is the <code>Collector</code> concurrent and unordered?<br>\n&nbsp;</p>\n\n<h3>Collectors.toList() API documentation</h3>\n\n<p><a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toList--\" rel=\"nofollow\"><code>toList()</code></a>'s documentation reads:</p>\n\n<blockquote>\n  <p>Returns a <code>Collector</code> that accumulates the input elements into a new <code>List</code>. There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>List</code> returned; if more control over the returned <code>List</code> is required, use <code>toCollection(Supplier)</code>.</p>\n  \n  <p>Returns:<br>\n  a Collector which collects all the input elements into a List, <strong>in encounter order</strong></p>\n</blockquote>\n\n<p>An operation that works in <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Ordering\" rel=\"nofollow\">encounter order</a> operates on the elements in their original order. This overrides parallelness.<br>\n&nbsp;</p>\n\n<h3>Implementation code</h3>\n\n<p>Inspecting the implementation of <code>Collectors.java</code> confirms that <code>toList()</code> does <strong>not</strong> include the <code>CONCURRENT</code> or <code>UNORDERED</code> traits.</p>\n\n<pre><code>public static &lt;T&gt;\nCollector&lt;T, ?, List&lt;T&gt;&gt; toList() {\n    return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add,\n                               (left, right) -&gt; { left.addAll(right); return left; },\n                               CH_ID);\n}\n\n// ...\n\nstatic final Set&lt;Collector.Characteristics&gt; CH_ID\n        = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));\n</code></pre>\n\n<p>Notice how the collector has the <code>CH_ID</code> trait set, which has only the single <code>IDENTITY_FINISH</code> trait. <code>CONCURRENT</code> and <code>UNORDERED</code> are not there, so the reduction cannot be concurrent.</p>\n\n<p>A non-concurrent reduction means that, if the stream is parallel, collection can proceed in parallel, but it will be split into several thread-confined intermediate results which are then combined. This ensures the combined result is in encounter order.<br>\n&nbsp;</p>\n\n<h3>Conclusion</h3>\n\n<p>Yes, the order is guaranteed.<br>\n&nbsp;</p>\n\n<p><strong>See also:</strong> <a href=\"http://stackoverflow.com/questions/29709140/why-parallel-stream-get-collected-sequentially-in-java-8/29713386#29713386\">Why parallel stream get collected sequentially in Java 8</a></p>\n    "},{"t":"How to debug stream().map(…) with lambda expressions?","l":"http://stackoverflow.com/questions/24541786/how-to-debug-stream-map-with-lambda-expressions","q":"\n\n<p>In our project we are migrating to java 8 and we are testing the new features of it.</p>\n\n<p>On my project I'm using Guava predicates and functions to filter and transform some collections using <code>Collections2.transform</code> and <code>Collections2.filter</code>. </p>\n\n<p>On this migration I need to change for example guava code to java 8 changes. So, the changes I'm doing are the kind of:</p>\n\n<pre><code>List&lt;Integer&gt; naturals = Lists.newArrayList(1,2,3,4,5,6,7,8,9,10,11,12,13);\n\nFunction &lt;Integer, Integer&gt; duplicate = new Function&lt;Integer, Integer&gt;(){\n    @Override\n    public Integer apply(Integer n)\n    {\n        return n * 2;\n    }\n};\n\nCollection result = Collections2.transform(naturals, duplicate);\n</code></pre>\n\n<p>To...</p>\n\n<pre><code>List&lt;Integer&gt; result2 = naturals.stream()\n    .map(n -&gt; n * 2)\n    .collect(Collectors.toList());\n</code></pre>\n\n<p>Using guava I was very confortable debugging the code since I could debug each transformation process but my concern is how to debug for example <code>.map(n -&gt; n*2)</code>.</p>\n\n<p>Using the debugger I can see some code like:</p>\n\n<pre><code>@Hidden\n@DontInline\n/** Interpretively invoke this form on the given arguments. */\nObject interpretWithArguments(Object... argumentValues) throws Throwable {\n    if (TRACE_INTERPRETER)\n        return interpretWithArgumentsTracing(argumentValues);\n    checkInvocationCounter();\n    assert(arityCheck(argumentValues));\n    Object[] values = Arrays.copyOf(argumentValues, names.length);\n    for (int i = argumentValues.length; i &lt; values.length; i++) {\n        values[i] = interpretName(names[i], values);\n    }\n    return (result &lt; 0) ? null : values[result];\n}\n</code></pre>\n\n<p>But it isn't as straighforward as Guava to debug the code, actually I couldn't find the <code>n * 2</code> transformation.</p>\n\n<p>Is there a way to see this transformation or a way to easy debug this code?</p>\n\n<p><strong>EDIT: I've added answer from different comments and posted answers</strong></p>\n\n<p>Thanks to <code>Holger</code> comment that answered my question, the approach of having lambda block allowed me to see the transformation process and debug what happened inside lambda body:</p>\n\n<pre><code>.map(\n    n -&gt; {\n        Integer nr = n * 2;\n        return nr;\n    }\n)\n</code></pre>\n\n<p>Thanks to <code>Stuart Marks</code> the approach of having method references also allowed me to debug the transformation process:</p>\n\n<pre><code>static int timesTwo(int n) {\n    Integer result = n * 2;\n    return result;\n}\n...\nList&lt;Integer&gt; result2 = naturals.stream()\n    .map(Java8Test::timesTwo)\n    .collect(Collectors.toList());\n...\n</code></pre>\n\n<p>Thanks to <code>Marlon Bernardes</code> answer I noticed that my Eclipse doesn't show what it should and the usage of peek() helped to display results. </p>\n    ","a":"\n<p>I usually have no problem debugging lambda expressions while using Eclipse Kepler or Intellij IDEA (using JDK8u5). Just set a breakpoint and be sure not to inspect the whole lambda expression (inspect only the lambda body). </p>\n\n<p><img src=\"http://i.stack.imgur.com/GdDMO.png\" alt=\"Debugging Lambdas\"></p>\n\n<p>Another approach is to use <code>peek</code> to inspect the elements of the stream:</p>\n\n<pre><code>List&lt;Integer&gt; naturals = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13);\nnaturals.stream()\n    .map(n -&gt; n * 2)\n    .peek(System.out::println)\n    .collect(Collectors.toList());\n</code></pre>\n\n<p><strong>UPDATE:</strong></p>\n\n<p>I think you're getting confused because <code>map</code> is an <code>intermediate operation</code> - in other words: it is a lazy operation which will be executed only after a <code>terminal operation</code> was executed. So when you call <code>stream.map(n -&gt; n * 2)</code> the lambda body isn't being executed at the moment. You need to set a breakpoint and inspect it after a terminal operation was called (<code>collect</code>, in this case).</p>\n\n<p>Check <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\">Stream Operations</a> for further explanations.</p>\n\n<p><strong>UPDATE 2:</strong></p>\n\n<p>Quoting <a href=\"http://stackoverflow.com/users/2711488/holger\">Holger's</a> comment: </p>\n\n<blockquote>\n  <p>What makes it tricky here is that the call to map and the lambda\n  expression are in one line so a line breakpoint will stop on two\n  completely unrelated actions. </p>\n  \n  <p>Inserting a line break right after <code>map(</code>\n  would allow you to set a break point for the lambda expression only.\n  And it’s not unusual that debuggers don’t show intermediate values of\n  a <code>return</code> statement. Changing the lambda to <code>n -&gt; { int result=n * 2; return result; }</code>\n  would allow you to inspect result. Again, insert line\n  breaks appropriately when stepping line by line…</p>\n</blockquote>\n    "},{"t":"Why is the max recursion depth I can reach non-deterministic?","l":"http://stackoverflow.com/questions/27043922/why-is-the-max-recursion-depth-i-can-reach-non-deterministic","q":"\n\n<p>I decided to try a few experiments to see what I could discover about the size of stack frames, and how far through the stack the currently executing code was. There are two interesting questions we might investigate here:</p>\n\n<ol>\n<li>How many levels deep into the stack is the current code?</li>\n<li>How many levels of recursion can the current method reach before it hits a <code>StackOverflowError</code>?</li>\n</ol>\n\n<h1>Stack depth of currently executing code</h1>\n\n<p>Here's the best I could come up with for this:</p>\n\n<pre><code>public static int levelsDeep() {\n    try {\n        throw new SomeKindOfException();\n    } catch (SomeKindOfException e) {\n        return e.getStackTrace().length;\n    }\n}\n</code></pre>\n\n<p>This seems a bit hacky. It generates and catches an exception, and then looks to see what the length of the stack trace is.</p>\n\n<p>Unfortunately it also seems to have a fatal limitation, which is that the maximum length of the stack trace returned is 1024. Anything beyond that gets axed, so the maximum that this method can return is 1024.</p>\n\n<blockquote>\n  <p></p><h2>Question:</h2> Is there a better way of doing this that isn't so hacky and doesn't have this limitation?<p></p>\n</blockquote>\n\n<p>For what it's worth, my guess is that there isn't: <code>Throwable.getStackTraceDepth()</code> is a native call, which suggests (but doesn't prove it) that it can't be done in pure Java.</p>\n\n<h1>Determining how much more recursion depth we have left</h1>\n\n<p>The number of levels we can reach will be determined by (a) size of stack frame, and (b) amount of stack left. Let's not worry about size of stack frame, and just see how many levels we can reach before we hit a <code>StackOverflowError</code>.</p>\n\n<p>Here's my code for doing this:</p>\n\n<pre><code>public static int stackLeft() {\n    try {\n        return 1+stackLeft();\n    } catch (StackOverflowError e) {\n        return 0;\n    }\n}\n</code></pre>\n\n<p>It does its job admirably, even if it's linear in the amount of stack remaining. But here is the very, very weird part. On 64-bit Java 7 (OpenJDK 1.7.0_65), the results are perfectly consistent: 9,923, on my machine (Ubuntu 14.04 64-bit). But Oracle's Java 8 (1.8.0_25) gives me <strong>non-deterministic results</strong>: I get a recorded depth of anywhere between about 18,500 and 20,700.</p>\n\n<p>Now why on earth would it be non-deterministic? There's supposed to be a fixed stack size, isn't there? And all of the code looks deterministic to me.</p>\n\n<p>I wondered whether it was something weird with the error trapping, so I tried this instead:</p>\n\n<pre><code>public static long badSum(int n) {\n    if (n==0)\n        return 0;\n    else\n        return 1+badSum(n-1);\n}\n</code></pre>\n\n<p>Clearly this will either return the input it was given, or overflow.</p>\n\n<p>Again, the results I get are non-deterministic on Java 8. If I call <code>badSum(14500)</code>, it will give me a <code>StackOverflowError</code> about half the time, and return 14500 the other half. but on Java 7 OpenJDK, it's consistent: <code>badSum(9160)</code> completes fine, and <code>badSum(9161)</code> overflows.</p>\n\n<blockquote>\n  <p></p><h2>Question:</h2> Why is the maximum recursion depth non-deterministic on Oracle's Java 8? And why is it deterministic on OpenJDK 7?<p></p>\n</blockquote>\n    ","a":"\n<p>The observed behavior is affected by the HotSpot optimizer, however it is not the only cause. When I run the following code</p>\n\n<pre><code>public static void main(String[] argv) {\n    System.out.println(System.getProperty(\"java.version\"));\n    System.out.println(countDepth());\n    System.out.println(countDepth());\n    System.out.println(countDepth());\n    System.out.println(countDepth());\n    System.out.println(countDepth());\n    System.out.println(countDepth());\n    System.out.println(countDepth());\n}\nstatic int countDepth() {\n    try { return 1+countDepth(); }\n    catch(StackOverflowError err) { return 0; }\n}\n</code></pre>\n\n<p>with JIT enabled, I get results like:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>&gt; f:\\Software\\jdk1.8.0_40beta02\\bin\\java -Xss68k -server -cp build\\classes X\n1.8.0_40-ea\n2097\n4195\n4195\n4195\n12587\n12587\n12587\n\n&gt; f:\\Software\\jdk1.8.0_40beta02\\bin\\java -Xss68k -server -cp build\\classes X\n1.8.0_40-ea\n2095\n4193\n4193\n4193\n12579\n12579\n12579\n\n&gt; f:\\Software\\jdk1.8.0_40beta02\\bin\\java -Xss68k -server -cp build\\classes X\n1.8.0_40-ea\n2087\n4177\n4177\n12529\n12529\n12529\n12529\n</code></pre>\n\n<p>Here, the effect of the JIT is clearly visible, obviously the optimized code needs less stack space, and it’s shown that tiered compilation is enabled (indeed, using <code>-XX:-TieredCompilation</code> shows a single jump if the program runs long enough).</p>\n\n<p>In contrast, with disabled JIT I get the following results:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>&gt; f:\\Software\\jdk1.8.0_40beta02\\bin\\java -Xss68k -server -Xint -cp build\\classes X\n1.8.0_40-ea\n2104\n2104\n2104\n2104\n2104\n2104\n2104\n\n&gt; f:\\Software\\jdk1.8.0_40beta02\\bin\\java -Xss68k -server -Xint -cp build\\classes X\n1.8.0_40-ea\n2076\n2076\n2076\n2076\n2076\n2076\n2076\n\n&gt; f:\\Software\\jdk1.8.0_40beta02\\bin\\java -Xss68k -server -Xint -cp build\\classes X\n1.8.0_40-ea\n2105\n2105\n2105\n2105\n2105\n2105\n2105\n</code></pre>\n\n<p>The values still vary, but not within the single runtime thread and with a lesser magnitude.</p>\n\n<p>So, there is a (rather small) difference that becomes much larger if the optimizer can reduce the stack space required per method invocation, e.g. due to inlining.</p>\n\n<p>What can cause such a difference? I don’t know how this JVM does it but one scenario could be that the way a stack limit is enforced requires a certain alignment of the stack <em>end</em> address (e.g. matching memory page sizes) while the memory <em>allocation</em> returns memory with a start address that has a weaker alignment guaranty. Combine such a scenario with <a href=\"http://en.wikipedia.org/wiki/Address_space_layout_randomization\">ASLR</a> and there might be always a difference, within the size of the alignment requirement.</p>\n    "},{"t":"Lambda behaving differently than anonymous inner class","l":"http://stackoverflow.com/questions/22648079/lambda-behaving-differently-than-anonymous-inner-class","q":"\n\n<p>While doing some basic lambda exercises, the output from an apparently identical anonymous inner class was giving me a different output than the lambda.</p>\n\n<pre><code>interface Supplier&lt;T&gt; {\n\n    T get(T t);\n}\n</code></pre>\n\n<p><strong>Scenario #1</strong></p>\n\n<pre><code>Supplier&lt;Integer&gt; s1 = new Supplier&lt;Integer&gt;() {\n    @Override\n    public Integer get(Integer t) {\n        return t;\n    }\n};\nSupplier&lt;Integer&gt; s2 = t -&gt; t;\nSystem.out.println(s1.get(2));\nSystem.out.println(s2.get(2));\n</code></pre>\n\n<p>Outputs <strong>2</strong> and <strong>2</strong>. Nothing new here.</p>\n\n<hr>\n\n<p>But when I do this:</p>\n\n<p><strong>Scenario #2</strong></p>\n\n<pre><code>Supplier&lt;Integer&gt; s1 = new Supplier&lt;Integer&gt;() {\n    @Override\n    public Integer get(Integer t) {\n        return t++;\n    }\n};\nSupplier&lt;Integer&gt; s2 = t -&gt; t++;\nSystem.out.println(s1.get(2));\nSystem.out.println(s2.get(2));\n</code></pre>\n\n<p>Outputs <strong>2</strong> and <strong>3</strong></p>\n\n<p><strong>QUESTION: Shouldn't both outputs be identical? Am I missing something?</strong></p>\n\n<hr>\n\n<p>For the sake of completeness:\n<strong>Scenario #3</strong></p>\n\n<pre><code>Supplier&lt;Integer&gt; s1 = new Supplier&lt;Integer&gt;() {\n    @Override\n    public Integer get(Integer t) {\n        return ++t;\n    }\n};\nSupplier&lt;Integer&gt; s2 = t -&gt; ++t;\nSystem.out.println(s1.get(2));\nSystem.out.println(s2.get(2));\n</code></pre>\n\n<p>Outputs <strong>3</strong> and <strong>3</strong>. Nothing new here as well.</p>\n\n<p><strong>UPDATE: Still getting same output from 1.8.0-b132</strong></p>\n\n<p><strong>UPDATE #2: Bug report:</strong> <a href=\"https://bugs.openjdk.java.net/browse/JDK-8038420\">https://bugs.openjdk.java.net/browse/JDK-8038420</a></p>\n\n<p><strong>UPDATE #3: The bug has been fixed in javac, you should be able to obtain the same result now.</strong></p>\n    ","a":"\n<p>According to generated bytecode:</p>\n\n<blockquote>\n  <p>Java(TM) SE Runtime Environment (build 1.8.0-b132)</p>\n</blockquote>\n\n<p><strong>Lambda:</strong></p>\n\n<pre><code> private static java.lang.Integer lambda$main$0(java.lang.Integer);\n   descriptor: (Ljava/lang/Integer;)Ljava/lang/Integer;\n   flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC\n   Code:\n     stack=2, locals=2, args_size=1\n        0: aload_0\n        1: invokevirtual #9                  // Method java/lang/Integer.intValue:()I\n        4: iconst_1\n        5: iadd\n        6: invokestatic  #6                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n        9: dup\n       10: astore_0\n       11: astore_1\n       12: aload_0\n       13: areturn\n     LineNumberTable:\n       line 20: 0\n     LocalVariableTable:\n       Start  Length  Slot  Name   Signature\n           0      14     0     t   Ljava/lang/Integer;\n</code></pre>\n\n<p><strong>Anonymous class:</strong></p>\n\n<pre><code>  public java.lang.Integer get(java.lang.Integer);\n    descriptor: (Ljava/lang/Integer;)Ljava/lang/Integer;\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=4, args_size=2\n         0: aload_1\n         1: astore_2\n         2: aload_1\n         3: invokevirtual #2                  // Method java/lang/Integer.intValue:()I\n         6: iconst_1\n         7: iadd\n         8: invokestatic  #3                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n        11: dup\n        12: astore_1\n        13: astore_3\n        14: aload_2\n        15: areturn\n      LineNumberTable:\n        line 16: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      16     0  this   LTest$1;\n            0      16     1     t   Ljava/lang/Integer;\n</code></pre>\n\n<p>As you can see, in anonymous class after loading variable from local variable table (method parameter <strong>t</strong>) runtime store copy of parameter in another variable (<strong>astore_2</strong>) and then use this copy of parameter as returning value.</p>\n\n<p>Lambda method doesn't make copy of parameter (load -&gt; unbox -&gt; add 1 -&gt; box -&gt; store -&gt; load -&gt; return).</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>It's definitely a javac bug.</p>\n\n<p>I got source from <a href=\"http://hg.openjdk.java.net/jdk8u/jdk8u\">http://hg.openjdk.java.net/jdk8u/jdk8u</a> </p>\n\n<p>Anonymous class and lambda converts to following intermediate representations:</p>\n\n<pre><code>@Override()\npublic Integer get(Integer t) {\n    return (let /*synthetic*/ final Integer $112619572 = t in \n       (let /*synthetic*/ final Integer $1295226194 = t = Integer.valueOf((int)(t.intValue() + 1)) in $112619572));\n}\n\n/*synthetic*/ private static Integer lambda$main$0(final Integer t) {\n    return (let /*synthetic*/ final Integer $1146147158 = t = Integer.valueOf((int)(t.intValue() + 1)) in t);\n}\n</code></pre>\n\n<p>In lambda generated method parameter marked as final, because LambdaToMethod translator \nmarks all parameters as FINAL (according source code <strong>LambdaTranslationContext.translate(…):1899</strong>).</p>\n\n<p>Then let expression builder checks variable flags and when if it’s final omits temporary variable generation\n(according source code <strong>Lower.abstractRval(…):2277</strong>), because modification considered to be prohibited.</p>\n\n<p>Possible solutions:</p>\n\n<ol>\n<li>Forbid parameter modification inside lambda or</li>\n<li><p>Remove FINAL flag from local variable (<strong>LambdaTranslationContext.translate(…):1894</strong>)\nand parameter (<strong>LambdaTranslationContext.translate(…):1899</strong>) in lamda generated method:</p>\n\n<pre><code> case LOCAL_VAR:\n   ret = new VarSymbol(FINAL, name, types.erasure(sym.type), translatedSym);\n ...\n\n case PARAM:\n   ret = new VarSymbol(FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym);\n ...\n</code></pre></li>\n</ol>\n\n<p>I removed FINAL flag and got expected results on tests from: <a href=\"https://bugs.openjdk.java.net/browse/JDK-8038420\">https://bugs.openjdk.java.net/browse/JDK-8038420</a></p>\n    "},{"t":"Method overload ambiguity with Java 8 ternary conditional and unboxed primitives","l":"http://stackoverflow.com/questions/30130720/method-overload-ambiguity-with-java-8-ternary-conditional-and-unboxed-primitives","q":"\n\n<p>The following is code compiles in Java 7, but not openjdk-1.8.0.45-31.b13.fc21.</p>\n\n<pre><code>static void f(Object o1, int i) {}\nstatic void f(Object o1, Object o2) {}\n\nstatic void test(boolean b) {\n    String s = \"string\";\n    double d = 1.0;\n    // The supremum of types 'String' and 'double' is 'Object'\n    Object o = b ? s : d;\n    Double boxedDouble = d;\n    int i = 1;\n    f(o,                   i); // fine\n    f(b ? s : boxedDouble, i); // fine\n    f(b ? s : d,           i); // ERROR!  Ambiguous\n}\n</code></pre>\n\n<p>The compiler claims the last method call ambiguous.</p>\n\n<p>If we change the type of the second parameter of <code>f</code> from <code>int</code> to <code>Integer</code>, then the code compiles on both platforms.  Why doesn't the posted code compile in Java 8?</p>\n    ","a":"\n<p>Let's first consider a simplified version that doesn't have a ternary conditional and doesn't compile on Java HotSpot VM (build 1.8.0_25-b17):</p>\n\n<pre><code>public class Test {\n\n    void f(Object o1, int i) {}\n    void f(Object o1, Object o2) {}\n\n    void test() {\n        double d = 1.0;\n\n        int i = 1;\n        f(d, i); // ERROR!  Ambiguous\n    }\n}\n</code></pre>\n\n<p>The compiler error is:</p>\n\n<pre><code>Error:(12, 9) java: reference to f is ambiguous\nboth method f(java.lang.Object,int) in test.Test and method f(java.lang.Object,java.lang.Object) in test.Test match\n</code></pre>\n\n<p>According to <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2\" rel=\"nofollow\">JLS 15.12.2. Compile-Time Step 2: Determine Method Signature</a> </p>\n\n<blockquote>\n  <p>A method is applicable if it is applicable by one of strict invocation (§15.12.2.2), loose invocation (§15.12.2.3), or variable arity invocation (§15.12.2.4).</p>\n</blockquote>\n\n<p>Invocation has to do with invocation context which is explained here <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.3\" rel=\"nofollow\">JLS 5.3. Invocation Contexts</a></p>\n\n<p>When no boxing or unboxing is involved for a method invocation then strict invocation applies. When boxing or unboxing is involved for a method invocation then loose invocation applies. </p>\n\n<p>Identifying applicable methods is divided into 3 phases. </p>\n\n<p>The first phase (§15.12.2.2) performs overload resolution without permitting boxing or unboxing conversion, or the use of variable arity method invocation. <strong>If no applicable method is found during this phase then processing continues to the second phase.</strong></p>\n\n<p>The second phase (§15.12.2.3) performs overload resolution while allowing boxing and unboxing, but still precludes the use of variable arity method invocation. <strong>If no applicable method is found during this phase then processing continues to the third phase.</strong></p>\n\n<p>The third phase (§15.12.2.4) allows overloading to be combined with variable arity methods, boxing, and unboxing.</p>\n\n<p>For our case there are no methods applicable by strict invocation. Both methods are applicable by loose invocation since the double value has to be boxed.</p>\n\n<p>According to <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5\" rel=\"nofollow\">JLS 15.12.2.5 Choosing the Most Specific Method</a>:</p>\n\n<blockquote>\n  <p>If more than one member method is both accessible and applicable to a\n  method invocation, it is necessary to choose one to provide the\n  descriptor for the run-time method dispatch. The Java programming\n  language uses the rule that the most specific method is chosen.</p>\n</blockquote>\n\n<p>Then:</p>\n\n<blockquote>\n  <p>One applicable method m1 is more specific than another applicable\n  method m2, for an invocation with argument expressions e1, ..., ek, if\n  any of the following are true:</p>\n  \n  <ol>\n  <li><p>m2 is generic, and m1 is inferred to be more specific than m2 for\n  argument expressions e1, ..., ek by §18.5.4.</p></li>\n  <li><p>m2 is not generic, and m1 and m2 are applicable by strict or loose\n  invocation, and where m1 has formal parameter types S1, ..., Sn and m2\n  has formal parameter types T1, ..., Tn, the type Si is more specific\n  than Ti for argument ei for all i (1 ≤ i ≤ n, n = k).</p></li>\n  <li><p>m2 is not generic, and m1 and m2 are applicable by variable arity\n  invocation, and where the first k variable arity parameter types of m1\n  are S1, ..., Sk and the first k variable arity parameter types of m2\n  are T1, ..., Tk, the type Si is more specific than Ti for argument ei\n  for all i (1 ≤ i ≤ k). Additionally, if m2 has k+1 parameters, then\n  the k+1'th variable arity parameter type of m1 is a subtype of the\n  k+1'th variable arity parameter type of m2.</p></li>\n  </ol>\n  \n  <p>The above conditions are the only circumstances under which one method may be more specific than another.</p>\n  \n  <p>A type S is more specific than a type T for any expression if S &lt;: T (§4.10).</p>\n</blockquote>\n\n<p>It may look that the 2nd condition matches for this case but in fact it doesn't because <em>int</em> is not a subtype of Object: it's not true that <em>int</em> &lt;: <em>Object</em>. However if we replace int with Integer in the f method signature this condition would match. Note that the 1st parameter in methods matches this condition since <em>Object</em> &lt;: <em>Object</em> is true.</p>\n\n<p>According to <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.10\" rel=\"nofollow\">$4.10</a> no subtype/supertype relation is defined between primitive types and Class/Interface types. So <em>int</em> is not a subtype of <em>Object</em> for example. Thus <em>int</em> is not more specific than <em>Object</em>.</p>\n\n<p>Since among the 2 methods there are no <em>more specific methods</em> thus there can be no <em>strictly more specific</em> and can be no <em>most specific</em> method (the JLS gives definitions for those terms in the same paragraph <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5\" rel=\"nofollow\">JLS 15.12.2.5 Choosing the Most Specific Method</a>). So both methods are <em>maximally specific</em>.</p>\n\n<p>In this case the JLS gives 2 options: </p>\n\n<blockquote>\n  <p>If all the maximally specific methods have override-equivalent signatures (§8.4.2) ...</p>\n</blockquote>\n\n<p>This is not our case, thus</p>\n\n<blockquote>\n  <p>Otherwise, the method invocation is ambiguous, and a compile-time error occurs.</p>\n</blockquote>\n\n<p>The compile-time error for our case looks valid according to the JLS. </p>\n\n<p><strong>What happens if we change method parameter type from int to Integer?</strong></p>\n\n<p>In this case both methods are still applicable by loose invocation. However the method with Integer parameter is more specific than the method with 2 Object parameters since Integer &lt;: Object. The method with Integer parameter is strictly more specific and most specific thus the compiler will choose it and not throw a compile error.</p>\n\n<p><strong>What happens if we change double to Double in this line: double d = 1.0;?</strong></p>\n\n<p>In this case there is exactly 1 method applicable by strict invocation: no boxing or unboxing is required for invocation of this method: f(Object o1, int i). For the other method you need to do boxing of int value so it's applicable by loose invocation. The compiler can choose the method applicable by strict invocation thus no compiler error is thrown. </p>\n\n<p>As Marco13 pointed out in his comment there is a similar case discussed in this post <a href=\"http://stackoverflow.com/questions/23020493/why-is-this-method-overloading-ambiguous\">Why is this method overloading ambiguous?</a></p>\n\n<p>As explained in the answer there were some major changes related to the method invocation mechanisms between Java 7 and Java 8. This explains why the code compiles in Java 7 but not in Java 8. </p>\n\n<hr>\n\n<p><strong>Now comes the fun part!</strong></p>\n\n<p>Let's add a ternary conditional operator:</p>\n\n<pre><code>public class Test {\n\n    void f(Object o1, int i) {\n        System.out.println(\"1\");\n    }\n    void f(Object o1, Object o2) {\n        System.out.println(\"2\");\n    }\n\n    void test(boolean b) {\n        String s = \"string\";\n        double d = 1.0;\n        int i = 1;\n\n        f(b ? s : d, i); // ERROR!  Ambiguous\n    }\n\n    public static void main(String[] args) {\n        new Test().test(true);\n    }\n}\n</code></pre>\n\n<p>The compiler complains about ambiguous method invocation. \nThe <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2\" rel=\"nofollow\">JLS 15.12.2</a> doesn't dictate any special rules related to ternary conditional operators when performing method invocations. </p>\n\n<p>However there are <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25\" rel=\"nofollow\">JLS 15.25 Conditional Operator ? :</a> and <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25.3\" rel=\"nofollow\">JLS 15.25.3. Reference Conditional Expressions</a>. The former one categorizes conditional expressions into 3 subcategories: boolean, numeric and reference conditional expression. The second and third operands of our conditional expression have types String and double respectively. According to the JLS our conditional expression is a reference conditional expression.</p>\n\n<p>Then according to <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25.3\" rel=\"nofollow\">JLS 15.25.3. Reference Conditional Expressions</a> our conditional expression is a poly reference conditional expression since it appears in an invocation context. The type of our poly conditional expression thus is Object (the target type in the invocation context). From here we could continue the steps as if the first parameter is Object in which case the compiler should choose the method with int as the second parameter (and not throw the compiler error). </p>\n\n<p>The tricky part is this note from JLS:</p>\n\n<blockquote>\n  <p>its second and third operand expressions similarly appear in a context of the same kind with target type T.</p>\n</blockquote>\n\n<p>From this we can assume (also the \"poly\" in the name implies this) that in the context of method invocation the 2 operands should be considered independently. What this means is that when the compiler has to decide whether a boxing operation is required for such argument it should look into each of the operands and see if a boxing may be required. For our specific case String doesn't require boxing and double will require boxing. Thus the compiler decides that for both overloaded methods it should be a loose method invocation. Further steps are the same as in the case when instead of a ternary conditional expression we use a double value.</p>\n\n<p>From the explanation above it seems that the JLS itself is vague and ambiguous in the part related to conditional expressions when applied to overloaded methods so we had to make some assumptions. </p>\n\n<p>What's interesting is that my IDE (IntelliJ IDEA) doesn't detect the last case (with the ternary conditional expression) as a compiler error. All other cases it detects according to the java compiler from JDK. This means that either JDK java  compiler or the internal IDE parser has a bug. </p>\n    "},{"t":"Usage of multiple inheritance in Java 8","l":"http://stackoverflow.com/questions/22052330/usage-of-multiple-inheritance-in-java-8","q":"\n\n<p>Am I <em>using</em> a feature of Java 8 or <em>misusing</em> it? </p>\n\n<p>Refer the code and explanation below to know as to why it was chosen to be like this.</p>\n\n<pre><code>public interface Drawable {\n    public void compileProgram();\n\n    public Program getProgram();\n\n    default public boolean isTessellated() {\n        return false;\n    }\n\n    default public boolean isInstanced() {\n        return false;\n    }\n\n    default public int getInstancesCount() {\n        return 0;\n    }\n\n    public int getDataSize();\n\n    public FloatBuffer putData(final FloatBuffer dataBuffer);\n\n    public int getDataMode();\n\n    public boolean isShadowReceiver();\n\n    public boolean isShadowCaster();    //TODO use for AABB calculations\n\n    default public void drawDepthPass(final int offset, final Program depthNormalProgram, final Program depthTessellationProgram) {\n        Program depthProgram = (isTessellated()) ? depthTessellationProgram : depthNormalProgram;\n        if (isInstanced()) {\n            depthProgram.use().drawArraysInstanced(getDataMode(), offset, getDataSize(), getInstancesCount());\n        }\n        else {\n            depthProgram.use().drawArrays(getDataMode(), offset, getDataSize());\n        }\n    }\n\n    default public void draw(final int offset) {\n        if (isInstanced()) {\n            getProgram().use().drawArraysInstanced(getDataMode(), offset, getDataSize(), getInstancesCount());\n        }\n        else {\n            getProgram().use().drawArrays(getDataMode(), offset, getDataSize());\n        }\n    }\n\n    default public void delete() {\n        getProgram().delete();\n    }\n\n    public static int countDataSize(final Collection&lt;Drawable&gt; drawables) {\n        return drawables.stream()\n                .mapToInt(Drawable::getDataSize)\n                .sum();\n    }\n\n    public static FloatBuffer putAllData(final List&lt;Drawable&gt; drawables) {\n        FloatBuffer dataBuffer = BufferUtils.createFloatBuffer(countDataSize(drawables) * 3);\n        drawables.stream().forEachOrdered(drawable -&gt; drawable.putData(dataBuffer));\n        return (FloatBuffer)dataBuffer.clear();\n    }\n\n    public static void drawAllDepthPass(final List&lt;Drawable&gt; drawables, final Program depthNormalProgram, final Program depthTessellationProgram) {\n        int offset = 0;\n        for (Drawable drawable : drawables) {\n            if (drawable.isShadowReceiver()) {\n                drawable.drawDepthPass(offset, depthNormalProgram, depthTessellationProgram);\n            }\n            offset += drawable.getDataSize();   //TODO count offset only if not shadow receiver?\n        }\n    }\n\n    public static void drawAll(final List&lt;Drawable&gt; drawables) {\n        int offset = 0;\n        for (Drawable drawable : drawables) {\n            drawable.draw(offset);\n            offset += drawable.getDataSize();\n        }\n    }\n\n    public static void deleteAll(final List&lt;Drawable&gt; drawables) {\n        drawables.stream().forEach(Drawable::delete);\n    }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>public interface TessellatedDrawable extends Drawable {\n    @Override\n    default public boolean isTessellated() {\n        return true;\n    }\n}\n</code></pre>\n\n<hr>\n\n<pre><code>public interface InstancedDrawable extends Drawable {\n    @Override\n    default public boolean isInstanced() {\n        return true;\n    }\n\n    @Override\n    public int getInstancesCount();\n}\n</code></pre>\n\n<hr>\n\n<pre><code>public class Box implements TessellatedDrawable, InstancedDrawable {\n    //&lt;editor-fold defaultstate=\"collapsed\" desc=\"keep-imports\"&gt;\n    static {\n        int KEEP_LWJGL_IMPORTS = GL_2_BYTES | GL_ALIASED_LINE_WIDTH_RANGE | GL_ACTIVE_TEXTURE | GL_BLEND_COLOR | GL_ARRAY_BUFFER | GL_ACTIVE_ATTRIBUTE_MAX_LENGTH | GL_COMPRESSED_SLUMINANCE | GL_ALPHA_INTEGER | GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH | GL_ALREADY_SIGNALED | GL_ANY_SAMPLES_PASSED | GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH | GL_ACTIVE_PROGRAM | GL_ACTIVE_ATOMIC_COUNTER_BUFFERS | GL_ACTIVE_RESOURCES | GL_BUFFER_IMMUTABLE_STORAGE;\n        int KEEP_OWN_IMPORTS = UNIFORM_PROJECTION_MATRIX.getLocation() | VS_POSITION.getLocation();\n    }\n//&lt;/editor-fold&gt;\n    private FloatBuffer data;\n    private Program program;\n\n    private final float width, height, depth;\n\n    public Box(final float width, final float height, final float depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        data = generateBox();\n        data.clear();\n    }\n\n    @Override\n    public void compileProgram() {\n        program = new Program(\n                new VertexShader(\"data/shaders/box.vs.glsl\").compile(),\n                new FragmentShader(\"data/shaders/box.fs.glsl\").compile()\n        ).compile().usingUniforms(\n                        UNIFORM_MODEL_MATRIX,\n                        UNIFORM_VIEW_MATRIX,\n                        UNIFORM_PROJECTION_MATRIX,\n                        UNIFORM_SHADOW_MATRIX\n                        );\n    }\n\n    @Override\n    public int getInstancesCount() {\n        return 100;\n    }\n\n    @Override\n    public Program getProgram() {\n        return program;\n    }\n\n    @Override\n    public int getDataSize() {\n        return 6 * 6;\n    }\n\n    @Override\n    public FloatBuffer putData(final FloatBuffer dataBuffer) {\n        FloatBuffer returnData = dataBuffer.put(data);\n        data.clear();   //clear to reset data state\n        return returnData;\n    }\n\n    @Override\n    public int getDataMode() {\n        return GL_TRIANGLES;\n    }\n\n    @Override\n    public boolean isShadowReceiver() {\n        return true;\n    }\n\n    @Override\n    public boolean isShadowCaster() {\n        return true;\n    }\n\n    private FloatBuffer generateBox() {\n        FloatBuffer boxData = BufferUtils.createFloatBuffer(6 * 6 * 3);\n\n        //put data into boxData\n\n        return (FloatBuffer)boxData.clear();\n    }\n}\n</code></pre>\n\n<p>First the steps on how I came to this code:</p>\n\n<ol>\n<li><p>I started with the <code>Drawable</code> interface and each implementation having its own <code>drawDepthPass</code>, <code>draw</code> and <code>delete</code> methods.</p></li>\n<li><p>Refactoring <code>delete</code> to a <code>default</code> method was easy, trivial and should not be wrong.</p></li>\n<li><p>However to be able to refactor <code>drawDepthPass</code> and <code>draw</code> I needed access to whether a <code>Drawable</code> was tesselated and/or instanced, so I added the public (<strong>non-default</strong>) methods <code>isTessellated()</code>, <code>isInstanced()</code> and <code>getInstancesCount()</code>.</p></li>\n<li><p>Then I figured out it would be slightly cumbersome, as we programmers are lazy, to implement them in every <code>Drawable</code>.</p></li>\n<li><p>As a consequence I added the <code>default</code> methods to <code>Drawable</code>, giving the behaviour of the most basic <code>Drawable</code>.</p></li>\n<li><p>Then I figured that I am still lazy and do not want to manually implement it for the tessellated and instanced variants eithere.</p></li>\n<li><p>So I created <code>TessellatedDrawable</code> and <code>InstancedDrawable</code> that provide <code>default</code> <code>isTessellated()</code> and <code>isInstanced()</code> respectively. And in <code>InstancedDrawable</code> I revoked the <code>default</code> implementation of <code>getInstancesCount()</code>.</p></li>\n</ol>\n\n<p>As a result I can have the following:</p>\n\n<ul>\n<li>Normal <code>Drawable</code>: <code>public class A implements Drawable</code></li>\n<li>Tessellated <code>Drawable</code>: <code>public class A implements TessellatedDrawable</code></li>\n<li>Instanced <code>Drawable</code>: <code>public class A implements InstancedDrawable</code></li>\n<li>Tessellated and instanced <code>Drawable</code>: <code>public class A implements InstancedDrawable, TessellatedDrawable</code>.</li>\n</ul>\n\n<p>Just to ensure you, this all compiles and runs fine, the <code>implements InstancedDrawable, TessellatedDrawable</code> gets handled perfectly by Java 8 as there is nowhere ever ambiguity on from which interface the functionality should come.</p>\n\n<p>Now onto my own little OOP design assessment:</p>\n\n<ul>\n<li>Every <code>Drawable</code> is in fact a <code>Drawable</code>, so <code>Collection&lt;Drawable&gt;</code> will not break.</li>\n<li>It is possible to group all <code>TessellatedDrawable</code> and/or <code>InstancedDrawable</code>, irrelevant of how exactly it is implement.</li>\n</ul>\n\n<p>Other thoughts I had:</p>\n\n<ul>\n<li><p>Use a more conventional, layered approach, however I disregarded that as it would end up in:</p></li>\n<li><p><code>abstract class AbstractDrawable</code></p></li>\n<li><code>class Drawable extends AbstractDrawable</code></li>\n<li><code>class TessellatedDrawable extends AbstractDrawable</code></li>\n<li><code>class InstancedDrawable extends AbstractDrawable</code></li>\n<li><code>class InstancedTessellatedDrawable extends AbstractDrawable</code></li>\n</ul>\n\n<p>I have also considered a Builder Pattern, however that is a pattern to be used when you are creating a lot of unique instances of a certain object, and that is not what we are doing here, neither is this about the constructor of the object.</p>\n\n<p>So the first and final question was: Am I <em>using</em> a feature of Java 8 or <em>misusing</em> it?</p>\n    ","a":"\n<p>First, if it works, and it does what you want to do, and there's no danger of something breaking in the future, it doesn't make sense to say you're misusing it. After all, it got the job done, right? Features like default methods and static methods were added to interfaces with particular goals in mind, but if they help you achieve other goals, either that's creative use of a new feature or a gross and dirty hack. :-) To a certain extent it's a matter of taste.</p>\n\n<p>With that perspective in mind, what I look for in APIs, and what I try to do when designing APIs, is to distinguish <em>clients</em> of an API from <em>implementors</em> of an API. A typical client, or user, of an API gets a reference of some interface type from somewhere and calls methods on it to make stuff happen. An implementor provides implementations for methods defined in interfaces, overrides methods, and (if subclassing) calls superclass methods. Often, the methods intended to be called by clients are different from those intended to be called from subclasses.</p>\n\n<p>It seems to me that these concepts are being mixed in the <code>Drawable</code> interface. Certainly, clients of a <code>Drawable</code> will do things like call the <code>draw</code> or <code>drawDepthPass</code> methods on them. Great. But looking at the default implementation of <code>drawDepthPass</code>, it gets some information using <code>isTessellated</code> and <code>isInstanced</code> methods, and then uses these to choose a Program and call methods on it in a particular way. It's fine for these bits of logic to be encapsulated within a method, but in order for it to be done in a <em>default</em> method, the getters have to be forced into the public interface.</p>\n\n<p>I might be wrong about your model, of course, but it seems to me that this kind of logic is more suited for an abstract superclass and subclasser relationship. The abstract superclass implements some logic that handles all Drawables, but it negotiates with the particular Drawable implementations with methods like <code>isTesselated</code> or <code>isInstanced</code>. In an abstract superclass, these would be protected methods that subclasses are required to implement. By putting this logic into default methods of an interface, all of these have to be public, which clutters up the client interface. The other methods that seem similar are <code>getDataMode</code>, <code>isShadowReceiver</code>, and <code>isShadowCaster</code>. Are clients expected to call these, or are they logically internal to the implementation?</p>\n\n<p>What this highlights is that, despite the addition of default methods and static methods, interfaces are still oriented toward clients, and less toward supporting subclasses. The reasons are as follows:</p>\n\n<ul>\n<li>Interfaces have only public members.</li>\n<li>Abstract classes can have protected methods for subclasses to override or call.</li>\n<li>Abstract classes can have private methods to enable implementation sharing.</li>\n<li>Abstract classes can have fields (state) which can be protected to share state with subclasses, or usually private otherwise.</li>\n<li>Abstract classes can have final methods that enforce certain behavior policies on subclasses.</li>\n</ul>\n\n<p>Another issue I note with the <code>Drawable</code> interface family is that it uses the ability of default methods to override each other to allow some simple mixins to the implementation classes like <code>Box</code>. It is kind of neat that you can just say <code>implements TessellatedDrawable</code> and avoid the pesky overriding of the <code>isTesselated</code> method! The problem is that this now becomes part of the implementation class's type. Is it useful for the client to know that a <code>Box</code> is also a <code>TessellatedDrawable</code>? Or is this just a scheme for making the internal implementation cleaner? If it's the latter, it might be preferable these mixin interfaces like <code>TessellatedDrawable</code> and <code>InstancedDrawable</code> not be public interfaces (i.e., package private).</p>\n\n<p>Note also that this approach clutters up the type hierarchy, which can make code more confusing to navigate. Usually a new type is a new concept, but it seems heavyweight to have interfaces that merely define default methods returning boolean constants.</p>\n\n<p>A further point in this vein. Again, I don't know your model, but the characteristics being mixed in here are very simple: they're just boolean constants. If there's ever a <code>Drawable</code> implementation that, say, starts off not being instanced and later can become instanced, it can't use these mixin interfaces. The default implementations are really quite restricted in what they can do. They can't call private methods or inspect fields of an implementation class, so their use is quite limited. Using interfaces this way is almost like using them as marker interfaces, with a tiny addition of being able to call a method to get the characteristic, instead of using <code>instanceof</code>. There doesn't seem to be much use beyond this.</p>\n\n<p>The static methods in the <code>Drawable</code> interface seem mostly reasonable. They're utilities that seem client-oriented, and they provide reasonable aggregations of logic provided by the public instance methods.</p>\n\n<p>Finally, there are a few points about the model that seem odd, though they're not directly related to the use of default and static methods.</p>\n\n<p>It seems like a <code>Drawable</code> has-a <code>Program</code>, as there are instance methods <code>compileProgram</code>, <code>getProgram</code>, and <code>delete</code>. Yet the <code>drawDepthPass</code> and similar methods require the client to pass in two programs, one of which is selected depending on the result of the boolean getters. It's not clear to me where the caller is supposed to choose the right Programs.</p>\n\n<p>Something similar is going on with the <code>drawAll</code> methods and the <code>offset</code> value. It seems like in a list of Drawables, they have to be drawn using particular offsets based on each Drawable's data size. Yet what is apparently the most fundamental method, <code>draw</code>, requires the caller to pass in an offset. This seems like a big responsibility to push onto the caller. So perhaps the offset stuff really belongs within the implementation as well.</p>\n\n<p>There are a couple methods that take a List of drawables and call <code>stream()</code> and then <code>forEach()</code> or <code>forEachOrdered()</code>. This isn't necessary, as <code>List</code> has a <code>forEach</code> method on it, inherited from <code>Iterable</code>.</p>\n\n<p>I think it's great to explore how this new stuff can be used. It's new enough that a commonly accepted style hasn't yet emerged. Experiments like this, and this discussion, help to develop that style. On the other hand, we also need to be careful not to use these shiny new features just because they're new and shiny.</p>\n    "},{"t":"JVM 8 exit code -559038737 (0xDEADBEEF)","l":"http://stackoverflow.com/questions/23370449/jvm-8-exit-code-559038737-0xdeadbeef","q":"\n\n<p>My application has started to non-deterministically fail after upgrading to Java 8. It doesn't throw an exception or print an error message. The only sign of its failure is the exit code -559038737. Has anyone encountered this?</p>\n    ","a":"\n<p>That exit code probably comes from <a href=\"http://svn.apache.org/repos/asf/commons/proper/exec/trunk/src/main/java/org/apache/commons/exec/Executor.java\" rel=\"nofollow\">Apache Commons Exec</a>:</p>\n\n<pre><code>public interface Executor {\n\n/** Invalid exit code. */\nint INVALID_EXITVALUE = 0xdeadbeef;\n...\n</code></pre>\n\n<p>There are some <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#waitFor-long-java.util.concurrent.TimeUnit-\" rel=\"nofollow\">changes</a> in Java 8 that might have introduced a bug.</p>\n\n<p>But without knowing your classpath and code, this is just an educated guess.</p>\n\n<p>Maybe you are using the asynchronous way to use Commons Exec:</p>\n\n<pre><code>DefaultExecuteResultHandler resultHandler = new DefaultExecuteResultHandler();\n\nExecutor executor = new DefaultExecutor();\nexecutor.execute(cmdLine, resultHandler);\n\nint exitValue = resultHandler.waitFor();\n\nreturn exitValue;\n</code></pre>\n\n<p>So the exception is only captured in the resultHandler, but not print on stderr automatically?</p>\n    "},{"t":"Lambdas, multiple forEach with casting","l":"http://stackoverflow.com/questions/25439277/lambdas-multiple-foreach-with-casting","q":"\n\n<p>Need some help thinking in lambdas from my fellow StackOverflow luminaries.</p>\n\n<p>Standard case of picking through a list of a list of a list to collect some children deep in a graph.  What awesome ways could <code>Lambdas</code> help with this boilerplate?</p>\n\n<pre><code>public List&lt;ContextInfo&gt; list() {\n    final List&lt;ContextInfo&gt; list = new ArrayList&lt;ContextInfo&gt;();\n    final StandardServer server = getServer();\n\n    for (final Service service : server.findServices()) {\n        if (service.getContainer() instanceof Engine) {\n            final Engine engine = (Engine) service.getContainer();\n            for (final Container possibleHost : engine.findChildren()) {\n                if (possibleHost instanceof Host) {\n                    final Host host = (Host) possibleHost;\n                    for (final Container possibleContext : host.findChildren()) {\n                        if (possibleContext instanceof Context) {\n                            final Context context = (Context) possibleContext;\n                            // copy to another object -- not the important part\n                            final ContextInfo info = new ContextInfo(context.getPath());\n                            info.setThisPart(context.getThisPart());\n                            info.setNotImportant(context.getNotImportant());\n                            list.add(info);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return list;\n}\n</code></pre>\n\n<p>Note the list itself is going to the client as <code>JSON</code>, so don't focus on what is returned.  Must be a few neat ways I can cut down the loops.</p>\n\n<p>Interested to see what my fellow experts create.  Multiple approaches encouraged.</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>The <code>findServices</code> and the two <code>findChildren</code> methods return arrays</p>\n\n<p><strong>EDIT - BONUS CHALLENGE</strong></p>\n\n<p>The \"not important part\" did turn out to be important.  I actually need to copy a value only available in the <code>host</code> instance.  This seems to ruin all the beautiful examples.  How would one carry state forward?</p>\n\n<pre><code>final ContextInfo info = new ContextInfo(context.getPath());\ninfo.setHostname(host.getName()); // The Bonus Challenge\n</code></pre>\n    ","a":"\n<p>It's fairly deeply nested but it doesn't seem exceptionally difficult.</p>\n\n<p>The first observation is that if a for-loop translates into a stream, nested for-loops can be \"flattened\" into a single stream using <code>flatMap</code>. This operation takes a single element and returns an arbitrary number elements in a stream. I looked up and found that <code>StandardServer.findServices()</code> returns an array of <code>Service</code> so we turn this into a stream using <code>Arrays.stream()</code>. (I make similar assumptions for <code>Engine.findChildren()</code> and <code>Host.findChildren()</code>.</p>\n\n<p>Next, the logic within each loop does an <code>instanceof</code> check and a cast. This can be modeled using streams as a <code>filter</code> operation to do the <code>instanceof</code> followed by a <code>map</code> operation that simply casts and returns the same reference. This is actually a no-op but it lets the static typing system convert a <code>Stream&lt;Container&gt;</code> to a <code>Stream&lt;Host&gt;</code> for example.</p>\n\n<p>Applying these transformations to the nested loops, we get the following:</p>\n\n<pre><code>public List&lt;ContextInfo&gt; list() {\n    final List&lt;ContextInfo&gt; list = new ArrayList&lt;ContextInfo&gt;();\n    final StandardServer server = getServer();\n\n    Arrays.stream(server.findServices())\n        .filter(service -&gt; service.getContainer() instanceof Engine)\n        .map(service -&gt; (Engine)service.getContainer())\n        .flatMap(engine -&gt; Arrays.stream(engine.findChildren()))\n        .filter(possibleHost -&gt; possibleHost instanceof Host)\n        .map(possibleHost -&gt; (Host)possibleHost)\n        .flatMap(host -&gt; Arrays.stream(host.findChildren()))\n        .filter(possibleContext -&gt; possibleContext instanceof Context)\n        .map(possibleContext -&gt; (Context)possibleContext)\n        .forEach(context -&gt; {\n            // copy to another object -- not the important part\n            final ContextInfo info = new ContextInfo(context.getPath());\n            info.setThisPart(context.getThisPart());\n            info.setNotImportant(context.getNotImportant());\n            list.add(info);\n        });\n    return list;\n}\n</code></pre>\n\n<p>But wait, there's more.</p>\n\n<p>The final <code>forEach</code> operation is a slightly more complicated <code>map</code> operation that converts a <code>Context</code> into a <code>ContextInfo</code>. Furthermore, these are just collected into a <code>List</code> so we can use collectors to do this instead of creating and empty list up front and then populating it. Applying these refactorings results in the following:</p>\n\n<pre><code>public List&lt;ContextInfo&gt; list() {\n    final StandardServer server = getServer();\n\n    return Arrays.stream(server.findServices())\n        .filter(service -&gt; service.getContainer() instanceof Engine)\n        .map(service -&gt; (Engine)service.getContainer())\n        .flatMap(engine -&gt; Arrays.stream(engine.findChildren()))\n        .filter(possibleHost -&gt; possibleHost instanceof Host)\n        .map(possibleHost -&gt; (Host)possibleHost)\n        .flatMap(host -&gt; Arrays.stream(host.findChildren()))\n        .filter(possibleContext -&gt; possibleContext instanceof Context)\n        .map(possibleContext -&gt; (Context)possibleContext)\n        .map(context -&gt; {\n            // copy to another object -- not the important part\n            final ContextInfo info = new ContextInfo(context.getPath());\n            info.setThisPart(context.getThisPart());\n            info.setNotImportant(context.getNotImportant());\n            return info;\n        })\n        .collect(Collectors.toList());\n}\n</code></pre>\n\n<p>I usually try to avoid multi-line lambdas (such as in the final <code>map</code> operation) so I'd refactor it into a little helper method that takes a <code>Context</code> and returns a <code>ContextInfo</code>. This doesn't shorten the code at all, but I think it does make it clearer.</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>But wait, there's still more.</p>\n\n<p>Let's extract the call to <code>service.getContainer()</code> into its own pipeline element:</p>\n\n<pre><code>    return Arrays.stream(server.findServices())\n        .map(service -&gt; service.getContainer())\n        .filter(container -&gt; container instanceof Engine)\n        .map(container -&gt; (Engine)container)\n        .flatMap(engine -&gt; Arrays.stream(engine.findChildren()))\n        // ...\n</code></pre>\n\n<p>This exposes the repetition of filtering on <code>instanceof</code> followed by a mapping with a cast. This is done three times in total. It seems likely that other code is going to need to do similar things, so it would be nice to extract this bit of logic into a helper method. The problem is that <code>filter</code> can change the number of elements in the stream (dropping ones that don't match) but it can't change their types. And <code>map</code> can change the types of elements, but it can't change their number. Can something change both the number and types? Yes, it's our old friend <code>flatMap</code> again! So our helper method needs to take an element and return a stream of elements of a different type. That return stream will contain a single casted element (if it matches) or it will be empty (if it doesn't match). The helper function would look like this:</p>\n\n<pre><code>&lt;T,U&gt; Stream&lt;U&gt; toType(T t, Class&lt;U&gt; clazz) {\n    if (clazz.isInstance(t)) {\n        return Stream.of(clazz.cast(t));\n    } else {\n        return Stream.empty();\n    }\n}\n</code></pre>\n\n<p>(This is loosely based on C#'s <code>OfType</code> construct mentioned in some of the comments.)</p>\n\n<p>While we're at it, let's extract a method to create a <code>ContextInfo</code>:</p>\n\n<pre><code>ContextInfo makeContextInfo(Context context) {\n    // copy to another object -- not the important part\n    final ContextInfo info = new ContextInfo(context.getPath());\n    info.setThisPart(context.getThisPart());\n    info.setNotImportant(context.getNotImportant());\n    return info;\n}\n</code></pre>\n\n<p>After these extractions, the pipeline looks like this:</p>\n\n<pre><code>    return Arrays.stream(server.findServices())\n        .map(service -&gt; service.getContainer())\n        .flatMap(container -&gt; toType(container, Engine.class))\n        .flatMap(engine -&gt; Arrays.stream(engine.findChildren()))\n        .flatMap(possibleHost -&gt; toType(possibleHost, Host.class))\n        .flatMap(host -&gt; Arrays.stream(host.findChildren()))\n        .flatMap(possibleContext -&gt; toType(possibleContext, Context.class))\n        .map(this::makeContextInfo)\n        .collect(Collectors.toList());\n</code></pre>\n\n<p>Nicer, I think, and we've removed the dreaded multi-line statement lambda.</p>\n\n<p><strong>UPDATE: BONUS CHALLENGE</strong></p>\n\n<p>Once again, <code>flatMap</code> is your friend. Take the tail of the stream and migrate it into the last <code>flatMap</code> before the tail. That way the <code>host</code> variable is still in scope, and you can pass it to a <code>makeContextInfo</code> helper method that's been modified to take <code>host</code> as well.</p>\n\n<pre><code>    return Arrays.stream(server.findServices())\n        .map(service -&gt; service.getContainer())\n        .flatMap(container -&gt; toType(container, Engine.class))\n        .flatMap(engine -&gt; Arrays.stream(engine.findChildren()))\n        .flatMap(possibleHost -&gt; toType(possibleHost, Host.class))\n        .flatMap(host -&gt; Arrays.stream(host.findChildren())\n                               .flatMap(possibleContext -&gt; toType(possibleContext, Context.class))\n                               .map(ctx -&gt; makeContextInfo(ctx, host)))\n        .collect(Collectors.toList());\n</code></pre>\n    "},{"t":"Which would be better in terms of performance Lambda or simple loop? [duplicate]","l":"http://stackoverflow.com/questions/31675319/which-would-be-better-in-terms-of-performance-lambda-or-simple-loop","q":"\n\n<div class=\"question-status question-originals-of-duplicate\">\n    <p>This question already has an answer here:</p>\n    <ul>\n        <li>\n            <a href=\"/questions/16635398/java-8-iterable-foreach-vs-foreach-loop\" dir=\"ltr\">Java 8 Iterable.forEach() vs foreach loop</a>\n                <span class=\"question-originals-answer-count\">\n                    7 answers\n                </span>\n        </li>\n    </ul>\n</div>\n<p>I have quickly read over the <a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\">Oracle Lambda Expression</a> documentation.</p>\n\n<p>This kind of example has helped me to understand better, though:</p>\n\n<pre><code>//Old way:\nList&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\nfor(Integer n: list) {\nSystem.out.println(n);\n}\n\n//New way:\nList&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\nlist.forEach(n -&gt; System.out.println(n));\n\n\n//or we can use :: double colon operator in Java 8\nlist.forEach(System.out::println);\n</code></pre>\n\n<p>Still, I don't understand why it's such an innovation. It's just a method that dies when the \"method variable\" ends, right? Why should I use this instead of a real method?\nWhich would be better option in terms of performance. Lambda or simple loop.</p>\n    ","a":"\n<p>My advice would be:</p>\n\n<ol>\n<li><p>to use the style that you and your coworkers agree is most maintainable,</p></li>\n<li><p>if you / your colleagues are not yet <em>comfortable</em> with lambdas, keep learning </p></li>\n<li><p>don't obsess over performance.</p></li>\n</ol>\n\n<p>Generally speaking, lambdas and streams provide a more concise and (once everyone is up to speed) more readable way of expressing this kind of algorithm.  Performance is not the primary goal.</p>\n\n<p>If performance does become an issue, then the standard advice is to code, test, profile, optimize.  You can easily waste time by optimizing at the coding stage.  Let the profiler point out what parts of your code are worthy of the effort of optimization.</p>\n\n<hr>\n\n<p>In this specific example, the performance difference is going to be too small to measure.  And if you scaled up to a list of millions of elements, the performance will be dominated by the time taken to build the list and write the numbers.  The different ways of iteration will only contribute a small part to the overall performance.</p>\n\n<hr>\n\n<p>And for folks, who (despite all of the above) <em>still</em> want to know whether it is faster to use a lambda or a conventional loop, the best general answer is:</p>\n\n<blockquote>\n  <p>\"It depends on all sorts of factors that 1) are not well understood, and 2) liable to change as Java compiler technology evolves.</p>\n</blockquote>\n\n<p>We could give you an answer for a specific example with a specific Java major/minor/patch release, but it would be unwise to generalize.</p>\n    "},{"t":"Does Java SE 8 have Pairs or Tuples?","l":"http://stackoverflow.com/questions/24328679/does-java-se-8-have-pairs-or-tuples","q":"\n\n<p>I am playing around with lazy functional operations in Java SE 8, and I want to <code>map</code> an index <code>i</code> to a pair / tuple <code>(i, value[i])</code>, then <code>filter</code> based on the second <code>value[i]</code> element, and finally output just the indices.</p>\n\n<p>Must I still suffer this: <a href=\"http://stackoverflow.com/questions/156275/what-is-the-equivalent-of-the-c-pairl-r-in-java\">What is the equivalent of the C++ Pair&lt;L,R&gt; in Java?</a> in the bold new era of lambdas and streams?</p>\n\n<p><strong>Update:</strong> I presented a rather simplified example, which has a neat solution offered by @dkatzel in one of the answers below. However, it does <em>not</em> generalze. Therefore, let me add a more general example:</p>\n\n<pre><code>package com.example.test;\n\nimport java.util.ArrayList;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    boolean [][] directed_acyclic_graph = new boolean[][]{\n        {false,  true, false,  true, false,  true},\n        {false, false, false,  true, false,  true},\n        {false, false, false,  true, false,  true},\n        {false, false, false, false, false,  true},\n        {false, false, false, false, false,  true},\n        {false, false, false, false, false, false}\n    };\n\n    System.out.println(\n        IntStream.range(0, directed_acyclic_graph.length)\n        .parallel()\n        .mapToLong(i -&gt; IntStream.range(0, directed_acyclic_graph[i].length)\n            .filter(j -&gt; directed_acyclic_graph[j][i])\n            .count()\n        )\n        .filter(n -&gt; n == 0)\n        .collect(() -&gt; new ArrayList&lt;Long&gt;(), (c, e) -&gt; c.add(e), (c1, c2) -&gt; c1.addAll(c2))\n    );\n  }\n\n}\n</code></pre>\n\n<p>This gives <strong>incorrect</strong> output of <code>[0, 0, 0]</code> which corresponds to the <em>counts</em> for the three columns that are all <code>false</code>. What I need are the <em>indices</em> of these three columns. The correct output should be <code>[0, 2, 4]</code>. How can I get this result?</p>\n    ","a":"\n<p><strong>UPDATE:</strong> This answer is in response to the original question, <em>Does Java SE 8 have Pairs or Tuples?</em> (And implicitly, if not, why not?) The OP has updated the question with a more complete example, but it seems like it can be solved without using any kind of Pair structure. [Note from OP: here is the other <a href=\"http://stackoverflow.com/questions/24328679/does-java-se-8-have-pairs-or-tuples/24339157#24339157\">the other correct answer</a>.]</p>\n\n<hr>\n\n<p>The short answer is no. You either have to roll your own or bring in one of the several libraries that implements it.</p>\n\n<p>Having a <code>Pair</code> class in Java SE was proposed and rejected at least once. See <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2010-March/003973.html\">this discussion thread</a> on one of the OpenJDK mailing lists. The tradeoffs are not obvious. On the one hand, there are many Pair implementations in other libraries and in application code. That demonstrates a need, and adding such a class to Java SE will increase reuse and sharing. On the other hand, having a Pair class adds to the temptation of creating complicated data structures out of Pairs and collections without creating the necessary types and abstractions. (That's a paraphrase of <a href=\"http://mail.openjdk.java.net/pipermail/core-libs-dev/2010-March/003995.html\">Kevin Bourillion's message</a> from that thread.)</p>\n\n<p>I recommend everybody read that entire email thread. It's remarkably insightful and has no flamage. It's quite convincing. When it started I thought, \"Yeah, there should be a Pair class in Java SE\" but by the time the thread reached its end I had changed my mind.</p>\n\n<p>Note however that JavaFX has the <a href=\"http://docs.oracle.com/javafx/2/api/javafx/util/Pair.html\">javafx.util.Pair</a> class. JavaFX's APIs evolved separately from the Java SE APIs.</p>\n\n<p>As one can see from the linked question <a href=\"http://stackoverflow.com/questions/156275/what-is-the-equivalent-of-the-c-pairl-r-in-java\">What is the equivalent of the C++ Pair in Java?</a> there is quite a large design space surrounding what is apparently such a simple API. Should the objects be immutable? Should they be serializable? Should they be comparable? Should the class be final or not? Should the two elements be ordered? Should it be an interface or a class? Why stop at pairs? Why not triples, quads, or N-tuples?</p>\n\n<p>And of course there is the inevitable naming bikeshed for the elements:</p>\n\n<ul>\n<li>(a, b)</li>\n<li>(first, second)</li>\n<li>(left, right)</li>\n<li>(car, cdr)</li>\n<li>(foo, bar)</li>\n<li>etc.</li>\n</ul>\n\n<p>One big issue that has hardly been mentioned is the relationship of Pairs to primitives. If you have an <code>(int x, int y)</code> datum that represents a point in 2D space, representing this as <code>Pair&lt;Integer, Integer&gt;</code> consumes <strong>three objects</strong> instead of two 32-bit words. Furthermore, these objects must reside on the heap and will incur GC overhead.</p>\n\n<p>It would seem clear that, like Streams, it would be essential for there to be primitive specializations for Pairs. Do we want to see:</p>\n\n<pre><code>Pair\nObjIntPair\nObjLongPair\nObjDoublePair\nIntObjPair\nIntIntPair\nIntLongPair\nIntDoublePair\nLongObjPair\nLongIntPair\nLongLongPair\nLongDoublePair\nDoubleObjPair\nDoubleIntPair\nDoubleLongPair\nDoubleDoublePair\n</code></pre>\n\n<p>Even an <code>IntIntPair</code> would still require one object on the heap.</p>\n\n<p>These are, of course, reminiscent of the proliferation of functional interfaces in the <code>java.util.function</code> package in Java SE 8. If you don't want a bloated API, which ones would you leave out? You could also argue that this isn't enough, and that specializations for, say, <code>Boolean</code> should be added as well.</p>\n\n<p>My feeling is that if Java had added a Pair class long ago, it would have been simple, or even simplistic, and it wouldn't have satisfied many of the use cases we are envisioning now. Consider that if Pair had been added in the JDK 1.0 time frame, it probably would have been mutable! (Look at java.util.Date.) Would people have been happy with that? My guess is that if there were a Pair class in Java, it would be kinda-sort-not-really-useful and everybody will still be rolling their own to satisfy their needs, there would be various Pair and Tuple implementations in external libraries, and people would still be arguing/discussing about how to fix Java's Pair class. In other words, kind of in the same place we're at today.</p>\n\n<p>Meanwhile, some work is going on to address the fundamental issue, which is better support in the JVM (and eventually the Java language) for <em>value types</em>. See this <a href=\"http://cr.openjdk.java.net/~jrose/values/values-0.html\">State of the Values</a> document. This is preliminary, speculative work, and it covers only issues from the JVM perspective, but it already has a fair amount of thought behind it. Of course there are no guarantees that this will get into Java 9, or ever get in anywhere, but it does show the current direction of thinking on this topic.</p>\n    "},{"t":"Java 8 stream API: Exceptions when modifying Lists","l":"http://stackoverflow.com/questions/30590378/java-8-stream-api-exceptions-when-modifying-lists","q":"\n\n<p>Let's take an <code>ArrayList</code> and fill it with with something simple:</p>\n\n<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; 10; i++) {\n    list.add(\"\"+i);\n}\n</code></pre>\n\n<p>I will try to remove one member, say named 5, with a different ways of stream API. For this I define the method, that will give me a <code>ConcurentModificationException</code> when using traditional iteration with iterator.</p>\n\n<pre><code>void removeMember(String clientListener) {\n    list.remove(clientListener);\n}\n</code></pre>\n\n<p>This code gives me that exception, which I understand:</p>\n\n<pre><code>list.parallelStream()\n    .filter(string -&gt; string.equalsIgnoreCase(\"5\"))\n    .forEach(string -&gt; removeMember(string));\n</code></pre>\n\n<p>However, trying just <code>stream()</code>, not <code>parallelStream()</code> gives an null pointer exception (NPE), which is strange for me:</p>\n\n<pre><code>list.stream()\n    .filter(string -&gt; string.equalsIgnoreCase(\"5\"))\n    .forEach(string -&gt; removeMember(string));\n</code></pre>\n\n<p>Now change the <code>List</code> type to <code>LinkedList&lt;&gt;</code>. Last code with <code>stream()</code> gives me a <code>ConcurentModificationException</code>, and <code>parallelStream()</code> suddenly works!</p>\n\n<p>So, the questions.</p>\n\n<ol>\n<li><p>Is the internal <code>parallelStream()</code> kitchen (Spliterators and other magic) smart enough to use such element removal for <code>LinkedList</code>? Will it always work?</p></li>\n<li><p>Why was that NPE for <code>ArrayList</code>? Why NPE, not <code>ConcurentModificationException</code> I mean.</p></li>\n</ol>\n    ","a":"\n<p>The behaviour of your code is essentially undefined (hence the various answers you get). The <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html\">stream documentation</a> (Non-Intereference section) states:</p>\n\n<blockquote>\n  <p>Unless the stream source is concurrent, modifying a stream's data source during execution of a stream pipeline can cause exceptions, incorrect answers, or nonconformant behavior.</p>\n</blockquote>\n\n<p>And <code>ArrayList</code> and <code>LinkedList</code> are not concurrent.</p>\n\n<p>You could use a concurrent source but it would make more sense to move away from modifying the source of the stream, for example by using <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#removeIf-java.util.function.Predicate-\"><code>Collection#removeIf</code></a>:</p>\n\n<pre><code>list.removeIf(string -&gt; string.equalsIgnoreCase(\"5\"));\n</code></pre>\n    "},{"t":"How to have Eclipse use JDK8 to compile a project?","l":"http://stackoverflow.com/questions/8122843/how-to-have-eclipse-use-jdk8-to-compile-a-project","q":"\n\n<p>I'm experimenting with the new jdk8 what is available here <a href=\"http://jdk8.java.net/lambda/\">http://jdk8.java.net/lambda/</a></p>\n\n<p>I'm able to compile and run my project from command line.</p>\n\n<p>I'm also able to add this new JDK to <code>Installed JREs</code> in Eclipse.\nHowever, I'm not able to have Eclipse to compile and run the project with this JDK.</p>\n\n<p>I'm trying to change the settings on <code>Project Properties/Java Compiler</code> but the <code>Use [JDK] compliance from execution environment on the 'Java Build Path'</code> checkbox is disabled and no matter whatever I click on this page, I cannot make it work.</p>\n\n<p>I have Eclipse Platform Version: 3.7.1</p>\n\n<p>Any ideas?</p>\n\n<p>thx</p>\n    ","a":"\n<p>Eclipse uses a built-in compiler rather than <code>javac</code>. The built-in compiler obviously doesn't support Java 8 yet.</p>\n\n<p>You can define a custom builder for your project which will call your <code>javac</code>. In the project's preferences, go to \"Builders\", add a new custom builder (which can be either an Ant script or an executable program) and disable the default built-in Java builder.</p>\n\n<p>Afterwards, <em>running</em> the project with the JDK of your choice shouldn't be a problem - adding it to the \"Installed JREs\" preference page (as you did) should be sufficient.</p>\n    "},{"t":"Java 8 Method references called on a local variable","l":"http://stackoverflow.com/questions/27747781/java-8-method-references-called-on-a-local-variable","q":"\n\n<p>I am in the process of learning Java 8 and I came across something that I find a bit strange.</p>\n\n<p>Consider the following snippet:</p>\n\n<pre><code>private MyDaoClass myDao;\n\npublic void storeRelationships(Set&lt;Relationship&lt;ClassA, ClassB&gt;&gt; relationships) \n{\n    RelationshipTransformer transformer = new RelationshipTransformerImpl();\n\n    myDao.createRelationships(\n            relationships.stream()\n            .map((input) -&gt; transformer.transformRelationship(input))\n            .collect(Collectors.toSet())\n    );\n}\n</code></pre>\n\n<p>Basically, I need to map the input set called <code>relationships</code> to a different type in order to\nconform to the API of the DAO I'm using. For the conversion, I would like to use an existing <code>RelationshipTransformerImpl</code> class that I instantiate as a local variable.</p>\n\n<p>Now, here's my question:</p>\n\n<p>If I was to modify the above code as follows:</p>\n\n<pre><code>public void storeRelationships(Set&lt;Relationship&lt;ClassA, ClassB&gt;&gt; relationships) \n{\n    RelationshipTransformer transformer = new RelationshipTransformerImpl();\n\n    myDao.createRelationships(\n            relationships.stream()\n            .map((input) -&gt; transformer.transformRelationship(input))\n            .collect(Collectors.toSet())\n    );\n\n    transformer = null;  //setting the value of an effectively final variable\n}\n</code></pre>\n\n<p>I would obviously get a compilation error, since the local variable <code>transformer</code> is no longer \"effectively final\". However, if replace the lambda with a method reference:</p>\n\n<pre><code>public void storeRelationships(Set&lt;Relationship&lt;ClassA, ClassB&gt;&gt; relationships) \n{\n    RelationshipTransformer transformer = new RelationshipTransformerImpl();\n\n    myDao.createRelationships(\n            relationships.stream()\n            .map(transformer::transformRelationship)\n            .collect(Collectors.toSet())\n    );\n\n    transformer = null;  //setting the value of an effectively final variable\n}\n</code></pre>\n\n<p>Then I no longer get a compilation error! Why does this happen? I thought the two ways to write the lambda expression should be equivalent, but there's clearly something more going on.</p>\n    ","a":"\n<p><a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.13.3\">JLS 15.13.5</a> may hold the explanation:</p>\n\n<blockquote>\n  <p>The timing of method reference expression evaluation is more complex than that of lambda expressions (§15.27.4). When a method reference expression has an expression (rather than a type) preceding the :: separator, that subexpression is evaluated immediately. The result of evaluation is stored until the method of the corresponding functional interface type is invoked; at that point, the result is used as the target reference for the invocation. This means the expression preceding the :: separator is evaluated only when the program encounters the method reference expression, and is not re-evaluated on subsequent invocations on the functional interface type. </p>\n</blockquote>\n\n<p>As I understand it, since in your case <code>transformer</code> is the expression preceding the :: separator, it is evaluated just once and stored. Since it doesn't have to be re-evaluated in order to invoke the referenced method, it doesn't matter that <code>transformer</code> is later assigned null.</p>\n    "},{"t":"Generics compilation error with ternary operator in Java 8, but not in Java 7","l":"http://stackoverflow.com/questions/22509488/generics-compilation-error-with-ternary-operator-in-java-8-but-not-in-java-7","q":"\n\n<p>This class compiles ok in Java 7, but not in Java 8:</p>\n\n<pre><code>public class Foo {\n\n    public static void main(String[] args) throws Exception {\n        //compiles fine in Java 7 and Java 8:\n        Class&lt;? extends CharSequence&gt; aClass = true ? String.class : StringBuilder.class;\n        CharSequence foo = foo(aClass);\n\n        //Inlining the variable, compiles in Java 7, but not in Java 8:\n        CharSequence foo2 = foo(true ? String.class : StringBuilder.class);\n\n    }\n\n    static &lt;T&gt; T foo(Class&lt;T&gt; clazz) throws Exception {\n        return clazz.newInstance();\n    }\n}\n</code></pre>\n\n<p>Compilation error:</p>\n\n<blockquote>\n  <p>Error:(9, 29) java: method foo in class Foo cannot be applied to given\n  types;   required: java.lang.Class   found: true ? Str[...]class<br>\n  reason: inferred type does not conform to equality constraint(s)\n      inferred: java.lang.StringBuilder\n      equality constraints(s): java.lang.StringBuilder,java.lang.String</p>\n</blockquote>\n\n<p>Why has this stopped working in Java 8? Is it intentional / a side effect of some other feature, or is it simply a compiler bug?</p>\n    ","a":"\n<p>This is not a javac bug, according to the current spec. I wrote an answer here is SO for a similar <a href=\"http://stackoverflow.com/questions/23381764/compilation-error-with-generics-and-ternary-operator-in-jdk-7/23573766#23573766\">issue</a>. Here the problem is more or less the same. </p>\n\n<p>On an assignment or invocation context reference conditional expressions are poly expressions. This means that the type of the expression is not the result of applying capture conversion to lub(T1, T2), see <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25.3\">JSL-15.25.3</a> for a detailed definition of T1 and T2. Instead we have, also from this portion of the spec that:</p>\n\n<blockquote>\n  <p>Where a poly reference conditional expression appears in a context of a particular\n  kind with target type T, its second and third operand expressions similarly appear\n  in a context of the same kind with target type T.</p>\n  \n  <p>The type of a poly reference conditional expression is the same as its target type.</p>\n</blockquote>\n\n<p>So this means that the target type is pushed down to both operands of the reference conditional expression, and both operands are attributed against that target type. So the compiler ends up gathering constraints from both operands, leading to an unsolvable constraint set and thus an error.</p>\n\n<hr>\n\n<p>OK, but why do we get equality bounds for T here? </p>\n\n<p>Let's see in detail, from the call:</p>\n\n<pre><code>foo(true ? String.class : StringBuilder.class)\n</code></pre>\n\n<p>where foo is:</p>\n\n<pre><code>static &lt;T&gt; T foo(Class&lt;T&gt; clazz) throws Exception {\n    return clazz.newInstance();\n}\n</code></pre>\n\n<p>We have that as we are invoking method <code>foo()</code> with the expression <code>true ? String.class : StringBuilder.class</code>. This reference conditional expression should be compatible in a loose invocation context with type <code>Class&lt;T&gt;</code>. This is represented as, see <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.1.2\">JLS-18.1.2</a>:</p>\n\n<pre><code>true ? String.class : StringBuilder.class → Class&lt;T&gt;\n</code></pre>\n\n<p>As follows from <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.2.1\">JLS-18.2.1</a> we have that:</p>\n\n<blockquote>\n  <p>A constraint formula of the form ‹Expression → T› is reduced as follows:</p>\n  \n  <p>...</p>\n  \n  <ul>\n  <li>If the expression is a conditional expression of the form e1 ? e2 : e3, the\n  constraint reduces to two constraint formulas, ‹e2 → T› and ‹e3 → T›.</li>\n  </ul>\n</blockquote>\n\n<p>This implies that we obtain the following constraint formulas:</p>\n\n<pre><code>String.class → Class&lt;T&gt;\nStringBuilder.class → Class&lt;T&gt;\n</code></pre>\n\n<p>or:</p>\n\n<pre><code>Class&lt;String&gt; → Class&lt;T&gt;\nClass&lt;StringBuilder&gt; → Class&lt;T&gt;\n</code></pre>\n\n<p>Later from <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.2.2\">JLS-18.2.2</a> we have that:</p>\n\n<blockquote>\n  <p>A constraint formula of the form ‹S → T› is reduced as follows:</p>\n  \n  <p>...</p>\n  \n  <ul>\n  <li>Otherwise, the constraint reduces to ‹S &lt;: T›.</li>\n  </ul>\n</blockquote>\n\n<p>I'm only including the related parts. So going on we have now:</p>\n\n<pre><code>Class&lt;String&gt; &lt;: Class&lt;T&gt;\nClass&lt;StringBuilder&gt; &lt;: Class&lt;T&gt;\n</code></pre>\n\n<p>From <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.2.3\">JLS-18.2.3</a>, we have:</p>\n\n<blockquote>\n  <p>A constraint formula of the form ‹S &lt;: T› is reduced as follows:</p>\n  \n  <p>...</p>\n  \n  <ul>\n  <li>Otherwise, the constraint is reduced according to the form of T:\n  <ul>\n  <li>If T is a parameterized class or interface type, or an inner class type of a\n  parameterized class or interface type (directly or indirectly), let A1, ..., An be\n  the type arguments of T. Among the supertypes of S, a corresponding class\n  or interface type is identified, with type arguments B1, ..., Bn. If no such type\n  exists, the constraint reduces to false. Otherwise, the constraint reduces to the\n  following new constraints: for all i (1 ≤ i ≤ n), ‹Bi &lt;= Ai›.</li>\n  </ul></li>\n  </ul>\n</blockquote>\n\n<p>So as <code>Class&lt;T&gt;</code>, <code>Class&lt;String&gt;</code> and <code>Class&lt;StringBuilder&gt;</code> are parameterized classes, this implies that now our constraints reduces to:</p>\n\n<pre><code>String &lt;= T\nStringBuilder &lt;= T\n</code></pre>\n\n<p>Also from <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.2.3\">JLS-18.2.3</a>, we have:</p>\n\n<blockquote>\n  <p>A constraint formula of the form ‹S &lt;= T›, where S and T are type arguments\n  (§4.5.1), is reduced as follows:</p>\n  \n  <p>...</p>\n  \n  <ul>\n  <li>If T is a type:\n  <ul>\n  <li>If S is a type, the constraint reduces to ‹S = T›.</li>\n  </ul></li>\n  </ul>\n</blockquote>\n\n<p>Thus we end up with these constraints for T:</p>\n\n<pre><code>String = T\nStringBuilder = T\n</code></pre>\n\n<p>Finally at <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.2.4\">JLS-18.2.4</a> we have that:</p>\n\n<blockquote>\n  <p>A constraint formula of the form ‹S = T›, where S and T are types, is reduced as\n  follows:</p>\n  \n  <p>...</p>\n  \n  <ul>\n  <li>Otherwise, if T is an inference variable, α, the constraint reduces to the bound\n  S = α.</li>\n  </ul>\n</blockquote>\n\n<p>And there is no solution for type variable T with bounds <code>T = String</code> and <code>T = StringBuilder</code>. There is no type the compiler can substitute T for that satisfies both restrictions. For this reason the compiler displays the error message.</p>\n\n<hr>\n\n<p>So javac is OK according to the current spec, but is the spec correct on this? Well there is a compatibility issue between 7 and 8 that should be investigated. For this reason I have filed <a href=\"https://bugs.openjdk.java.net/browse/JDK-8044053\">JDK-8044053</a> so we can track this issue.</p>\n    "},{"t":"Why does my Eclipse Luna 4.4 crash on Debian Wheezy 7.4 with Oracle JDK8 64bit?","l":"http://stackoverflow.com/questions/24872995/why-does-my-eclipse-luna-4-4-crash-on-debian-wheezy-7-4-with-oracle-jdk8-64bit","q":"\n\n<p>I have Debian GNU/Linux 7.4 (wheezy) OS installed on Oracle VirtualBox and:</p>\n\n<blockquote>\n<pre><code>java version \"1.8.0_11\"\nJava(TM) SE Runtime Environment (build 1.8.0_11-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode)\n</code></pre>\n</blockquote>\n\n<p>I downloaded Eclipse Luna 4.4.  When I was trying to run Eclipse an error occurred:</p>\n\n<blockquote>\n<pre><code>A fatal error has been detected by the Java Runtime Environment:\nSIGSEGV (0xb) at pc=0x00007f9e8a42173f, pid=10942, tid=140319582553856\nJRE version: Java(TM) SE Runtime Environment (8.0_11-b12) (build 1.8.0_11-b12)\nJava VM: Java HotSpot(TM) 64-Bit Server VM (25.11-b03 mixed mode linux-amd64 compressed oops)\nProblematic frame:\nC  [libgdk-x11-2.0.so.0+0x5173f]  gdk_display_open+0x3f\nFailed to write core dump. Core dumps have been disabled. To enable core dumping, try \"ulimit -c unlimited\" before starting Java\n</code></pre>\n</blockquote>\n\n<p>So I issued a command in the terminal:</p>\n\n<pre><code>$ ulimit -c unlimited\n$ ./eclipse\n</code></pre>\n\n<p>But the next error occurred:</p>\n\n<blockquote>\n<pre><code>Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=256m; support\nwas removed in 8.0\n(java:11276): GLib-GObject-WARNING **: cannot register existing type `GdkDisplayManager'\n(java:11276): GLib-CRITICAL **: g_once_init_leave: assertion `result != 0' failed\n(java:11276): GLib-GObject-CRITICAL **: g_object_new: assertion `G_TYPE_IS_OBJECT (object_type)' failed\n(java:11276): GLib-GObject-WARNING **: invalid (NULL) pointer instance\n(java:11276): GLib-GObject-CRITICAL **: g_signal_connect_data: assertion `G_TYPE_CHECK_INSTANCE (instance)' failed\n(java:11276): GLib-GObject-WARNING **: invalid (NULL) pointer instance\n(java:11276): GLib-GObject-CRITICAL **: g_signal_connect_data: assertion `G_TYPE_CHECK_INSTANCE (instance)' failed\n(java:11276): GLib-GObject-WARNING **: cannot register existing type `GdkDisplay'\n(java:11276): GLib-CRITICAL **: g_once_init_leave: assertion `result != 0' failed\n(java:11276): GLib-GObject-CRITICAL **: g_type_register_static: assertion `parent_type &gt; 0' failed\n(java:11276): GLib-CRITICAL **: g_once_init_leave: assertion `result != 0' failed\n(java:11276): GLib-GObject-CRITICAL **: g_object_new: assertion `G_TYPE_IS_OBJECT (object_type)' failed\nA fatal error has been detected by the Java Runtime Environment:\nSIGSEGV (0xb) at pc=0x00007f216d28473f, pid=11276, tid=139782222493440JRE version: Java(TM) SE Runtime Environment\n</code></pre>\n  \n  <p>(8.0_11-b12) (build 1.8.0_11-b12)\n      Java VM: Java HotSpot(TM) 64-Bit Server VM (25.11-b03 mixed mode linux-amd64 compressed oops)\n      Problematic frame:\n      C  [libgdk-x11-2.0.so.0+0x5173f]  gdk_display_open+0x3f\n      Core dump written. Default location: /home/abcdef/ECLIPSE_JAVA/eclipse/core or core.11276</p>\n</blockquote>\n\n<p>I also tried to solve this problem by adding:</p>\n\n<pre><code>-Dorg.eclipse.swt.browser.DefaultType=mozilla\n</code></pre>\n\n<p>to eclipse.ini, but it didn't help.</p>\n\n<p>Can anybody help me with this problem?</p>\n    ","a":"\n<p>According to:\n<a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=430736\">https://bugs.eclipse.org/bugs/show_bug.cgi?id=430736</a></p>\n\n<p>Add to 2 lines eclipse.ini:</p>\n\n<pre><code>--launcher.GTK_version\n2\n</code></pre>\n\n<p>The option --launcher.GTK_version should be <em>before</em> --launcher.appendVmargs</p>\n    "},{"t":"Java 8 lambda Void argument","l":"http://stackoverflow.com/questions/29945627/java-8-lambda-void-argument","q":"\n\n<p>Let's say I have the following functional interface in Java 8:</p>\n\n<pre><code>interface Action&lt;T, U&gt; {\n   U execute(T t);\n}\n</code></pre>\n\n<p>And for some cases I need an action without arguments or return type. So I write\nsomething like this:</p>\n\n<pre><code>Action&lt;Void, Void&gt; a = () -&gt; { System.out.println(\"Do nothing!\"); };\n</code></pre>\n\n<p>However, it gives me compile error, I need to write it as</p>\n\n<pre><code>Action&lt;Void, Void&gt; a = (Void v) -&gt; { System.out.println(\"Do nothing!\"); return null;};\n</code></pre>\n\n<p>Which is ugly. Is there any way to get rid of the <code>Void</code> type?</p>\n    ","a":"\n<p>The syntax you're after is possible with a little helper function that converts a <code>Runnable</code> into <code>Action&lt;Void, Void&gt;</code> (you can place it in <code>Action</code> for example):</p>\n\n<pre><code>public static Action&lt;Void, Void&gt; action(Runnable runnable) {\n    return (v) -&gt; {\n        runnable.run();\n        return null;\n    };\n}\n\n// Somewhere else in your code\n Action&lt;Void, Void&gt; action = action(() -&gt; System.out.println(\"foo\"));\n</code></pre>\n    "},{"t":"Is there a way to have a Java8 duration of one year that accounts for leap years?","l":"http://stackoverflow.com/questions/29899299/is-there-a-way-to-have-a-java8-duration-of-one-year-that-accounts-for-leap-years","q":"\n\n<p>I need the number of days in a year and I wanted to use Java8's new time api. </p>\n\n<p>However, I can't do <code>Duration.ofDays(365)</code> because it doesn't account for leap years.  And <code>Duration.of(1, ChronoUnit.YEARS)</code> doesn't fly because of <code>java.time.temporal.UnsupportedTemporalTypeException: Unit must not have an estimated duration</code></p>\n\n<p>I looked into Period, but it doesn't appear useful for going from years to days.</p>\n\n<p>I feel like I'm missing something here?  I could write something to add a day if the year is a leap year, but it seems like I should be able to handle this out of the box.</p>\n    ","a":"\n<p>As per the response in <a href=\"http://stackoverflow.com/questions/26454129/getting-duration-using-the-new-datetime-api\">Getting Duration using the new dateTime API</a> you should be using</p>\n\n<pre><code>Period p = Period.ofYears(1);\n</code></pre>\n\n<p>It's important to understand the difference between <code>Duration</code> (exact number of nanoseconds) and <code>Period</code> (variable).</p>\n\n<p><code>Duration</code> won't account for daylight savings time or leap seconds, for example, and is intended for durations of less than a day, at most a few days. So it's really better if you're able to use <code>Period</code> instead.</p>\n\n<p>Because different years have different number of days, if you want to find the number of days in a year, you need to specify which year you're talking about.</p>\n\n<p>If you want the number of days in a specific year, you can use </p>\n\n<pre><code>Year.of(year).length()\n</code></pre>\n\n<p>If you want the date one year from now, you can use</p>\n\n<pre><code>LocalDate.now().plusYears(1)\n</code></pre>\n\n<p>or</p>\n\n<pre><code>LocalDate.now().plus(Period.ofYears(1))\n</code></pre>\n\n<p>If you need the number of days between two dates, you can use</p>\n\n<pre><code>ChronoUnit.DAYS.between(start, end)\n</code></pre>\n\n<p>So to find the number of days to the date a year from now, you can use</p>\n\n<pre><code>LocalDate today = LocalDate.now();\nlong days = ChronoUnit.DAYS.between(today, today.plusYears(1));\n</code></pre>\n\n<p>If you want to see whether a membership of one year is still valid, you can use</p>\n\n<pre><code>Period membershipLength = Period.ofYears(1);\nLocalDate membershipStart = ...;\nLocalDate membershipEnd = membershipStart.plus(membershipLength);\nboolean isMember = LocalDate.now().isBefore(membershipEnd);\n</code></pre>\n    "},{"t":"Why can't @FunctionalInterfaces have default methods?","l":"http://stackoverflow.com/questions/30165060/why-cant-functionalinterfaces-have-default-methods","q":"\n\n<p>Why can't I create a <code>@FunctionalInterface</code> with a default method implementation?</p>\n\n<pre><code>@FunctionalInterface\npublic MyInterface {\n    default boolean authorize(String value) {\n        return true;\n    }\n}\n</code></pre>\n    ","a":"\n<p>You can have default methods in a <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html\">functional interface</a> but its contract requires you to provide one single abstract method (or SAM). Since a default method have an implementation, it's not abstract.</p>\n\n<blockquote>\n  <p>Conceptually, a functional interface has exactly one abstract method.\n  Since default methods have an implementation, they are not abstract.</p>\n</blockquote>\n\n<p>and</p>\n\n<blockquote>\n  <p>If a type is annotated with this annotation type, compilers are\n  required to generate an error message unless:</p>\n  \n  <p>The type is an interface type and not an annotation type, enum, or\n  class. </p>\n  \n  <p>The annotated type satisfies the requirements of a functional\n  interface.</p>\n</blockquote>\n\n<p>Here you don't satisfy the functional interface's requirement, so you need to provide one abstract method. For example:</p>\n\n<pre><code>@FunctionalInterface\ninterface MyInterface {\n\n    boolean authorize(int val);\n\n    default boolean authorize(String value) {\n        return true;\n    }\n}\n</code></pre>\n\n<p>Note that if you declare an abstract method overriding one of a public method from the Object's class it doesn't count, because any implementation of this interface will have an implementation of those methods through at least the Object's class. For example:</p>\n\n<pre><code>@FunctionalInterface\ninterface MyInterface {\n\n    default boolean authorize(String value) {\n        return true;\n    }\n\n    boolean equals(Object o);\n}\n</code></pre>\n\n<p>does not compile.</p>\n    "},{"t":"Java 8 Collector that returns a value if there's only a single value","l":"http://stackoverflow.com/questions/26810375/java-8-collector-that-returns-a-value-if-theres-only-a-single-value","q":"\n\n<p>I'm a little green on this functional programming and streams stuff, but what little I do know has been very useful!</p>\n\n<p>I've had this situation come up several times:</p>\n\n<pre><code>List&lt;SomeProperty&gt; distinctProperties = someList.stream()\n    .map(obj -&gt; obj.getSomeProperty())\n    .distinct()\n    .collect(Collectors.toList());\n\nif (distinctProperties.size() == 1) {\n    SomeProperty commonProperty = distinctProperties.get(0);\n    // take some action knowing that all share this common property\n}\n</code></pre>\n\n<p>What I really want is:</p>\n\n<pre><code>Optional&lt;SomeProperty&gt; universalCommonProperty = someList.stream()\n    .map(obj -&gt; obj.getSomeProperty())\n    .distinct()\n    .collect(Collectors.singleOrEmpty());\n</code></pre>\n\n<p>I think the <code>singleOrEmpty</code> thing can be useful in other situations besides just in combination with <code>distinct</code>.  When I was an uber n00b I spent a lot of time reinventing the Java Collections Framework because I didn't know it was there, so I'm trying not to repeat my mistakes.  Does Java come with a good way to do this <code>singleOrEmpty</code> thing?  Am I formulating it wrong?</p>\n\n<p>Thanks!</p>\n\n<p>EDIT: Here's some example data for the <code>distinct</code> case.  If you ignore the <code>map</code> step:</p>\n\n<pre><code>Optional&lt;SomeProperty&gt; universalCommonProperty = someList.stream()\n    .map(obj -&gt; obj.getSomeProperty())\n    .distinct()\n    .collect(Collectors.singleOrEmpty());\n\n[]     -&gt; Optional.empty()\n[1]    -&gt; Optional.of(1)\n[1, 1] -&gt; Optional.of(1)\n[2, 2] -&gt; Optional.of(2)\n[1, 2] -&gt; Optional.empty()\n</code></pre>\n\n<p>I find I need this when I screw up my types, or have legacy code.  It's really nice to be able to quickly say \"All the elements of this collection share this property, so now I can take some action using this shared property.\"  Another example is when a user multi-selects some diverse elements, and you're trying to see what stuff you can do (if anything) that's valid for all of them.</p>\n\n<p>EDIT2: Sorry if my example is a misleading.  The key is <strong>singleOrEmpty</strong>.  I commonly find that I put a <code>distinct</code> in front, but it could just as easily be a <code>filter</code> of some other kind.</p>\n\n<pre><code>Optional&lt;SomeProperty&gt; loneSpecialItem = someList.stream()\n    .filter(obj -&gt; obj.isSpecial())\n    .collect(Collectors.singleOrEmpty());\n\n[special]           -&gt; Optional.of(special)\n[special, special]  -&gt; Optional.empty()\n[not]               -&gt; Optional.empty()\n[not, special]      -&gt; Optional.of(special)\n[not, special, not] -&gt; Optional.of(special)\n</code></pre>\n\n<p>EDIT3: I think I screwed up by motivating the <strong>singleOrEmpty</strong> instead of just asking for it on its own.</p>\n\n<pre><code>Optional&lt;Int&gt; value = someList.stream().collect(Collectors.singleOrEmpty())\n[]     -&gt; Optional.empty()\n[1]    -&gt; Optional.of(1)\n[1, 1] -&gt; Optional.empty()\n</code></pre>\n    ","a":"\n<p>\"Hacky\" solution that only evaluates the first two elements:</p>\n\n<pre><code>    .limit(2)\n    .map(Optional::ofNullable)\n    .reduce(Optional.empty(),\n        (a, b) -&gt; a.isPresent() ^ b.isPresent() ? b : Optional.empty());\n</code></pre>\n\n<p>Some basic explanation:</p>\n\n<p><strong>Single element</strong> [1] -&gt; map to [Optional(1)] -&gt; reduce does</p>\n\n<pre><code>\"Empty XOR Present\" yields Optional(1)\n</code></pre>\n\n<p>= Optional(1)</p>\n\n<p><strong>Two elements</strong> [1, 2] -&gt; map to [Optional(1), Optional(2)] -&gt; reduce does: </p>\n\n<pre><code>\"Empty XOR Present\" yields Optional(1)\n\"Optional(1) XOR Optional(2)\" yields Optional.Empty\n</code></pre>\n\n<p>= Optional.Empty</p>\n\n<p>Here is the complete testcase:</p>\n\n<pre><code>public static &lt;T&gt; Optional&lt;T&gt; singleOrEmpty(Stream&lt;T&gt; stream) {\n    return stream.limit(2)\n        .map(Optional::ofNullable)\n        .reduce(Optional.empty(),\n             (a, b) -&gt; a.isPresent() ^ b.isPresent() ? b : Optional.empty());\n}\n\n@Test\npublic void test() {\n    testCase(Optional.empty());\n    testCase(Optional.of(1), 1);\n    testCase(Optional.empty(), 1, 1);\n    testCase(Optional.empty(), 1, 1, 1);\n}\n\nprivate void testCase(Optional&lt;Integer&gt; expected, Integer... values) {\n    Assert.assertEquals(expected, singleOrEmpty(Arrays.stream(values)));\n}\n</code></pre>\n\n<p>Kudos to Ned (the OP) who has contributed the XOR idea and the above testcase!</p>\n    "},{"t":"Is method reference caching a good idea in Java 8?","l":"http://stackoverflow.com/questions/23983832/is-method-reference-caching-a-good-idea-in-java-8","q":"\n\n<p>Consider I have code like the following:</p>\n\n<pre><code>class Foo {\n\n   Y func(X x) {...} \n\n   void doSomethingWithAFunc(Function&lt;X,Y&gt; f){...}\n\n   void hotFunction(){\n        doSomethingWithAFunc(this::func);\n   }\n\n}\n</code></pre>\n\n<p>Suppose that <code>hotFunction</code> is called very often. Would it then be advisable to cache <code>this::func</code>, maybe like this:</p>\n\n<pre><code>class Foo {\n     Function&lt;X,Y&gt; f = this::func;\n     ...\n     void hotFunction(){\n        doSomethingWithAFunc(f);\n     }\n}\n</code></pre>\n\n<p>As far as my understanding of java method references goes, the Virtual Machine creates an object of an anonymous class when a method reference is used. Thus, caching the reference would create that object only once while the first approach creates it on each function call. Is this correct?</p>\n\n<p>Should method references that appear at hot positions in the code be cached or is the VM able to optimize this and make the caching superfluous? Is there a general best practice about this or is this highly VM-implemenation specific whether such caching is of any use?</p>\n    ","a":"\n<p>You have to make a distinction between frequent executions of the same <em>call-site</em>, for stateless lambda or state-full lambdas, and frequent uses of a <em>method-reference</em> to the same method (by different call-sites).</p>\n\n<p>Look at the following examples:</p>\n\n<pre><code>    Runnable r1=null;\n    for(int i=0; i&lt;2; i++) {\n        Runnable r2=System::gc;\n        if(r1==null) r1=r2;\n        else System.out.println(r1==r2? \"shared\": \"unshared\");\n    }\n</code></pre>\n\n<p>Here, the same call-site is executed two times, producing a stateless lambda and the current implementation will print <code>\"shared\"</code>.</p>\n\n<pre><code>Runnable r1=null;\nfor(int i=0; i&lt;2; i++) {\n  Runnable r2=Runtime.getRuntime()::gc;\n  if(r1==null) r1=r2;\n  else {\n    System.out.println(r1==r2? \"shared\": \"unshared\");\n    System.out.println(\n        r1.getClass()==r2.getClass()? \"shared class\": \"unshared class\");\n  }\n}\n</code></pre>\n\n<p>In this second example, the same call-site is executed two times, producing a lambda containing a reference to a <code>Runtime</code> instance and the current implementation will print <code>\"unshared\"</code> but <code>\"shared class\"</code>.</p>\n\n<pre><code>Runnable r1=System::gc, r2=System::gc;\nSystem.out.println(r1==r2? \"shared\": \"unshared\");\nSystem.out.println(\n    r1.getClass()==r2.getClass()? \"shared class\": \"unshared class\");\n</code></pre>\n\n<p>In contrast, in the last example are two different call-sites producing an equivalent method reference but as of <code>1.8.0_05</code> it will print <code>\"unshared\"</code> and <code>\"unshared class\"</code>.</p>\n\n<hr>\n\n<p>For each lambda expression or method reference the compiler will emit an <code>invokedynamic</code> instruction that refers to a JRE provided bootstrap method in the class <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html\" rel=\"nofollow\"><code>LambdaMetafactory</code></a> and the static arguments necessary to produce the desired lambda implementation class. It is left to the actual JRE what the meta factory produces but it is a specified behavior of the <code>invokedynamic</code> instruction to remember and re-use the <code>CallSite</code> instance created on the first invocation.</p>\n\n<p>The current JRE produces a <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/invoke/ConstantCallSite.html\" rel=\"nofollow\"><code>ConstantCallSite</code></a> containing a <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html\" rel=\"nofollow\"><code>MethodHandle</code></a> to a constant object for stateless lambdas (and there’s no imaginable reason to do it differently). And method references to <code>static</code> method are always stateless. So for stateless lambdas and single call-sites the answer must be: don’t cache, the JVM will do and if it doesn’t, it must have strong reasons that you shouldn’t counteract.</p>\n\n<p>For lambdas having parameters, and <code>this::func</code> is a lambda that has a reference to the <code>this</code> instance, things are a bit different. The JRE is allowed to cache them but this would imply maintaining some sort of <code>Map</code> between actual parameter values and the resulting lambda which could be more costly than just creating that simple structured lambda instance again. The current JRE does not cache lambda instances having a state.</p>\n\n<p>But this does not mean that the lambda class is created every time. It just means that the resolved call-site will behave like an ordinary object construction instantiating the lambda class that has been generated on the first invocation.</p>\n\n<p>Similar things apply to method references to the same target method created by different call-sites. The JRE is allowed to share a single lambda instance between them but in the current version it doesn’t, most probably because it is not clear whether the cache maintenance will pay off. Here, even the generated classes might differ.</p>\n\n<hr>\n\n<p>So caching like in your example might have your program do different things than without. But not necessarily more efficient. A cached object is not always more efficient than a temporary object. Unless you really measure a performance impact caused by a lambda creation, you should not add any caching.</p>\n\n<p>I think, there are only some special cases were caching might be useful:</p>\n\n<ul>\n<li>we are talking about lots of different call-sites referring to the same method</li>\n<li>the lambda is created in the constructor/class initialize because later on the use-site will\n<ul>\n<li>be called by multiple threads concurrently</li>\n<li>suffer from the lower performance of the <em>first</em> invocation</li>\n</ul></li>\n</ul>\n    "},{"t":"Java 8: virtual extension methods vs abstract class","l":"http://stackoverflow.com/questions/18198517/java-8-virtual-extension-methods-vs-abstract-class","q":"\n\n<p>I'm looking at the new virtual extension methods in Java 8 interfaces:</p>\n\n<pre><code>public interface MyInterface {\n   default String myMethod() { \n      return \"myImplementation\"; \n   }\n}\n</code></pre>\n\n<p>I get their purpose in allowing an interface to evolve over time, and the multiple inheritance bit, but they look awfully like an abstract class to me.</p>\n\n<p>If you're doing new work are abstract classes prefered over extension methods to provide implementation to an \"interface\" or are these two approaches conceptually equivalent?</p>\n    ","a":"\n<p>One primary purpose of such constructs is to preserve backwards compatibility. The addition of closures to the Java language is quite a major alteration, and things need to be updated to fully take advantage of this. For example, <a href=\"http://download.java.net/jdk8/docs/api/java/util/Collection.html\"><code>Collection</code></a> in Java 8 will have methods such as <code>forEach()</code> which work in conjunction with lambdas. Simply adding such methods to the pre-existing <code>Collection</code> interface would not be feasible, since it would break backwards compatibility. A class I wrote in Java 7 implementing <code>Collection</code> would no longer compile since it would lack these methods. Consequently, these methods are introduced with a \"default\" implementation. If you know Scala, you can see that Java <code>interface</code>s are becoming more like Scala <code>trait</code>s.</p>\n\n<p>As for interfaces vs abstract classes, the two are still <em>different</em> in Java 8; you still can't have a constructor in an interface, for example. Hence, the two approaches are not \"conceptually equivalent\" per se. Abstract classes are more structured and can have a state associated with them, whereas interfaces can not. You should use whichever makes more sense in the context of your program, just like you would do in Java 7 and below.</p>\n    "},{"t":"Sorting (a stream of) doubles by absolute magnitude","l":"http://stackoverflow.com/questions/30299500/sorting-a-stream-of-doubles-by-absolute-magnitude","q":"\n\n<p>I have a series of double values which I want to sum up and get the maximum value.\nThe <code>DoubleStream.summaryStatistics()</code> sounds perfect for that.\nThe <code>getSum()</code> method has an API note reminding me of what I learned during one of my computer science courses: the stability of the summation problem tends to be better if the values are sorted by their absolute values. However, <code>DoubleStream</code> does not let me specify the comparator to use, it will just use <code>Double.compareTo</code> if I call <code>sorted()</code> on the stream.</p>\n\n<p>Thus I gathered the values into a <code>final Stream.Builder&lt;Double&gt; values = Stream.builder();</code> and call</p>\n\n<pre><code>values.build()\n    .sorted(Comparator.comparingDouble(Math::abs))\n    .mapToDouble(a -&gt; a).summaryStatistics();\n</code></pre>\n\n<p>Yet, this looks somewhat lengthy and I would have preferred to use the <code>DoubleStream.Builder</code> instead of the generic builder.\nDid I miss something or do I really have to use the boxed version of the stream just to be able to specify the comparator?</p>\n    ","a":"\n<p>Primitive streams don't have an overloaded <code>sorted</code> method and will get sorted in natural order. But to go back to your underlying problem, there are ways to improve the accuracy of the sum that don't involve sorting the data first.</p>\n\n<p>One such algorithm is the <a href=\"http://en.wikipedia.org/wiki/Kahan_summation_algorithm\">Kahan summation algorithm</a> which happens to be used by the <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/DoubleSummaryStatistics.java#DoubleSummaryStatistics\">OpenJDK/Oracle JDK internally</a>.</p>\n\n<p>This is admittedly an implementation detail so the usual caveats apply (non-OpenJDK/Oracle JDKs or future OpenJDK JDKs may take alternative approaches etc.)</p>\n\n<p>See also this post: <a href=\"http://stackoverflow.com/questions/6699066/in-which-order-should-floats-be-added-to-get-the-most-precise-result\">In which order should floats be added to get the most precise result?</a></p>\n    "},{"t":"Precise definition of “functional interface” in Java-8","l":"http://stackoverflow.com/questions/14655913/precise-definition-of-functional-interface-in-java-8","q":"\n\n<p>Recently I started exploring Java 8 and I can't quite understand the concept of \"functional interface\" that is essential to Java's implementation of lambda expressions. There is a <a href=\"http://www.lambdafaq.org/\">pretty comprehensive guide</a> to lambda functions in Java, but I got stuck on <a href=\"http://www.lambdafaq.org/what-is-a-functional-interface/\">the chapter that gives definition to the concept of functional interfaces</a>. The definition reads:</p>\n\n<blockquote>\n  <p>More precisely, a functional interface is defined as any interface that has exactly one abstract method.</p>\n</blockquote>\n\n<p>An then he proceeds to examples, one of which is \"Comparator\" interface:</p>\n\n<blockquote>\n  <p>public interface Comparator { int compare(T o1, T o2); boolean equals(Object obj); } </p>\n</blockquote>\n\n<p>I was able to test that I can use a lambda function in place of Comparator argument and it works(i.e. <code>Collections.sort(list, (a, b) -&gt; a-b)</code>). </p>\n\n<p>But in the Comparator interface both compare() and equals() methods are abstract, which means it has <strong>two abstract methods</strong>. So how can this be working, if the definition requires an interface to have <strong>exactly one abstract method</strong>? What am I missing here?</p>\n    ","a":"\n<p>From the <a href=\"http://www.lambdafaq.org/what-is-a-functional-interface/\">same page you linked to</a>: </p>\n\n<blockquote>\n  <p>The interface <code>Comparator</code> is functional although it explicitly declares two methods, because only one is abstract; <code>equals</code> is an explicit declaration of a concrete method inherited from <code>Object</code> that, without this declaration, would otherwise be implicitly declared.</p>\n</blockquote>\n\n<p>I can't really say it better.</p>\n    "},{"t":"Problems running Java 8 TestNG inside IntelliJ","l":"http://stackoverflow.com/questions/15614406/problems-running-java-8-testng-inside-intellij","q":"\n\n<p>I am writing a Maven application using OpenJDK 1.8 and running tests using TestNG.  </p>\n\n<p>When I run Maven from the command line everything works fine, but when I try to run the test inside IntelliJ, then the make process is displaying the following error:</p>\n\n<pre><code>java: javacTask: source release 8 requires target release 1.8\n</code></pre>\n\n<p>I have the project settings pointing to the 1.8 JDK and Project Language Level 8.</p>\n\n<p>Inside Maven I have the following block (which I am guessing is not getting called yet as it seems to be the make causing the problem)</p>\n\n<pre><code>  &lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.3.2&lt;/version&gt;\n    &lt;configuration&gt;\n      &lt;source&gt;1.8&lt;/source&gt;\n      &lt;target&gt;1.8&lt;/target&gt;\n    &lt;/configuration&gt;\n  &lt;/plugin&gt;\n</code></pre>\n\n<p>I have even configured the Maven Runner JRE to point to the 1.8 JDK.</p>\n\n<p>I just don't seem to be able to get IntelliJ 12.0.4 to run the tests properly</p>\n\n<p>Am I missing something?</p>\n    ","a":"\n<p>After the hint from <a href=\"http://stackoverflow.com/users/104891/crazycoder\">CrazyCoder</a> it turns out that .idea/compiler.xml had the following section in it</p>\n\n<pre><code>&lt;bytecodeTargetLevel&gt; \n    &lt;module name=\"game\" target=\"1.7\" /&gt; \n&lt;/bytecodeTargetLevel&gt; \n</code></pre>\n\n<p>I changed this to:</p>\n\n<pre><code>&lt;bytecodeTargetLevel&gt; \n    &lt;module name=\"game\" target=\"1.8\" /&gt; \n&lt;/bytecodeTargetLevel&gt; \n</code></pre>\n\n<p>and it worked</p>\n    "},{"t":"Java 8: performance of Streams vs Collections","l":"http://stackoverflow.com/questions/22658322/java-8-performance-of-streams-vs-collections","q":"\n\n<p>I'm new to Java 8. I still don't know the API in depth, but I've made a small informal benchmark to compare the performance of the new Streams API vs the good old Collections. </p>\n\n<p>The test consists in filtering a list of <code>Integer</code>, and for each even number, calculate the square root and storing it in a result <code>List</code> of <code>Double</code>.</p>\n\n<p>Here is the code:</p>\n\n<pre><code>    public static void main(String[] args) {\n        //Calculating square root of even numbers from 1 to N       \n        int min = 1;\n        int max = 1000000;\n\n        List&lt;Integer&gt; sourceList = new ArrayList&lt;&gt;();\n        for (int i = min; i &lt; max; i++) {\n            sourceList.add(i);\n        }\n\n        List&lt;Double&gt; result = new LinkedList&lt;&gt;();\n\n\n        //Collections approach\n        long t0 = System.nanoTime();\n        long elapsed = 0;\n        for (Integer i : sourceList) {\n            if(i % 2 == 0){\n                result.add(Math.sqrt(i));\n            }\n        }\n        elapsed = System.nanoTime() - t0;       \n        System.out.printf(\"Collections: Elapsed time:\\t %d ns \\t(%f seconds)%n\", elapsed, elapsed / Math.pow(10, 9));\n\n\n        //Stream approach\n        Stream&lt;Integer&gt; stream = sourceList.stream();       \n        t0 = System.nanoTime();\n        result = stream.filter(i -&gt; i%2 == 0).map(i -&gt; Math.sqrt(i)).collect(Collectors.toList());\n        elapsed = System.nanoTime() - t0;       \n        System.out.printf(\"Streams: Elapsed time:\\t\\t %d ns \\t(%f seconds)%n\", elapsed, elapsed / Math.pow(10, 9));\n\n\n        //Parallel stream approach\n        stream = sourceList.stream().parallel();        \n        t0 = System.nanoTime();\n        result = stream.filter(i -&gt; i%2 == 0).map(i -&gt; Math.sqrt(i)).collect(Collectors.toList());\n        elapsed = System.nanoTime() - t0;       \n        System.out.printf(\"Parallel streams: Elapsed time:\\t %d ns \\t(%f seconds)%n\", elapsed, elapsed / Math.pow(10, 9));      \n    }.\n</code></pre>\n\n<p>And here are the results for a dual core machine:</p>\n\n<pre><code>    Collections: Elapsed time:   94338247 ns    (0,094338 seconds)\n    Streams: Elapsed time:       201112924 ns   (0,201113 seconds)\n    Parallel streams: Elapsed time:  357243629 ns   (0,357244 seconds)\n</code></pre>\n\n<p>For this particular test, streams are about twice as slow as collections, and parallelism doesn't help (or either I'm using it the wrong way?).</p>\n\n<p>Questions:</p>\n\n<ul>\n<li>Is this test fair? Have I made any mistake? </li>\n<li>Are streams slower than collections? Has anyone made a good formal benchmark on this?</li>\n<li>Which approach should I strive for?</li>\n</ul>\n\n<hr>\n\n<p><strong>Updated results.</strong></p>\n\n<p>I ran the test 1k times after JVM warmup (1k iterations) as advised by @pveentjer:</p>\n\n<pre><code>    Collections: Average time:      206884437,000000 ns     (0,206884 seconds)\n    Streams: Average time:           98366725,000000 ns     (0,098367 seconds)\n    Parallel streams: Average time: 167703705,000000 ns     (0,167704 seconds)\n</code></pre>\n\n<p>In this case streams are more performant. I wonder what would be observed in an app where the filtering function is only called once or twice during runtime.</p>\n    ","a":"\n<ol>\n<li><p>Stop using <code>LinkedList</code> for anything but heavy removing from the middle of the list using iterator.</p></li>\n<li><p>Stop writing benchmarking code by hand, use <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">JMH</a>.</p></li>\n</ol>\n\n<p>Proper benchmarks:</p>\n\n<pre><code>@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@BenchmarkMode(Mode.AverageTime)\n@OperationsPerInvocation(StreamVsVanilla.N)\npublic class StreamVsVanilla {\n    public static final int N = 10000;\n\n    static List&lt;Integer&gt; sourceList = new ArrayList&lt;&gt;();\n    static {\n        for (int i = 0; i &lt; N; i++) {\n            sourceList.add(i);\n        }\n    }\n\n    @GenerateMicroBenchmark\n    public List&lt;Double&gt; vanilla() {\n        List&lt;Double&gt; result = new ArrayList&lt;&gt;(sourceList.size() / 2 + 1);\n        for (Integer i : sourceList) {\n            if (i % 2 == 0){\n                result.add(Math.sqrt(i));\n            }\n        }\n        return result;\n    }\n\n    @GenerateMicroBenchmark\n    public List&lt;Double&gt; stream() {\n        return sourceList.stream()\n                .filter(i -&gt; i % 2 == 0)\n                .map(Math::sqrt)\n                .collect(Collectors.toCollection(\n                    () -&gt; new ArrayList&lt;&gt;(sourceList.size() / 2 + 1)));\n    }\n}\n</code></pre>\n\n<p>Result:</p>\n\n<pre><code>Benchmark                   Mode   Samples         Mean   Mean error    Units\nStreamVsVanilla.stream      avgt        10       17.588        0.230    ns/op\nStreamVsVanilla.vanilla     avgt        10       10.796        0.063    ns/op\n</code></pre>\n\n<p>Just as I expected stream implementation is fairly slower. JIT is able to inline all lambda stuff but doesn't produce as perfectly concise code as vanilla version.</p>\n\n<p>Generally, Java 8 streams is not a magic. They couldn't speedup already well-implemented things (with, probably, plain iterations or Java 5's for-each statements replaced with <code>Iterable.forEach()</code> and <code>Collection.removeIf()</code> calls). Streams are more about coding convenience and safety. Convenience -- speed tradeoff is working here.</p>\n    "},{"t":"Adding up BigDecimals using Streams","l":"http://stackoverflow.com/questions/22635945/adding-up-bigdecimals-using-streams","q":"\n\n<p>I am trying to understand and learn Lambdas and streams, and I took a real-life scenario to try and help figure things out.</p>\n\n<p>I have a collection of BigDecimals (in this example, a <code>LinkedList</code>) that I would like to add together. Is it possible to use streams for this?</p>\n\n<p>I noticed the <code>Stream</code> class has several methods</p>\n\n<pre><code>Stream::mapToInt\nStream::mapToDouble\nStream::mapToLong\n</code></pre>\n\n<p>Each of which has a convenient <code>sum()</code> method. But, as we know, <code>float</code> and <code>double</code> arithmetic is almost always a bad idea.</p>\n\n<p>So, is there a convenient way to sum up BigDecimals?</p>\n\n<p>This is the code I have so far.</p>\n\n<pre><code>public static void main(String[] args) {\n    LinkedList&lt;BigDecimal&gt; values = new LinkedList&lt;&gt;();\n    values.add(BigDecimal.valueOf(.1));\n    values.add(BigDecimal.valueOf(1.1));\n    values.add(BigDecimal.valueOf(2.1));\n    values.add(BigDecimal.valueOf(.1));\n\n    // Classical Java approach\n    BigDecimal sum = BigDecimal.ZERO;\n    for(BigDecimal value : values) {\n        System.out.println(value);\n        sum = sum.add(value);\n    }\n    System.out.println(\"Sum = \" + sum);\n\n    // Java 8 approach\n    values.forEach((value) -&gt; System.out.println(value));\n    System.out.println(\"Sum = \" + values.stream().mapToDouble(BigDecimal::doubleValue).sum());\n    System.out.println(values.stream().mapToDouble(BigDecimal::doubleValue).summaryStatistics().toString());\n}\n</code></pre>\n\n<p>As you can see, I am summing up the BigDecimals using <code>BigDecimal::doubleValue()</code>, but this is (as expected) not precise.</p>\n\n<p><strong>Post-answer edit for posterity:</strong></p>\n\n<p>Both answers were extremely helpful. I wanted to add a little: my real-life scenario does not involve a collection of raw <code>BigDecimal</code>s, they are wrapped in an invoice. But, I was able to modify Aman Agnihotri's answer to account for this by using the <code>map()</code> function for stream:</p>\n\n<p>This Lambda stuff is really beginning to grow on me!</p>\n\n<pre><code>public static void main(String[] args) {\n\n    LinkedList&lt;Invoice&gt; invoices = new LinkedList&lt;&gt;();\n    invoices.add(new Invoice(\"C1\", \"I-001\", BigDecimal.valueOf(.1), BigDecimal.valueOf(10)));\n    invoices.add(new Invoice(\"C2\", \"I-002\", BigDecimal.valueOf(.7), BigDecimal.valueOf(13)));\n    invoices.add(new Invoice(\"C3\", \"I-003\", BigDecimal.valueOf(2.3), BigDecimal.valueOf(8)));\n    invoices.add(new Invoice(\"C4\", \"I-004\", BigDecimal.valueOf(1.2), BigDecimal.valueOf(7)));\n\n    // Classical Java approach\n    BigDecimal sum = BigDecimal.ZERO;\n    for(Invoice invoice : invoices) {\n        BigDecimal total = invoice.unit_price.multiply(invoice.quantity);\n        System.out.println(total);\n        sum = sum.add(total);\n    }\n    System.out.println(\"Sum = \" + sum);\n\n    // Java 8 approach\n    invoices.forEach((invoice) -&gt; System.out.println(invoice.total()));\n    System.out.println(\"Sum = \" + invoices.stream().map((x) -&gt; x.total()).reduce((x, y) -&gt; x.add(y)).get());\n}\n\nstatic class Invoice {\n    String company;\n    String invoice_number;\n    BigDecimal unit_price;\n    BigDecimal quantity;\n\n    public Invoice() {\n        unit_price = BigDecimal.ZERO;\n        quantity = BigDecimal.ZERO;\n    }\n\n    public Invoice(String company, String invoice_number, BigDecimal unit_price, BigDecimal quantity) {\n        this.company = company;\n        this.invoice_number = invoice_number;\n        this.unit_price = unit_price;\n        this.quantity = quantity;\n    }\n\n    public BigDecimal total() {\n        return unit_price.multiply(quantity);\n    }\n\n    public void setUnit_price(BigDecimal unit_price) {\n        this.unit_price = unit_price;\n    }\n\n    public void setQuantity(BigDecimal quantity) {\n        this.quantity = quantity;\n    }\n\n    public void setInvoice_number(String invoice_number) {\n        this.invoice_number = invoice_number;\n    }\n\n    public void setCompany(String company) {\n        this.company = company;\n    }\n\n    public BigDecimal getUnit_price() {\n        return unit_price;\n    }\n\n    public BigDecimal getQuantity() {\n        return quantity;\n    }\n\n    public String getInvoice_number() {\n        return invoice_number;\n    }\n\n    public String getCompany() {\n        return company;\n    }\n}\n</code></pre>\n    ","a":"\n<h2>Original answer</h2>\n\n<p>Yes, this is possible:</p>\n\n<pre><code>List&lt;BigDecimal&gt; bdList = new ArrayList&lt;&gt;();\n//populate list\nBigDecimal result = bdList.stream()\n        .reduce(BigDecimal.ZERO, BigDecimal::add);\n</code></pre>\n\n<p>What it does is:</p>\n\n<ol>\n<li>Obtain a <code>List&lt;BigDecimal&gt;</code>.</li>\n<li>Turn it into a <code>Stream&lt;BigDecimal&gt;</code></li>\n<li><p>Call the reduce method.</p>\n\n<p>3.1. We supply an identity value for addition, namely <code>BigDecimal.ZERO</code>.</p>\n\n<p>3.2. We specify the <code>BinaryOperator&lt;BigDecimal&gt;</code>, which adds two <code>BigDecimal</code>'s, via a method reference <code>BigDecimal::add</code>.</p></li>\n</ol>\n\n<h2>Updated answer, after edit</h2>\n\n<p>I see that you have added new data, therefore the new answer will become:</p>\n\n<pre><code>List&lt;Invoice&gt; invoiceList = new ArrayList&lt;&gt;();\n//populate\nFunction&lt;Invoice, BigDecimal&gt; totalMapper = invoice -&gt; invoice.getUnit_price().multiply(invoice.getQuantity());\nBigDecimal result = invoiceList.stream()\n        .map(totalMapper)\n        .reduce(BigDecimal.ZERO, BigDecimal::add);\n</code></pre>\n\n<p>It is mostly the same, except that I have added a <code>totalMapper</code> variable, that has a function from <code>Invoice</code> to <code>BigDecimal</code> and returns the total price of that invoice.</p>\n\n<p>Then I obtain a <code>Stream&lt;Invoice&gt;</code>, map it to a <code>Stream&lt;BigDecimal&gt;</code> and then reduce it to a <code>BigDecimal</code>.</p>\n\n<p>Now, from an OOP design point I would advice you to also actually use the <code>total()</code> method, which you have already defined, then it even becomes easier:</p>\n\n<pre><code>List&lt;Invoice&gt; invoiceList = new ArrayList&lt;&gt;();\n//populate\nBigDecimal result = invoiceList.stream()\n        .map(Invoice::total)\n        .reduce(BigDecimal.ZERO, BigDecimal::add);\n</code></pre>\n\n<p>Here we directly use the method reference in the <code>map</code> method.</p>\n    "},{"t":"What is a Java 8 “view”?","l":"http://stackoverflow.com/questions/19718696/what-is-a-java-8-view","q":"\n\n<p>I'm watching a talk by Paul Philips : </p>\n\n<p><a href=\"http://www.youtube.com/watch?v=TS1lpKBMkgg\">http://www.youtube.com/watch?v=TS1lpKBMkgg</a></p>\n\n<p>at 12:48 he says \"in Java 8 their views actually work\" when comparing Scala and Java</p>\n\n<p>What are Java \"views\" and what is Scala's equivalent ?</p>\n\n<p>update : Thanks to Daniel's answer I found this article helpful : <a href=\"http://www.scala-lang.org/docu/files/collections-api/collections_42.html\">http://www.scala-lang.org/docu/files/collections-api/collections_42.html</a></p>\n    ","a":"\n<p>Java 8's <code>Stream</code> is what he means by views. They have two important properties:</p>\n\n<ol>\n<li>They are non-strict, which means they only produce the result on-demand.</li>\n<li>They \"fuse\" together multiple operations, so you can do multiple <code>map</code> or <code>filter</code> calls, and the original collection will still be iterated only once.</li>\n</ol>\n\n<p>Scala's equivalent are the various <code>View</code> collections, which you can get by calling <code>.view</code> on an existing collection. They do have these properties -- they are the defining properties, after all -- but are plagued with deficiencies and bugs, not to mention a very complex implementation.</p>\n\n<p>Paul has toyed with alternative implementations for it on and off, but it has never been a priority replacing them.</p>\n    "},{"t":"How to perform Stream functions on an Iterable? [duplicate]","l":"http://stackoverflow.com/questions/20310209/how-to-perform-stream-functions-on-an-iterable","q":"\n\n<div class=\"question-status question-originals-of-duplicate\">\n    <p>This question already has an answer here:</p>\n    <ul>\n        <li>\n            <a href=\"/questions/23114015/why-does-iterablet-not-provide-stream-and-parallelstream-methods\" dir=\"ltr\">Why does Iterable&lt;T&gt; not provide stream() and parallelStream() methods?</a>\n                <span class=\"question-originals-answer-count\">\n                    1 answer\n                </span>\n        </li>\n    </ul>\n</div>\n<p>In Java 8, the <code>Stream</code> class does not have any method to wrap a an <code>Iterable</code>.</p>\n\n<p>Instead, I am obtaining the <code>Spliterator</code> from the <code>Iterable</code> and then obtaining a <code>Stream</code> from <code>StreamSupport</code> like this:</p>\n\n<pre><code>boolean parallel = true;\n\nStreamSupport.stream(spliterator(), parallel)\n                .filter(Row::isEmpty)\n                .collect(Collectors.toList())\n                .forEach(this::deleteRow);\n</code></pre>\n\n<p>Is there some other way of generating <code>Stream</code> operations on an <code>Iterable</code> that I am missing?</p>\n    ","a":"\n<p>My similar question got marked as duplicate, but here is the helper methods I've used to avoid some of the boilerplate:</p>\n\n<pre><code>public static &lt;T&gt; Stream&lt;T&gt; stream(Iterable&lt;T&gt; in) {\n    return StreamSupport.stream(in.spliterator(), false);\n}\n\npublic static &lt;T&gt; Stream&lt;T&gt; parallelStream(Iterable&lt;T&gt; in) {\n    return StreamSupport.stream(in.spliterator(), true);\n}\n</code></pre>\n    "},{"t":"Java Lambdas : How it works in JVM & is it OOP? [closed]","l":"http://stackoverflow.com/questions/29143803/java-lambdas-how-it-works-in-jvm-is-it-oop","q":"\n\n<p>For example in the case of an anonymous inner class, an (anonymous) object reference is passed and methods of that object are executed.</p>\n\n<p>Lambdas are code blocks which will be executed when needed.</p>\n\n<p>What happens in the JVM when lambdas are encountered? Where does the JVM store the code blocks related to lambdas (Heap : Young, Old or Permanent Generation)?</p>\n\n<p>I tried searching, and I got the syntax for using lambdas but was not able to understand what is happening inside JVM, as in JAVA everything is object-based.</p>\n\n<ol>\n<li><p>So in context of OOP how do lambdas work?</p></li>\n<li><p>Do lambdas violate OOP concepts?</p></li>\n<li><p>Is Lambda good for the garbage collector as no objects are created hence\nno worry about memory issues and clearing memory?</p></li>\n</ol>\n    ","a":"\n<p>I wouldn't waste my time thinking weather lambda expressions are a violation of OO principles. Its goal is to increase the power of a language and not to write an OO code, I don't see how lambdas can violate encapsulation, inheritance or polymorphism.</p>\n\n<p>This <a href=\"http://blog.takipi.com/compiling-lambda-expressions-scala-vs-java-8/\">article</a> explains how Java handles lambda expressions:</p>\n\n<blockquote>\n  <p>What’s interesting about Lambda expressions is that from the JVM’s perspective they’re completely invisible. It has no notion of what an anonymous function or a Lambda expression is. It only knows bytecode which is a strict OO specification. It’s up to the makers of the language and its compiler to work within these constraints to create newer, more advanced language elements.</p>\n</blockquote>\n\n<p>Considering the following code:</p>\n\n<pre><code>List names = Arrays.asList(\"1\", \"2\", \"3\");\nStream lengths = names.stream().map(name -&gt; name.length());\n</code></pre>\n\n<blockquote>\n  <p>... It begins quite simply by loading the names var and invokes its <code>.stream()</code> method, but then it does something quite elegant. Instead of creating a new object that will wrap the Lambda function, it uses the new <code>invokeDynamic</code> instruction which was added in Java 7 to dynamically link this call site to the actual Lambda function.</p>\n</blockquote>\n\n<pre><code>aload_1 //load the names var\n\n// call its stream() func\ninvokeinterface java/util/List.stream:()Ljava/util/stream/Stream;\n\n//invokeDynamic magic!\ninvokedynamic #0:apply:()Ljava/util/function/Function;\n\n//call the map() func\ninvokeinterface java/util/stream/Stream.map:\n(Ljava/util/function/Function;)Ljava/util/stream/Stream;\n</code></pre>\n\n<blockquote>\n  <p><code>InvokeDynamic</code> is an instruction that was added in Java 7 to make the JVM less strict, and allows dynamic languages to bind symbols at run-time, vs. doing all the linkage statically when the code is compiled by the JVM.</p>\n</blockquote>\n\n<p>The Lambda code</p>\n\n<pre><code>aload_0\ninvokevirtual java/lang/String.length:()\ninvokestatic java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\nareturn\n</code></pre>\n    "},{"t":"Built-in Java 8 predicate that always returns true?","l":"http://stackoverflow.com/questions/26549659/built-in-java-8-predicate-that-always-returns-true","q":"\n\n<p>Google Guava has a predicate that <a href=\"http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Predicates.html#alwaysTrue%28%29\">always returns <code>true</code></a>. Does Java 8 have something similar for its <code>Predicate</code>? I know I could use <code>(foo)-&gt;{return true;}</code>, but I want something pre-made, analogous to <code>Collections.emptySet()</code>.</p>\n    ","a":"\n<p>There are no built-in always-true and always-false predicates in Java 8. The most concise way to write these is</p>\n\n<pre><code>x -&gt; true\n</code></pre>\n\n<p>and</p>\n\n<pre><code>x -&gt; false\n</code></pre>\n\n<p>Compare these to</p>\n\n<pre><code>Predicate.alwaysTrue() // Guava\n</code></pre>\n\n<p>and finally to an anonymous inner class:</p>\n\n<pre><code>new Predicate&lt;Object&gt;() {\n    public boolean test(Object x) {\n        return true;\n    }\n}\n</code></pre>\n\n<p>Probably the reason that Guava has these built-in predicates is that there is a huge syntactic advantage of a static method call over an anonymous inner class. In Java 8, the lambda syntax is so concise that there is a syntactic <em>disadvantage</em> to writing out a static method call.</p>\n\n<p>That's just a syntactic comparison, though. There is probably a small space advantage if there were a single global always-true predicate, compared to <code>x -&gt; true</code> occurrences spread across multiple classes, each of which would create its own predicate instance. Is this what you're concerned about? The savings didn't seem compelling, which is probably why they weren't added in the first place. But it could be reconsidered for a future release.</p>\n\n<p><strong>UPDATE 2015-04-24</strong></p>\n\n<p>We've considered the addition of a variety of static, named functions such as <code>Predicate.alwaysTrue</code>, <code>Runnable.noop</code>, etc., and we have decided not to add any more in future versions of Java SE.</p>\n\n<p>Certainly there is some value in something that has a name vs. a written-out lambda, but this value is quite small. We expect that people will learn how to read and write <code>x -&gt; true</code> and <code>() -&gt; { }</code> and that their usage will become idiomatic. Even the value of <code>Function.identity()</code> over <code>x -&gt; x</code> is questionable.</p>\n\n<p>There is a tiny performance advantage to reusing an existing function instead of evaluating a written-out lambda, but we expect the usage of these kinds of functions to be so small that such an advantage would be negligible, certainly not worth the API bloat.</p>\n\n<p>Holger also mentioned in comments the possibility of optimizing composed functions such as <code>Predicate.or</code> and such. This was also considered (<a href=\"https://bugs.openjdk.java.net/browse/JDK-8067971\">JDK-8067971</a>) but was deemed somewhat fragile and error-prone, and occurring infrequently enough that it wasn't worth the effort to implement.</p>\n    "},{"t":"How to get the MethodInfo of a Java 8 method reference?","l":"http://stackoverflow.com/questions/19845213/how-to-get-the-methodinfo-of-a-java-8-method-reference","q":"\n\n<p>Please have a look at the following code:</p>\n\n<pre><code>Method methodInfo = MyClass.class.getMethod(\"myMethod\");\n</code></pre>\n\n<p>This works, but the method name is passed as a string, so this will compile even if myMethod does not exist.</p>\n\n<p>On the other hand, Java 8 introduces a method reference feature. It is checked at compile time. It is possible to use this feature to get method info?</p>\n\n<pre><code>printMethodName(MyClass::myMethod);\n</code></pre>\n\n<p>Full example:</p>\n\n<pre><code>@FunctionalInterface\nprivate interface Action {\n\n    void invoke();\n}\n\nprivate static class MyClass {\n\n    public static void myMethod() {\n    }\n}\n\nprivate static void printMethodName(Action action) {\n}\n\npublic static void main(String[] args) throws NoSuchMethodException {\n    // This works, but method name is passed as a string, so this will compile\n    // even if myMethod does not exist\n    Method methodInfo = MyClass.class.getMethod(\"myMethod\");\n\n    // Here we pass reference to a method. It is somehow possible to\n    // obtain java.lang.reflect.Method for myMethod inside printMethodName?\n    printMethodName(MyClass::myMethod);\n}\n</code></pre>\n\n<p>In other words I would like to have a code which is the equivalent of the following C# code:</p>\n\n<pre><code>    private static class InnerClass\n    {\n        public static void MyMethod()\n        {\n            Console.WriteLine(\"Hello\");\n        }\n    }\n\n    static void PrintMethodName(Action action)\n    {\n        // Can I get java.lang.reflect.Method in the same way?\n        MethodInfo methodInfo = action.GetMethodInfo();\n    }\n\n    static void Main()\n    {\n        PrintMethodName(InnerClass.MyMethod);\n    }\n</code></pre>\n    ","a":"\n<p>No, you cannot do this.  You assign a method reference to an instance of a functional interface, but that instance is cooked up by <code>LambdaMetaFactory</code>, and there is no way to drill into it to find the method you originally bound to.</p>\n\n<p>Lambdas and method references in Java work quite differently than delegates in C#.  For some interesting background, read up on <code>invokedynamic</code>.</p>\n    "},{"t":"Default methods and interfaces extending other interfaces","l":"http://stackoverflow.com/questions/29525975/default-methods-and-interfaces-extending-other-interfaces","q":"\n\n<p>Suppose there are two interfaces <code>Interface1</code> and <code>Interface2</code> where <code>Interface2</code> extends <code>Interface1</code>.</p>\n\n<pre><code>interface Interface1 {\n\n    default void method() {\n        System.out.println(\"1\");\n    }\n\n    // Other methods\n}\n\ninterface Interface2 extends Interface1 {\n\n    @Override\n    default void method() {\n        System.out.println(\"2\");\n    }\n\n    // Other methods\n}\n</code></pre>\n\n<p>Suppose I want to create a class that implements <code>Interface2</code> but I want <code>method()</code> to be the version in <code>Interface1</code>. If I write</p>\n\n<pre><code>class MyClass implements Interface1, Interface2 {\n\n    public void method() {\n        Interface1.super.method();\n    }\n}\n</code></pre>\n\n<p>I get the compilation error:</p>\n\n<blockquote>\n  <p>bad type qualifier in default super call: redundant interface Interface1 is extended by Interface2</p>\n</blockquote>\n\n<p>It is possible to get around this by creating a third interface:</p>\n\n<pre><code>interface Interface3 extends Interface1 {\n\n    default void method() {\n        Interface1.super.method();\n    }\n}\n</code></pre>\n\n<p>Then:</p>\n\n<pre><code>class MyClass implements Interface1, Interface2, Interface3 {\n\n    public void method() {\n        Interface3.super.method();\n    }\n}\n</code></pre>\n\n<p>This compiles fine, and if I instantiate a new <code>MyClass</code> and invoke <code>method()</code>, the output is <code>1</code> as expected.</p>\n\n<p>So my question is, given that it is so easy to get around the restriction that you can only write <code>InterfaceName.super.method()</code> for the most specific interface in a chain, what is the reason for the restriction? What problems are prevented by disallowing you from writing <code>Interface1.super.method()</code> in the first place?</p>\n    ","a":"\n<p>This is exactly addressed by the JLS in <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.3\" rel=\"nofollow\">15.12.3.</a> <em>\"Compile-Time Step 3: Is the Chosen Method Appropriate?\"</em>.</p>\n\n<blockquote>\n  <p>If the form is <em>TypeName .</em> super . <em>[TypeArguments] Identifier</em>, then:</p>\n  \n  <ul>\n  <li>[…]</li>\n  <li>If <em>TypeName</em> denotes an interface, let <code>T</code> be the type declaration immediately enclosing the method invocation. <strong>A compile-time error occurs if there exists a method, distinct from the compile-time declaration, that overrides (<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4.1\" rel=\"nofollow\">§9.4.1</a>) the compile-time declaration from a direct superclass or direct superinterface of <code>T</code>.</strong></li>\n  </ul>\n</blockquote>\n\n<p>The JLS goes on to explain why the rule is in place:</p>\n\n<blockquote>\n  <p><strong>In the case that a superinterface overrides a method declared in a grandparent interface, this rule prevents the child interface from \"skipping\" the override by simply adding the grandparent to its list of direct superinterfaces.</strong> The appropriate way to access functionality of a grandparent is through the direct superinterface, and only if that interface chooses to expose the desired behavior.</p>\n</blockquote>\n\n<p>So it more or less exists specifically to stop you from doing what you're trying to do.</p>\n\n<p>But the JLS also seems to acknowledge your workaround:</p>\n\n<blockquote>\n  <p>(Alternately, the developer is free to define his own additional superinterface that exposes the desired behavior with a super method invocation.)</p>\n</blockquote>\n    "},{"t":"Is there any reason to write `new Random()` since Java 8?","l":"http://stackoverflow.com/questions/29698704/is-there-any-reason-to-write-new-random-since-java-8","q":"\n\n<p>For some reason I used to think that <code>java.util.Random</code> is thread-unsafe, a-la <code>HashMap</code> or <code>BitSet</code>, and <code>Math.random()</code> is implemented either as wrapping access to <code>Random</code> with <code>synchronized</code> block, or <code>ThreadLocalRandom.current().nextDouble()</code>.</p>\n\n<p>Actually it turns out that <a href=\"http://stackoverflow.com/q/5819638/648955\"><code>java.util.Random</code> is thread-safe</a> (via atomics). Hence the takeaway: even if I need some random input in a single thread, it makes sense to use <code>ThreadLocalRandom</code>, because there isn't atomic reads and writes inside, compiled as locked instructions and emitting memory barriers.</p>\n\n<p>Moreover, since Java 8, <code>ThreadLocalRandom</code> is essentially a singleton, its state is kept in some fields of <code>java.lang.Thread</code> class. Therefore method <code>ThreadLocalRandom.current()</code> is not an access to <code>ThreadLocalMap</code>, but just a static field read, i. e. very cheap.</p>\n\n<p>I have two questions:</p>\n\n<ol>\n<li><p>From Computer Science point of view, is the output of several linear congruential random generators (initialized the way <code>ThreadLocalRandom</code>s are) is same \"random\" as an output of the single linear congruential random generator (the <code>java.util.Random</code> instance)?</p></li>\n<li><p>If answer to the first question is Yes, is there <em>any</em> reason to write the construction <code>new Random()</code> (without seed) instead of <code>ThreadLocalRandom.current()</code>, <em>ever?</em></p></li>\n</ol>\n\n<p>Update. I supposed that calls like <code>ThreadLocalRandom.current().ints().parallel().collect(...)</code> could be incorrect,  because Thread's random generator state might be not initialized in <code>ForkJoinPool</code> worker threads, but appears that <code>ThreadLocalRandom</code> overrides methods <code>ints()</code>, <code>longs()</code> and <code>doubles()</code>, making the above construction correct.</p>\n    ","a":"\n<blockquote>\n  <p>1... </p>\n</blockquote>\n\n<p>It depends on implementation but for Java it will be the <strike>same</strike> <strong>not as bad</strong> because Java has a <a href=\"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/util/Random.java#108\" rel=\"nofollow\">static unique seed atomic long that is manipulated everytime</a> a Random is created. However I would not be surprised in other languages or implementations this is not the case and they might just use the system time (Java uses the system time as well but uses the unique seed in combination). That is on some systems you could get the same seed for multiple threads.</p>\n\n<p><strong>After further examination and some actual testing (albeit brittle testing) it appears I might have been wrong before</strong> in that it is actually worse to use many (I'm talking 100k) Random number generators at the same time (even though they are different instances). I'm not entirely sure if its seed collision or just the fact that the actual global seed incrementing becomes predictable. Of course this could just be my testing harness or methodology.</p>\n\n<p>According to wikipedia:</p>\n\n<blockquote>\n  <p>Random number generators, particularly for parallel computers, should not be trusted.[12] It is strongly recommended to check the results of simulation with more than one RNG to check if bias is introduced. Among the recommended generators for use on a parallel computer include <strong>combined linear congruential generators using sequence splitting and lagged Fibonacci generators using independent sequences.</strong></p>\n</blockquote>\n\n<p>So in theory it is supposed to be better since ThreadLocalRandom would create independent sequences so maybe my testing is flawed.</p>\n\n<p>This is of course based on pseudo random.</p>\n\n<p>Physical randomness or a secure random generator based on actually entropy might result in differences (ie more/less entropy) but I'm not an expert and I don't have access to one.</p>\n\n<blockquote>\n  <p>2...</p>\n</blockquote>\n\n<p>I can't come up with a particular use case but one might be that you use an ExecutorService that constantly creates and disposes of threads (assume they don't have control of this) but never many at once (ie max 2 concurrent threads). You might find the ThreadLocalRandom to be more expensive instead of creating a single shared Random.</p>\n\n<p>Another reason and probably better reason given your comments is that you might want to reset the seed for all processes. If you have a game that uses threads (not many do but lets pretend) you might want to global reset the seed for testing purposes which is far easier with an AtomicReference to a Random than trying to message pass to all the running threads.</p>\n\n<p>Another reason you might not want to use ThreadLocalRandom are platform reasons. Some platforms have specific requirements on thread creation and thus threadlocal creation. Thus to address \"<em>you have a bigger problem, than randoms</em>\"  check out <a href=\"https://cloud.google.com/appengine/docs/java/\" rel=\"nofollow\">Google Apps</a> where:</p>\n\n<blockquote>\n  <p>A Java application can create a new thread, but there are some restrictions on how to do it. These threads can't \"outlive\" the request that creates them. (On a backend server, an application can spawn a background thread, a thread that can \"outlive\" the request that creates it.)</p>\n</blockquote>\n\n<p>And to address your additional comment of why would you use an ExecutorService that can't reuse threads:</p>\n\n<blockquote>\n  <p>or use the factory object returned by com.google.appengine.api.ThreadManager.currentRequestThreadFactory() with an ExecutorService (e.g., call Executors.newCachedThreadPool(factory)).</p>\n</blockquote>\n\n<p>ie a ThreadPool that doesn't necessarily reuse threads.</p>\n    "},{"t":"Java8: Why is it forbidden to define a default method for a method from java.lang.Object","l":"http://stackoverflow.com/questions/24016962/java8-why-is-it-forbidden-to-define-a-default-method-for-a-method-from-java-lan","q":"\n\n<p>Default methods are a nice new tool in our Java toolbox. However, I tried to write an interface that defines a <code>default</code> version of the <code>toString</code> method. Java tells me that this is forbidden, since methods declared in <code>java.lang.Object</code> may not be <code>default</code>ed. Why is this the case?</p>\n\n<p>I know that there is the \"base class always wins\" rule, so by default (pun ;), any <code>default</code> implementation of an <code>Object</code> method would be overwritten by the method from <code>Object</code> anyway. However, I see no reason why there shouldn't be an exception for methods from <code>Object</code> in the spec. Especially for <code>toString</code> it might be very useful to have a default implementation.</p>\n\n<p>So, what is the reason why Java designers decided to not allow <code>default</code> methods overriding methods from <code>Object</code>?</p>\n    ","a":"\n<p>This is yet another of those language design issues that seems \"obviously a good idea\" until you start digging and you realize that its actually a bad idea.  </p>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html\">This mail</a> has a lot on the subject (and on other subjects too.)  There were several  design forces that converged to bring us to the current design: </p>\n\n<ul>\n<li>The desire to keep the inheritance model simple;</li>\n<li>The fact that once you look past the obvious examples (e.g., turning <code>AbstractList</code> into an interface), you realize that inheriting equals/hashCode/toString is strongly tied to single inheritance and state, and interfaces are multiply inherited and stateless;</li>\n<li>That it potentially opened the door to some surprising behaviors.  </li>\n</ul>\n\n<p>You've already touched on the \"keep it simple\" goal; the inheritance and conflict-resolution rules are designed to be very simple (classes win over interfaces, derived interfaces win over superinterfaces, and any other conflicts are resolved by the implementing class.)  Of course these rules could be tweaked to make an exception, but I think you'll find when you start pulling on that string, that the incremental complexity is not as small as you might think.  </p>\n\n<p>Of course, there's some degree of benefit that would justify more complexity, but in this case it's not there.  The methods we're talking about here are equals, hashCode, and toString.  These methods are all intrinsically about object state, and it is the class that owns the state, not the interface, who is in the best position to determine what equality means for that class (especially as the contract for equality is quite strong; see Effective Java for some surprising consequences); interface writers are just too far removed.  </p>\n\n<p>It's easy to pull out the <code>AbstractList</code> example; it would be lovely if we could get rid of <code>AbstractList</code> and put the behavior into the <code>List</code> interface.  But once you move beyond this obvious example, there are not many other good examples to be found.  At root, <code>AbstractList</code> is designed for single inheritance.  But interfaces must be designed for multiple inheritance.  </p>\n\n<p>Further, imagine you are writing this class:</p>\n\n<pre><code>class Foo implements com.libraryA.Bar, com.libraryB.Moo { \n    // Implementation of Foo, that does NOT override equals\n}\n</code></pre>\n\n<p>The <code>Foo</code> writer looks at the supertypes, sees no implementation of equals, and concludes that to get reference equality, all he need do is inherit equals from <code>Object</code>.  Then, next week, the library maintainer for Bar \"helpfully\" adds a default <code>equals</code> implementation.  Ooops!  Now the semantics of <code>Foo</code> have been broken by an interface in another maintenance domain \"helpfully\" adding a default for a common method.  </p>\n\n<p>Defaults are supposed to be defaults.  Adding a default to an interface where there was none (anywhere in the hierarchy) should not affect the semantics of concrete implementing classes.  But if defaults could \"override\" Object methods, that wouldn't be true.  </p>\n\n<p>So, while it seems like a harmless feature, it is in fact quite harmful: it adds a lot of complexity for little incremental expressivity, and it makes it far too easy for well-intentioned, harmless-looking changes to separately compiled interfaces to undermine the intended semantics of implementing classes.  </p>\n    "},{"t":"Java 8 lambda expression and first-class values","l":"http://stackoverflow.com/questions/15221659/java-8-lambda-expression-and-first-class-values","q":"\n\n<p>Are Java 8 closures really first-class values or are they only a syntactic sugar? </p>\n    ","a":"\n<p>I would say that Java 8 closures (\"Lambdas\") are neither mere syntactic sugar nor are they first-class values.</p>\n\n<p>I've addressed the issue of syntactic sugar in an <a href=\"http://programmers.stackexchange.com/a/181743/59134\">answer</a> to another StackExchange question.</p>\n\n<p>As for whether lambdas are \"first class\" it really depends on your definition, but I'll make a case that lambdas aren't really first class.</p>\n\n<p>In some sense a lambda wants to be a function, but Java 8 is not adding function types. Instead, a lambda expression <em>is converted into</em> an instance of a functional interface. This has allowed lambdas to be added to Java 8 with only minor changes to Java's type system. After conversion, the result is a reference just like that of any other reference type. In fact, using a Lambda -- for example, in a method that was passed a lambda expression as parameter -- is indistinguishable from calling a method through an interface. A method that receives a parameter of a functional interface type can't tell whether it was passed a lambda expression or an instance of some class that happens to implement that functional interface.</p>\n\n<p>For more information about whether lambdas are objects, see the <a href=\"http://www.lambdafaq.org/are-lambda-expressions-objects/\">Lambda FAQ Answer</a> to this question.</p>\n\n<p>Given that lambdas are converted into objects, they inherit (literally) all the characteristics of objects. In particular, objects:</p>\n\n<ul>\n<li>have various methods like <code>equals</code>, <code>getClass</code>, <code>hashCode</code>, <code>notify</code>, <code>toString</code>, and <code>wait</code></li>\n<li>have an identity hash code</li>\n<li>can be locked by a <code>synchronized</code> block</li>\n<li>can be compared using the <code>==</code> and <code>!=</code> and <code>instanceof</code> operators</li>\n</ul>\n\n<p>and so forth. In fact, all of these are <strong>irrelevant</strong> to the intended usage of lambdas. Their behavior is essentially undefined. You can write a program that uses any of these, and you will get some result, but the result may differ from release to release (or even run to run!).</p>\n\n<p>Restating this more concisely, in Java, objects have <em>identity</em>, but values (particularly function values, if they were to exist) should not have any notion of identity. Java 8 does not have function types. Instead, lambda expressions are converted to objects, so they have a lot baggage that's irrelevant to functions, particularly identity. That doesn't seem like \"first class\" to me.</p>\n\n<p><strong>Update 2013-10-24</strong></p>\n\n<p>I've been thinking further on this topic since having posted my answer several months ago. From a technical standpoint everything I wrote above is correct. The conclusion is probably expressed more precisely as Java 8 lambdas not being <em>pure</em> (as opposed to <em>first-class</em>) values, because they carry a lot of object baggage along. However, just because they're impure doesn't mean they aren't first-class. Consider the <a href=\"https://en.wikipedia.org/wiki/First-class_function\">Wikipedia definition</a> of first-class function. Briefly, the criteria listed there for considering functions first-class are the abilities to:</p>\n\n<ul>\n<li>pass functions as arguments to other functions</li>\n<li>return functions from other functions</li>\n<li>assign functions to variables</li>\n<li>store functions in data structures</li>\n<li>have functions be anonymous</li>\n</ul>\n\n<p>Java 8 lambdas meet <strong>all</strong> of these criteria. So that does make them seem first-class.</p>\n\n<p>The article also mentions function names not having special status, instead a function's name is simply a variable whose type is a function type. Java 8 lambdas do not meet this last criterion. Java 8 doesn't have function types; it has functional interfaces. These are used effectively like function types, but they aren't function types at all. If you have a reference whose type is a functional interface, you have no idea whether it's a lambda, an instance of an anonymous inner class, or an instance of a concrete class that happens to implement that interface.</p>\n\n<p>In summary, Java 8 lambdas are more first-class functions than I had originally thought. They just aren't <em>pure</em> first-class functions.</p>\n    "},{"t":"Tomcat7 and Java8 won't start","l":"http://stackoverflow.com/questions/23541532/tomcat7-and-java8-wont-start","q":"\n\n<p>I'm porting a webapp from Tomcat 7 to another server with Tomcat 7 but with Java 8.</p>\n\n<p>Tomcat starts successfully but in log <code>catalina.out</code> I get:</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in \nconstant pool: 15\n        at org.apache.tomcat.util.bcel.classfile.Constant.readConstant(Constant.java:131)\n        at org.apache.tomcat.util.bcel.classfile.ConstantPool.&lt;init&gt;(ConstantPool.java:60)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:209)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.parse(ClassParser.java:119)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:2049)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1931)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1899)\n        at org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1885)\n        at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1281)\n        at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855)\n        at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:346)\n        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n        at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5172)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:899)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:875)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:618)\n        at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1100)\n        at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1618)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n\n    mag 08, 2014 9:06:44 AM org.apache.catalina.startup.ContextConfig processAnnotationsJar\n    GRAVE: Unable to process Jar entry [jdk/nashorn/internal/objects/NativeDate$Constructor.class] from Jar [jar:file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/nashorn.jar!/] for annotations\n    org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 15\n        at org.apache.tomcat.util.bcel.classfile.Constant.readConstant(Constant.java:131)\n        at org.apache.tomcat.util.bcel.classfile.ConstantPool.&lt;init&gt;(ConstantPool.java:60)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:209)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.parse(ClassParser.java:119)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:2049)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1931)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1899)\n        at org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1885)\n        at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1281)\n        at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855)\n        at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:346)\n        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n        at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5172)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:899)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:875)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:618)\n        at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1100)\n        at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1618)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n\n    mag 08, 2014 9:06:44 AM org.apache.catalina.startup.ContextConfig processAnnotationsJar\n    GRAVE: Unable to process Jar entry [jdk/nashorn/internal/objects/NativeUint8Array$Prototype.class] from Jar [jar:file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/nashorn.jar!/] for annotations\n    org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 15\n        at org.apache.tomcat.util.bcel.classfile.Constant.readConstant(Constant.java:131)\n        at org.apache.tomcat.util.bcel.classfile.ConstantPool.&lt;init&gt;(ConstantPool.java:60)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:209)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.parse(ClassParser.java:119)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:2049)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1931)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1899)\n        at org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1885)\n        at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1281)\n        at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855)\n        at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:346)\n        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n        at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5172)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:899)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:875)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:618)\n        at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1100)\n        at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1618)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n\n    mag 08, 2014 9:06:44 AM org.apache.catalina.startup.ContextConfig processAnnotationsJar\n    GRAVE: Unable to process Jar entry [jdk/nashorn/internal/objects/NativeError$Constructor.class] from Jar [jar:file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/nashorn.jar!/] for annotations\n    org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 15\n        at org.apache.tomcat.util.bcel.classfile.Constant.readConstant(Constant.java:131)\n        at org.apache.tomcat.util.bcel.classfile.ConstantPool.&lt;init&gt;(ConstantPool.java:60)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:209)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.parse(ClassParser.java:119)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:2049)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1931)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1899)\n        at org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1885)\n        at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1281)\n        at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855)\n        at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:346)\n        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n        at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5172)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:899)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:875)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:618)\n        at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1100)\n        at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1618)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n\n    mag 08, 2014 9:06:44 AM org.apache.catalina.startup.ContextConfig processAnnotationsJar\n    GRAVE: Unable to process Jar entry [jdk/nashorn/internal/objects/NativeRegExp$Constructor.class] from Jar [jar:file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/nashorn.jar!/] for annotations\n    org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 15\n        at org.apache.tomcat.util.bcel.classfile.Constant.readConstant(Constant.java:131)\n        at org.apache.tomcat.util.bcel.classfile.ConstantPool.&lt;init&gt;(ConstantPool.java:60)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:209)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.parse(ClassParser.java:119)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:2049)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1931)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1899)\n        at org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1885)\n        at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1281)\n        at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855)\n        at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:346)\n        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n        at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5172)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:899)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:875)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:618)\n        at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1100)\n        at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1618)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n\n    mag 08, 2014 9:06:44 AM org.apache.catalina.startup.ContextConfig processAnnotationsJar\n    GRAVE: Unable to process Jar entry [jdk/nashorn/internal/objects/NativeFloat32Array$Prototype.class] from Jar [jar:file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/nashorn.jar!/] for annotations\n    org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 15\n        at org.apache.tomcat.util.bcel.classfile.Constant.readConstant(Constant.java:131)\n        at org.apache.tomcat.util.bcel.classfile.ConstantPool.&lt;init&gt;(ConstantPool.java:60)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:209)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.parse(ClassParser.java:119)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:2049)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1931)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1899)\n        at org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1885)\n        at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1281)\n        at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855)\n        at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:346)\n        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n        at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5172)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:899)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:875)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:618)\n        at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1100)\n        at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1618)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n\n    mag 08, 2014 9:06:44 AM org.apache.catalina.startup.ContextConfig processAnnotationsJar\n    GRAVE: Unable to process Jar entry [jdk/nashorn/internal/objects/NativeJavaImporter$Constructor.class] from Jar [jar:file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/nashorn.jar!/] for annotations\n    org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 15\n        at org.apache.tomcat.util.bcel.classfile.Constant.readConstant(Constant.java:131)\n        at org.apache.tomcat.util.bcel.classfile.ConstantPool.&lt;init&gt;(ConstantPool.java:60)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:209)\n        at org.apache.tomcat.util.bcel.classfile.ClassParser.parse(ClassParser.java:119)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsStream(ContextConfig.java:2049)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsJar(ContextConfig.java:1931)\n        at org.apache.catalina.startup.ContextConfig.processAnnotationsUrl(ContextConfig.java:1899)\n        at org.apache.catalina.startup.ContextConfig.processAnnotations(ContextConfig.java:1885)\n        at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1281)\n        at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:855)\n        at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:346)\n        at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119)\n        at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:90)\n        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5172)\n        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\n        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:899)\n        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:875)\n        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:618)\n        at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:1100)\n        at org.apache.catalina.startup.HostConfig$DeployDirectory.run(HostConfig.java:1618)\n        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at java.lang.Thread.run(Thread.java:745)\n</code></pre>\n\n<p>AND MANY OTHER EXCEPTIONS!</p>\n\n<p>What could be the problem??\nThanks!</p>\n    ","a":"\n<p>The \"offical answer\" is that Tomcat 7 runs on Java 8, see\n<a href=\"http://tomcat.apache.org/whichversion.html\">http://tomcat.apache.org/whichversion.html</a> (\"Java version 6 and later\").</p>\n\n<p>However, if annotation scanning is enabled (metadata-complete=\"true\" in web.xml) there are some issues due to BCEL (not able to process the new Java 8 byte codes). You will get exceptions like (at least with Tomcat 7.0.28):</p>\n\n<pre><code>SEVERE: Unable to process Jar entry [jdk/nashorn/internal/objects/NativeString.class] from Jar [jar:file:/usr/lib/jvm/jdk1.8.0_5/jre/lib/ext/nashorn.jar!/] for annotations\norg.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 15\n    at org.apache.tomcat.util.bcel.classfile.Constant.readConstant(Constant.java:131)\n</code></pre>\n\n<p>If <strong>not</strong> using annotation scanning, everything works fine, starting release 7.0.53 (updated compiler with better Java 8 support).</p>\n\n<p>(UPDATE 2014-10-17)\nIf your <strong>are</strong> using annotation scanning <strong>and</strong> your own code is not Java 8 based, another solution is to add the following line in <code>/etc/tomcat7/catalina.properties</code> (text added after \"ant-launcher.jar\" so part of property <code>tomcat.util.scan.DefaultJarScanner.jarsToSkip</code>):</p>\n\n<pre><code>junit.jar,junit-*.jar,ant-launcher.jar,\\\njfxrt.jar,nashorn.jar\n</code></pre>\n\n<p>Tested with Tomcat 7.0.28 and Oracle JDK 8_25 on Debian 7.6.</p>\n    "},{"t":"Is it possible to cast a Stream in Java 8?","l":"http://stackoverflow.com/questions/22511750/is-it-possible-to-cast-a-stream-in-java-8","q":"\n\n<p>Is it possible to cast a stream in Java 8? Say I have a list of objects, I can do something like this to filter out all the additional objects:</p>\n\n<pre><code>Stream.of(objects).filter(c -&gt; c instanceof Client)\n</code></pre>\n\n<p>After this though, if I want to do something with the clients I would need to cast each of them:</p>\n\n<pre><code>Stream.of(objects).filter(c -&gt; c instanceof Client)\n    .map(c -&gt; ((Client) c).getID()).forEach(System.out::println);\n</code></pre>\n\n<p>This looks a little ugly. Is it possible to cast an entire stream to a different type? Like cast <code>Stream&lt;Object&gt;</code> to a <code>Stream&lt;Client&gt;</code>?</p>\n\n<p>Please ignore the fact that doing things like this would probably mean bad design. We do stuff like this in my computer science class, so I was looking into the new features of java 8 and was curious if this was possible.</p>\n    ","a":"\n<p>I don't think there is a way to do that out-of-the-box. A possibly cleaner solution would be:</p>\n\n<pre><code>Stream.of(objects).filter(c -&gt; c instanceof Client)\n    .map(c -&gt; (Client) c)\n    .map(Client::getID).forEach(System.out::println);\n</code></pre>\n\n<p>or, as suggested in the comments, you could use the <code>cast</code> method - the former may be easier to read though:</p>\n\n<pre><code>Stream.of(objects).filter(c -&gt; c instanceof Client)\n    .map(Client.class::cast)\n    .map(Client::getID).forEach(System.out::println);\n</code></pre>\n    "},{"t":"Erratic performance of Arrays.stream().map().sum()","l":"http://stackoverflow.com/questions/25847397/erratic-performance-of-arrays-stream-map-sum","q":"\n\n<p>I have chanced upon an instance of exceedingly erratic performance profile of a very simple map/reduce operation on primitive arrays. Here is my jmh benchmark code:</p>\n\n<pre><code>@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@BenchmarkMode(Mode.AverageTime)\n@OperationsPerInvocation(Measure.ARRAY_SIZE)\n@Warmup(iterations = 300, time = 200, timeUnit=MILLISECONDS)\n@Measurement(iterations = 1, time = 1000, timeUnit=MILLISECONDS)\n@State(Scope.Thread)\n@Threads(1)\n@Fork(1)\npublic class Measure\n{\n  static final int ARRAY_SIZE = 1&lt;&lt;20;\n  final int[] ds = new int[ARRAY_SIZE];\n\n  private IntUnaryOperator mapper;\n\n  @Setup public void setup() {\n    setAll(ds, i-&gt;(int)(Math.random()*(1&lt;&lt;7)));\n    final int multiplier = (int)(Math.random()*10);\n    mapper = d -&gt; multiplier*d;\n  }\n\n  @Benchmark public double multiply() {\n    return Arrays.stream(ds).map(mapper).sum();\n  }\n}\n</code></pre>\n\n<p>And here are the snippets of the typical output:</p>\n\n<pre><code># VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_20.jdk/Contents/Home/jre/bin/java\n# VM options: &lt;none&gt;\n# Warmup: 300 iterations, 200 ms each\n# Measurement: 1 iterations, 1000 ms each\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Average time, time/op\n# Benchmark: org.sample.Measure.multiply\n\n# Run progress: 0,00% complete, ETA 00:01:01\n# Fork: 1 of 1\n# Warmup Iteration   1: 0,779 ns/op\n# Warmup Iteration   2: 0,684 ns/op\n# Warmup Iteration   3: 0,608 ns/op\n# Warmup Iteration   4: 0,619 ns/op\n# Warmup Iteration   5: 0,642 ns/op\n# Warmup Iteration   6: 0,638 ns/op\n# Warmup Iteration   7: 0,660 ns/op\n# Warmup Iteration   8: 0,611 ns/op\n# Warmup Iteration   9: 0,636 ns/op\n# Warmup Iteration  10: 0,692 ns/op\n# Warmup Iteration  11: 0,632 ns/op\n# Warmup Iteration  12: 0,612 ns/op\n# Warmup Iteration  13: 1,280 ns/op\n# Warmup Iteration  14: 7,261 ns/op\n# Warmup Iteration  15: 7,379 ns/op\n# Warmup Iteration  16: 7,376 ns/op\n# Warmup Iteration  17: 7,379 ns/op\n# Warmup Iteration  18: 7,195 ns/op\n# Warmup Iteration  19: 7,351 ns/op\n# Warmup Iteration  20: 7,761 ns/op\n....\n....\n....\n# Warmup Iteration 100: 7,300 ns/op\n# Warmup Iteration 101: 7,384 ns/op\n# Warmup Iteration 102: 7,132 ns/op\n# Warmup Iteration 103: 7,278 ns/op\n# Warmup Iteration 104: 7,331 ns/op\n# Warmup Iteration 105: 7,335 ns/op\n# Warmup Iteration 106: 7,450 ns/op\n# Warmup Iteration 107: 7,346 ns/op\n# Warmup Iteration 108: 7,826 ns/op\n# Warmup Iteration 109: 7,221 ns/op\n# Warmup Iteration 110: 8,017 ns/op\n# Warmup Iteration 111: 7,611 ns/op\n# Warmup Iteration 112: 7,376 ns/op\n# Warmup Iteration 113: 0,707 ns/op\n# Warmup Iteration 114: 0,828 ns/op\n# Warmup Iteration 115: 0,608 ns/op\n# Warmup Iteration 116: 0,634 ns/op\n# Warmup Iteration 117: 0,633 ns/op\n# Warmup Iteration 118: 0,660 ns/op\n# Warmup Iteration 119: 0,635 ns/op\n# Warmup Iteration 120: 0,566 ns/op\n</code></pre>\n\n<p>The key moments happen at iterations 13 and 113: first the performance is degraded by a factor of ten, then it is restored. The corresponding times are 2.5 and 22.5 seconds into the test run. The timing of these events is very sensitive to the array size, BTW.</p>\n\n<p>What can possibly explain this sort of behavior? The JIT compiler had probably done its work within the first iteration; there is no GC action to speak of (confirmed by VisualVM)... I am at a complete loss as to any kind of explanation.</p>\n\n<p>My version of Java (OS X):</p>\n\n<pre><code>$ java -version\njava version \"1.8.0_20\"\nJava(TM) SE Runtime Environment (build 1.8.0_20-b26)\nJava HotSpot(TM) 64-Bit Server VM (build 25.20-b23, mixed mode)\n</code></pre>\n    ","a":"\n<p>The JIT will first compile the hot loop that is iterating over and operating (map/reduce) on the array elements. This happens quite early on since the array contains 2<sup>20</sup> elements.</p>\n\n<p>Later on the JIT compiles the pipeline, most likely inlined within the compiled benchmark method, and due to inlining limits fails to compile it all into one method. It just so happens those inlining limits are reached in the hot loop, and calls to map or sum are not inlined, so the hot loop is unintentionally \"de-optimized\".</p>\n\n<p>Use the options <code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining</code> when running the benchmark and early on you should see output like the following:</p>\n\n<pre><code>   1202  487 %     4       java.util.Spliterators$IntArraySpliterator::forEachRemaining @ 49 (68 bytes)\n                              @ 53   java.util.stream.IntPipeline$3$1::accept (23 bytes)   inline (hot)\n                               \\-&gt; TypeProfile (1186714/1186714 counts) = java/util/stream/IntPipeline$3$1\n                                @ 12   test.Measure$$Lambda$2/1745776415::applyAsInt (9 bytes)   inline (hot)\n                                 \\-&gt; TypeProfile (1048107/1048107 counts) = test/Measure$$Lambda$2\n                                  @ 5   test.Measure::lambda$setup$1 (4 bytes)   inline (hot)\n                                @ 17   java.util.stream.ReduceOps$5ReducingSink::accept (19 bytes)   inline (hot)\n                                 \\-&gt; TypeProfile (1048107/1048107 counts) = java/util/stream/ReduceOps$5ReducingSink\n                                  @ 10   java.util.stream.IntPipeline$$Lambda$3/1779653790::applyAsInt (6 bytes)   inline (hot)\n                                   \\-&gt; TypeProfile (1048064/1048064 counts) = java/util/stream/IntPipeline$$Lambda$3\n                                    @ 2   java.lang.Integer::sum (4 bytes)   inline (hot)\n</code></pre>\n\n<p>That is the hot loop getting compiled. (The <code>%</code> means it is On Stack Replaced, or OSR'ed)</p>\n\n<p>Later on further compilation of the stream pipeline occurs (at i suspect ~10,000 iterations of the benchmark method, but I have not verified):</p>\n\n<pre><code>                          @ 16   java.util.stream.IntPipeline::sum (11 bytes)   inline (hot)\n                           \\-&gt; TypeProfile (5120/5120 counts) = java/util/stream/IntPipeline$3\n                            @ 2   java.lang.invoke.LambdaForm$MH/1279902262::linkToTargetMethod (8 bytes)   force inline by annotation\n                              @ 4   java.lang.invoke.LambdaForm$MH/1847865997::identity (18 bytes)   force inline by annotation\n                                @ 14   java.lang.invoke.LambdaForm$DMH/2024969684::invokeStatic_L_L (14 bytes)   force inline by annotation\n                                  @ 1   java.lang.invoke.DirectMethodHandle::internalMemberName (8 bytes)   force inline by annotation\n                                  @ 10   sun.invoke.util.ValueConversions::identity (2 bytes)   inline (hot)\n                            @ 7   java.util.stream.IntPipeline::reduce (16 bytes)   inline (hot)\n                              @ 3   java.util.stream.ReduceOps::makeInt (18 bytes)   inline (hot)\n                                @ 1   java.util.Objects::requireNonNull (14 bytes)   inline (hot)\n                                @ 14   java.util.stream.ReduceOps$5::&lt;init&gt; (16 bytes)   inline (hot)\n                                  @ 12   java.util.stream.ReduceOps$ReduceOp::&lt;init&gt; (10 bytes)   inline (hot)\n                                    @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n                              @ 6   java.util.stream.AbstractPipeline::evaluate (94 bytes)   inline (hot)\n                                @ 50   java.util.stream.AbstractPipeline::isParallel (8 bytes)   inline (hot)\n                                @ 80   java.util.stream.TerminalOp::getOpFlags (2 bytes)   inline (hot)\n                                 \\-&gt; TypeProfile (5122/5122 counts) = java/util/stream/ReduceOps$5\n                                @ 85   java.util.stream.AbstractPipeline::sourceSpliterator (163 bytes)   inline (hot)\n                                  @ 79   java.util.stream.AbstractPipeline::isParallel (8 bytes)   inline (hot)\n                                @ 88   java.util.stream.ReduceOps$ReduceOp::evaluateSequential (18 bytes)   inline (hot)\n                                  @ 2   java.util.stream.ReduceOps$5::makeSink (5 bytes)   inline (hot)\n                                    @ 1   java.util.stream.ReduceOps$5::makeSink (16 bytes)   inline (hot)\n                                      @ 12   java.util.stream.ReduceOps$5ReducingSink::&lt;init&gt; (15 bytes)   inline (hot)\n                                        @ 11   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n                                  @ 6   java.util.stream.AbstractPipeline::wrapAndCopyInto (18 bytes)   inline (hot)\n                                    @ 3   java.util.Objects::requireNonNull (14 bytes)   inline (hot)\n                                    @ 9   java.util.stream.AbstractPipeline::wrapSink (37 bytes)   inline (hot)\n                                      @ 1   java.util.Objects::requireNonNull (14 bytes)   inline (hot)\n                                      @ 23   java.util.stream.IntPipeline$3::opWrapSink (10 bytes)   inline (hot)\n                                       \\-&gt; TypeProfile (4868/4868 counts) = java/util/stream/IntPipeline$3\n                                        @ 6   java.util.stream.IntPipeline$3$1::&lt;init&gt; (11 bytes)   inline (hot)\n                                          @ 7   java.util.stream.Sink$ChainedInt::&lt;init&gt; (16 bytes)   inline (hot)\n                                            @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n                                            @ 6   java.util.Objects::requireNonNull (14 bytes)   inline (hot)\n                                    @ 13   java.util.stream.AbstractPipeline::copyInto (53 bytes)   inline (hot)\n                                      @ 1   java.util.Objects::requireNonNull (14 bytes)   inline (hot)\n                                      @ 9   java.util.stream.AbstractPipeline::getStreamAndOpFlags (5 bytes)   accessor\n                                      @ 12   java.util.stream.StreamOpFlag::isKnown (19 bytes)   inline (hot)\n                                      @ 20   java.util.Spliterator::getExactSizeIfKnown (25 bytes)   inline (hot)\n                                       \\-&gt; TypeProfile (4870/4870 counts) = java/util/Spliterators$IntArraySpliterator\n                                        @ 1   java.util.Spliterators$IntArraySpliterator::characteristics (5 bytes)   accessor\n                                        @ 19   java.util.Spliterators$IntArraySpliterator::estimateSize (11 bytes)   inline (hot)\n                                      @ 25   java.util.stream.Sink$ChainedInt::begin (11 bytes)   inline (hot)\n                                       \\-&gt; TypeProfile (4870/4870 counts) = java/util/stream/IntPipeline$3$1\n                                        @ 5   java.util.stream.ReduceOps$5ReducingSink::begin (9 bytes)   inline (hot)\n                                         \\-&gt; TypeProfile (4871/4871 counts) = java/util/stream/ReduceOps$5ReducingSink\n                                      @ 32   java.util.Spliterator$OfInt::forEachRemaining (53 bytes)   inline (hot)\n                                        @ 12   java.util.Spliterators$IntArraySpliterator::forEachRemaining (68 bytes)   inline (hot)\n                                          @ 53   java.util.stream.IntPipeline$3$1::accept (23 bytes)   inline (hot)\n                                            @ 12   test.Measure$$Lambda$2/1745776415::applyAsInt (9 bytes)   inline (hot)\n                                             \\-&gt; TypeProfile (1048107/1048107 counts) = test/Measure$$Lambda$2\n                                              @ 5   test.Measure::lambda$setup$1 (4 bytes)   inlining too deep\n                                            @ 17   java.util.stream.ReduceOps$5ReducingSink::accept (19 bytes)   inline (hot)\n                                             \\-&gt; TypeProfile (1048107/1048107 counts) = java/util/stream/ReduceOps$5ReducingSink\n                                              @ 10   java.util.stream.IntPipeline$$Lambda$3/1779653790::applyAsInt (6 bytes)   inlining too deep\n                                               \\-&gt; TypeProfile (1048064/1048064 counts) = java/util/stream/IntPipeline$$Lambda$3\n                                          @ 53   java.util.stream.IntPipeline$3$1::accept (23 bytes)   inline (hot)\n                                            @ 12   test.Measure$$Lambda$2/1745776415::applyAsInt (9 bytes)   inline (hot)\n                                             \\-&gt; TypeProfile (1048107/1048107 counts) = test/Measure$$Lambda$2\n                                              @ 5   test.Measure::lambda$setup$1 (4 bytes)   inlining too deep\n                                            @ 17   java.util.stream.ReduceOps$5ReducingSink::accept (19 bytes)   inline (hot)\n                                             \\-&gt; TypeProfile (1048107/1048107 counts) = java/util/stream/ReduceOps$5ReducingSink\n                                              @ 10   java.util.stream.IntPipeline$$Lambda$3/1779653790::applyAsInt (6 bytes)   inlining too deep\n                                               \\-&gt; TypeProfile (1048064/1048064 counts) = java/util/stream/IntPipeline$$Lambda$3\n                                      @ 38   java.util.stream.Sink$ChainedInt::end (10 bytes)   inline (hot)\n                                        @ 4   java.util.stream.Sink::end (1 bytes)   inline (hot)\n                                         \\-&gt; TypeProfile (5120/5120 counts) = java/util/stream/ReduceOps$5ReducingSink\n                                  @ 12   java.util.stream.ReduceOps$5ReducingSink::get (5 bytes)   inline (hot)\n                                    @ 1   java.util.stream.ReduceOps$5ReducingSink::get (8 bytes)   inline (hot)\n                                      @ 4   java.lang.Integer::valueOf (32 bytes)   inline (hot)\n                                        @ 28   java.lang.Integer::&lt;init&gt; (10 bytes)   inline (hot)\n                                          @ 1   java.lang.Number::&lt;init&gt; (5 bytes)   inline (hot)\n                                            @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)\n                              @ 12   java.lang.Integer::intValue (5 bytes)   accessor\n</code></pre>\n\n<p>Note the \"inlining too deep\" that occurs for methods in the hot loop.</p>\n\n<p>Even later on the generated JMH measurement loop is compiled:</p>\n\n<pre><code>  26857  685       3       test.generated.Measure_multiply::multiply_avgt_jmhLoop (55 bytes)\n                              @ 7   java.lang.System::nanoTime (0 bytes)   intrinsic\n                              @ 16   test.Measure::multiply (23 bytes)\n                                @ 4   java.util.Arrays::stream (8 bytes)\n                                  @ 4   java.util.Arrays::stream (11 bytes)\n                                    @ 3   java.util.Arrays::spliterator (10 bytes)\n                                      @ 6   java.util.Spliterators::spliterator (25 bytes)   callee is too large\n                                    @ 7   java.util.stream.StreamSupport::intStream (14 bytes)\n                                      @ 6   java.util.stream.StreamOpFlag::fromCharacteristics (37 bytes)   callee is too large\n                                      @ 10   java.util.stream.IntPipeline$Head::&lt;init&gt; (8 bytes)\n                                        @ 4   java.util.stream.IntPipeline::&lt;init&gt; (8 bytes)\n                                          @ 4   java.util.stream.AbstractPipeline::&lt;init&gt; (55 bytes)   callee is too large\n                                @ 11   java.util.stream.IntPipeline::map (26 bytes)\n                                  @ 1   java.util.Objects::requireNonNull (14 bytes)\n                                    @ 8   java.lang.NullPointerException::&lt;init&gt; (5 bytes)   don't inline Throwable constructors\n                                  @ 22   java.util.stream.IntPipeline$3::&lt;init&gt; (20 bytes)\n                                    @ 16   java.util.stream.IntPipeline$StatelessOp::&lt;init&gt; (29 bytes)   callee is too large\n                                @ 16   java.util.stream.IntPipeline::sum (11 bytes)\n                                  @ 2   java.lang.invoke.LambdaForm$MH/1279902262::linkToTargetMethod (8 bytes)   force inline by annotation\n                                    @ 4   java.lang.invoke.LambdaForm$MH/1847865997::identity (18 bytes)   force inline by annotation\n                                      @ 14   java.lang.invoke.LambdaForm$DMH/2024969684::invokeStatic_L_L (14 bytes)   force inline by annotation\n                                        @ 1   java.lang.invoke.DirectMethodHandle::internalMemberName (8 bytes)   force inline by annotation\n                                        @ 10   sun.invoke.util.ValueConversions::identity (2 bytes)\n                                  @ 7   java.util.stream.IntPipeline::reduce (16 bytes)\n                                    @ 3   java.util.stream.ReduceOps::makeInt (18 bytes)\n                                      @ 1   java.util.Objects::requireNonNull (14 bytes)\n                                      @ 14   java.util.stream.ReduceOps$5::&lt;init&gt; (16 bytes)\n                                        @ 12   java.util.stream.ReduceOps$ReduceOp::&lt;init&gt; (10 bytes)\n                                          @ 1   java.lang.Object::&lt;init&gt; (1 bytes)\n                                    @ 6   java.util.stream.AbstractPipeline::evaluate (94 bytes)   callee is too large\n                                    @ 12   java.lang.Integer::intValue (5 bytes)\n</code></pre>\n\n<p>Note that there is no attempt to inline the whole stream pipeline, it stops well before it reached the hot loop, see \"callee is too large\", thereby re-optimizing the hot loop.</p>\n\n<p>The inline limit can be increased to avoid such behaviour, for example <code>-XX:MaxInlineLevel=12</code>.</p>\n    "},{"t":"Java 8 Time API: how to parse string of format “MM.yyyy” to LocalDate","l":"http://stackoverflow.com/questions/23800477/java-8-time-api-how-to-parse-string-of-format-mm-yyyy-to-localdate","q":"\n\n<p>I'm a bit discouraged with parsing dates in <em>Java 8 Time API</em>.</p>\n\n<p>Previously I could easily write:</p>\n\n<pre><code>String date = \"04.2013\";\nDateFormat df = new SimpleDateFormat(\"MM.yyyy\");\nDate d = df.parse(date);\n</code></pre>\n\n<p>But now if I use <em>LocalDate</em> and do it like this:</p>\n\n<pre><code>String date = \"04.2013\";\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"MM.yyyy\");\nLocalDate ld = LocalDate.parse(date, formatter);\n</code></pre>\n\n<p>I receive an exception:</p>\n\n<pre><code>java.time.format.DateTimeParseException: Text '04' could not be parsed at index 0\njava.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:1948)\njava.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1850)\njava.time.LocalDate.parse(LocalDate.java:400)\njava.time.LocalDate.parse(LocalDate.java:385)\ncom.luxoft.ath.controllers.JsonController.region(JsonController.java:38)\nsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\njava.lang.reflect.Method.invoke(Method.java:483)\norg.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215)\norg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132)\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:749)\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:689)\norg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)\norg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:938)\norg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:870)\norg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:961)\norg.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:852)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:617)\norg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:837)\njavax.servlet.http.HttpServlet.service(HttpServlet.java:723)\norg.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)\norg.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n</code></pre>\n\n<p>If I change string format to <em>\"yyyy-MM-dd\"</em> everything work perfectly, even without formatter: </p>\n\n<pre><code>String date = \"2013-04-12\";\nLocalDate ld = LocalDate.parse(date);\n</code></pre>\n\n<p>So my question is: how to parse date in custom format using Java 8 Time API?</p>\n    ","a":"\n<p>It makes sense: your input is not really a date because it does not have a day information. You should parse it as a <code>YearMonth</code> and use that result if you don't care about the day.</p>\n\n<pre><code>String date = \"04.2013\";\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"MM.yyyy\");\nYearMonth ym = YearMonth.parse(date, formatter);\n</code></pre>\n\n<p>If you do need to apply a specific day, you can obtain a <code>LocalDate</code> from a <code>YearMonth</code> for example:</p>\n\n<pre><code>LocalDate ld = ym.atDay(1);\n//or\nLocalDate ld = ym.atEndOfMonth();\n</code></pre>\n\n<p>You can also use a <code>TemporalAdjuster</code>, for example, for the last day of the month*:</p>\n\n<pre><code>LocalDate ld = ym.atDay(1).with(lastDayOfMonth());\n</code></pre>\n\n<p><sub> *with an <code>import static java.time.temporal.TemporalAdjusters.lastDayOfMonth;</code></sub></p>\n    "},{"t":"Where can I get Java 8 language specification?","l":"http://stackoverflow.com/questions/17358269/where-can-i-get-java-8-language-specification","q":"\n\n<p>Specification for Java 7 is available on the Oracle site, but I can't find Java 8 specification anywhere, although downloads of beta versions of Java 8 are available on the internet. </p>\n\n<p>Do you have an idea: is it already written and where can it be downloaded?\nIf the specification isn't available, maybe another document which can act as (or come close to) the specification?</p>\n    ","a":"\n<p>Now that Java 8 is officially released, the Java Language and JVM specifications can be found on <a href=\"http://docs.oracle.com/javase/specs/index.html\" rel=\"nofollow\">Oracle's website</a>.</p>\n\n<p><strike><strong>Update: thanks to @MadChuckle, <a href=\"http://cr.openjdk.java.net/~mr/se/8/java-se-8-fr-spec-01/java-se-8-jls-fr-diffs.pdf\" rel=\"nofollow\">link to final release</a>.</strong></strike></p><strike>\n\n<p>According to the <a href=\"http://openjdk.java.net/projects/jdk8/spec/\" rel=\"nofollow\">project's page</a>, a public review will start in October 2013. In the meantime, you can follow the progress on the various mailing lists provided on that page or have a look at <a href=\"http://cr.openjdk.java.net/~mr/se/8/java-se-8-edr-spec.01.html\" rel=\"nofollow\">the early draft</a>.</p>\n\n</strike><p><strike>At this stage, the early draft mostly refers to individual sub-projects, so if you want to look at the changes brought by the lambdas for example, you would need to find that sub-project's documents which should indicate <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/attachments/20100122/3764c21a/attachment.txt\" rel=\"nofollow\">the impact on the JLS</a> (not sure if that old draft is the latest - probably not).\n</strike></p>\n    "},{"t":"Why doesn't Java 8's Predicate<T> extend Function<T, Boolean>","l":"http://stackoverflow.com/questions/22682836/why-doesnt-java-8s-predicatet-extend-functiont-boolean","q":"\n\n<p>If I wrote the Predicate interface, i'd want to encode in the interface the fact that it's just a function that returns a primitive boolean, like this:</p>\n\n<pre><code>@FunctionalInterface\npublic interface Predicate&lt;T&gt; extends Function&lt;T, Boolean&gt; {\n\n    boolean test(T t);\n\n    @Override\n    default Boolean apply(T t) {\n        return Boolean.valueOf(test(t));\n    }\n}\n</code></pre>\n\n<p>I was wondering, is there a compelling reason Java 8 API designers chose to keep the Predicate completely separate from Function? Is there some evidence that they considered doing so and decided against it? I guess similar question goes for all the other 'special' functional interfaces like Consumer (could be Function&lt;T, Void&gt;), Supplier (Function&lt;Void, T&gt;) and primitive functions like IntFunction (Function&lt;Integer, T&gt;).</p>\n\n<p>I haven't thought very deeply and thoroughly about all the ramifications of this, so I'm probably missing something.</p>\n\n<p>EDIT: Some of the answers ephasize the semantic distinction between apply and test. I'm not saying I don't appreciate the distinction, and I agree that it's beneficial to have this distinction. What I don't understand is why a Predicate is nevertheless not also a Function in the same way as e.g. a List is a Collection or Double is a Number, which is an Object.</p>\n\n<p>If Predicate (and all the other special generic functional interfaces, such as Consumer, Supplier, IntUnaryOperator etc.) had this relation with Function, it would allow one to use it in place where Function parameter is expected (what comes to mind is composition with other functions, e.g. calling myFunction.compose(myPredicate) or to avoid writing several specialized functions in an API when such auto(un)boxing implementation as described above would be sufficient)</p>\n\n<p>EDIT 2: Looking at openjdk lambda project I found that primitive functional interfaces used to extend Function up until <a href=\"http://hg.openjdk.java.net/lambda/lambda/jdk/rev/68f1d0672940\">this commit from Brian Goetz on 2012-12-19</a>. I couldn't find specific reasons for the change on any of the lambda-dev or JSR experts group mailing lists around that time.</p>\n    ","a":"\n<p>The method in <code>Predicate&lt;T&gt;</code> returns <code>boolean</code>. The method in <code>Function&lt;T, Boolean&gt;</code> returns <code>Boolean</code>. They are not the same. Although there is autoboxing, Java methods don't use wrapper classes when primitives would do. Also, there are differences like <code>Boolean</code> can be <code>null</code> while <code>boolean</code> can't.</p>\n\n<p>It's even more different in the case of <code>Consumer&lt;T&gt;</code>. The method in <code>Consumer&lt;T&gt;</code> has return type <code>void</code>, which means it can implicitly return or return using <code>return;</code>, but the method in <code>Function&lt;T, Void&gt;</code> must return using <code>return null;</code> explicitly.</p>\n    "},{"t":"Findbugs in Eclipse ArrayIndexOutOfBounds Exception when running","l":"http://stackoverflow.com/questions/17259201/findbugs-in-eclipse-arrayindexoutofbounds-exception-when-running","q":"\n\n<p>I just installed (and re-installed) Findbugs in Eclipse Juno and every time I try to run it in any of my projects I get the following error:</p>\n\n<pre><code>An internal error occurred during: \"Finding bugs in &lt;project name&gt;...\".\njava.lang.ArrayIndexOutOfBoundsException\n</code></pre>\n\n<p>Googling didn't provide any useful results. Any ideas?</p>\n\n<p>EDIT: I tried (and probably failed) to install Java 8's test version in Eclipse to try out Java 8's lambdas and other features. Maybe it has something to do with Findbugs not running properly?</p>\n    ","a":"\n<p>FB official release is not yet (2.0.3) compatible with Java 8 class file format.</p>\n\n<p>However, the perfectly working Eclipse plugin daily build of 3.0.0 version is available from this update site: <a href=\"http://findbugs.cs.umd.edu/eclipse-daily\">http://findbugs.cs.umd.edu/eclipse-daily</a></p>\n\n<p>We plan to release 3.0.0 RC1 in the next few days (till the end of the Juni 2014).</p>\n    "},{"t":"Why does the Java 8 generic type inference pick this overload?","l":"http://stackoverflow.com/questions/30521974/why-does-the-java-8-generic-type-inference-pick-this-overload","q":"\n\n<p>Consider the following program:</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>public class GenericTypeInference {\n\n    public static void main(String[] args) {\n        print(new SillyGenericWrapper().get());\n    }\n\n    private static void print(Object object) {\n        System.out.println(\"Object\");\n    }\n\n    private static void print(String string) {\n        System.out.println(\"String\");\n    }\n\n    public static class SillyGenericWrapper {\n        public &lt;T&gt; T get() {\n            return null;\n        }\n    }\n}\n</code></pre>\n\n<p>It prints \"String\" under Java 8 and \"Object\" under Java 7.</p>\n\n<p>I would have expected this to be an ambiguity in Java 8, because both overloaded methods match. Why does the compiler pick <code>print(String)</code> after <a href=\"http://openjdk.java.net/jeps/101\" rel=\"nofollow\">JEP 101</a>? </p>\n\n<p>Justified or not, this breaks backward compatibility and the change cannot be detected at compile time. The code just sneakily behaves differently after upgrading to Java 8.</p>\n\n<p>NOTE: The <code>SillyGenericWrapper</code> is named \"silly\" for a reason. I'm trying to understand why the compiler behaves the way it does, don't tell me that the silly wrapper is a bad design in the first place.</p>\n\n<p>UPDATE: I've also tried to compile and run the example under Java 8 but using a Java 7 language level. The behavior was consistent with Java 7. That was expected, but I still felt the need to verify.</p>\n    ","a":"\n<p>The rules of type inference have received a significant overhaul in Java 8; most notably target type inference has been much improved. So, whereas before Java 8 the method argument site did not receive any inference, defaulting to Object, in Java 8 the most specific applicable type is inferred, in this case String. The JLS for Java 8 introduced a new chapter <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html\" rel=\"nofollow\">Chapter 18. Type Inference</a> that's missing in JLS for Java 7.</p>\n\n<p>Earlier versions of JDK 1.8 (up until 1.8.0_25) had a bug related to overloaded methods resolution when the compiler successfully compiled code which according to JLS should have produce ambiguity error <a href=\"http://stackoverflow.com/questions/23020493/why-is-this-method-overloading-ambiguous\">Why is this method overloading ambiguous?</a> As Marco13 points out in the comments </p>\n\n<blockquote>\n  <p>This part of the JLS is probably the most complicated one</p>\n</blockquote>\n\n<p>which explains the bugs in earlier versions of JDK 1.8 and also the compatibility issue that you see.</p>\n\n<hr>\n\n<p>As shown in the example from the Java Tutoral (<a href=\"https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html\" rel=\"nofollow\">Type Inference</a>)</p>\n\n<blockquote>\n  <p>Consider the following method:</p>\n</blockquote>\n\n<pre><code>void processStringList(List&lt;String&gt; stringList) {\n    // process stringList\n}\n</code></pre>\n\n<blockquote>\n  <p>Suppose you want to invoke the method processStringList with an empty list. In Java SE 7, the following statement does not compile:</p>\n</blockquote>\n\n<pre><code>processStringList(Collections.emptyList());\n</code></pre>\n\n<blockquote>\n  <p>The Java SE 7 compiler generates an error message similar to the following:</p>\n</blockquote>\n\n<pre><code>List&lt;Object&gt; cannot be converted to List&lt;String&gt;\n</code></pre>\n\n<blockquote>\n  <p>The compiler requires a value for the type argument T so it starts with the value Object. Consequently, the invocation of Collections.emptyList returns a value of type List, which is incompatible with the method processStringList. Thus, in Java SE 7, you must specify the value of the value of the type argument as follows:</p>\n</blockquote>\n\n<pre><code>processStringList(Collections.&lt;String&gt;emptyList());\n</code></pre>\n\n<blockquote>\n  <p>This is no longer necessary in Java SE 8. The notion of what is a target type has been expanded to include method arguments, such as the argument to the method processStringList. In this case, processStringList requires an argument of type List</p>\n</blockquote>\n\n<p><code>Collections.emptyList()</code> is a generic method similar to the <code>get()</code> method from the question. <strong>In Java 7 the <code>print(String string)</code> method is not even applicable to the method invocation thus it doesn't take part in the overload resolution process</strong>. Whereas in Java 8 both methods are applicable.</p>\n\n<p>This incompatibility is worth mentioning in the <a href=\"http://www.oracle.com/technetwork/java/javase/8-compatibility-guide-2156366.html\" rel=\"nofollow\">Compatibility Guide for JDK 8</a>.</p>\n\n<hr>\n\n<p>You can check out my answer for a similar question related to overloaded methods resolution <a href=\"http://stackoverflow.com/questions/30130720/method-overload-ambiguity-with-java-8-ternary-conditional-and-unboxed-primitives/30137369#30137369\">Method overload ambiguity with Java 8 ternary conditional and unboxed primitives</a></p>\n\n<p>According to <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5\" rel=\"nofollow\">JLS 15.12.2.5 Choosing the Most Specific Method</a>:</p>\n\n<blockquote>\n  <p>If more than one member method is both accessible and applicable to a\n  method invocation, it is necessary to choose one to provide the\n  descriptor for the run-time method dispatch. The Java programming\n  language uses the rule that the most specific method is chosen.</p>\n</blockquote>\n\n<p>Then:</p>\n\n<blockquote>\n  <p>One applicable method m1 is more specific than another applicable\n  method m2, for an invocation with argument expressions e1, ..., ek, if\n  any of the following are true:</p>\n  \n  <ol>\n  <li><p>m2 is generic, and m1 is inferred to be more specific than m2 for\n  argument expressions e1, ..., ek by §18.5.4.</p></li>\n  <li><p>m2 is not generic, and m1 and m2 are applicable by strict or loose\n  invocation, and where m1 has formal parameter types S1, ..., Sn and m2\n  has formal parameter types T1, ..., Tn, the type Si is more specific\n  than Ti for argument ei for all i (1 ≤ i ≤ n, n = k).</p></li>\n  <li><p>m2 is not generic, and m1 and m2 are applicable by variable arity\n  invocation, and where the first k variable arity parameter types of m1\n  are S1, ..., Sk and the first k variable arity parameter types of m2\n  are T1, ..., Tk, the type Si is more specific than Ti for argument ei\n  for all i (1 ≤ i ≤ k). Additionally, if m2 has k+1 parameters, then\n  the k+1'th variable arity parameter type of m1 is a subtype of the\n  k+1'th variable arity parameter type of m2.</p></li>\n  </ol>\n  \n  <p>The above conditions are the only circumstances under which one method may be more specific than another.</p>\n  \n  <p>A type S is more specific than a type T for any expression if S &lt;: T (§4.10).</p>\n</blockquote>\n\n<p>The second of three options matches our case. Since <code>String</code> is a subtype of <code>Object</code> (<code>String &lt;: Object</code>) it is more specific. Thus the method itself is <em>more specific</em>. Following the JLS this method is also <em>strictly more specific</em> and <em>most specific</em> and is chosen by the compiler.</p>\n    "},{"t":"Is iteration via Collections.synchronizedSet(…).forEach() guaranteed to be thread safe?","l":"http://stackoverflow.com/questions/23450227/is-iteration-via-collections-synchronizedset-foreach-guaranteed-to-be-thr","q":"\n\n<p>As we know, iterating over a concurrent collection is not thread safe by default, so one cannot use:</p>\n\n<pre><code>Set&lt;E&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());\n//fill with data\nfor (E e : set) {\n    process(e);\n}\n</code></pre>\n\n<p>This happens as data may be added during iteration, because there is no exclusive lock on <code>set</code>.</p>\n\n<p>This is describe in the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedSet-java.util.Set-\">javadoc</a> of <code>Collections.synchronizedSet</code>:</p>\n\n<blockquote>\n  <p>public static  Set synchronizedSet(Set s)</p>\n  \n  <p>Returns a synchronized (thread-safe) set backed by the specified set. In order to guarantee serial access, it is critical that all access to the backing set is accomplished through the returned set.</p>\n  \n  <p>It is imperative that the user manually synchronize on the returned set when iterating over it:</p>\n  \n  <p>Set s = Collections.synchronizedSet(new HashSet());<br>\n        ...<br>\n     <code>synchronized (s) {\n        Iterator i = s.iterator(); // Must be in the synchronized block\n        while (i.hasNext())\n            foo(i.next());\n  }</code>  </p>\n  \n  <p>Failure to follow this advice may result in non-deterministic behavior. </p>\n</blockquote>\n\n<p><strong>However</strong>, this does not apply to <code>Set.forEach</code>, which inherits the default method <code>forEach</code> from <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html#forEach-java.util.function.Consumer-\">Iterable.forEach</a>.</p>\n\n<p>Now I looked into the source code, and here we can see that we have the following structure:</p>\n\n<ol>\n<li>We ask for a <code>Collections.synchronizedSet()</code>.</li>\n<li><p>We get one:</p>\n\n<pre><code>public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) {\n    return new SynchronizedSet&lt;&gt;(s);\n}\n\n...\n\nstatic class SynchronizedSet&lt;E&gt;\n      extends SynchronizedCollection&lt;E&gt;\n      implements Set&lt;E&gt; {\n    private static final long serialVersionUID = 487447009682186044L;\n\n    SynchronizedSet(Set&lt;E&gt; s) {\n        super(s);\n    }\n    SynchronizedSet(Set&lt;E&gt; s, Object mutex) {\n        super(s, mutex);\n    }\n\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        synchronized (mutex) {return c.equals(o);}\n    }\n    public int hashCode() {\n        synchronized (mutex) {return c.hashCode();}\n    }\n}\n</code></pre></li>\n<li><p>It extends <code>SynchronizedCollection</code>, which has the following <em>interesting</em> methods next to the obvious ones:</p>\n\n<pre><code>// Override default methods in Collection\n@Override\npublic void forEach(Consumer&lt;? super E&gt; consumer) {\n    synchronized (mutex) {c.forEach(consumer);}\n}\n@Override\npublic boolean removeIf(Predicate&lt;? super E&gt; filter) {\n    synchronized (mutex) {return c.removeIf(filter);}\n}\n@Override\npublic Spliterator&lt;E&gt; spliterator() {\n    return c.spliterator(); // Must be manually synched by user!\n}\n@Override\npublic Stream&lt;E&gt; stream() {\n    return c.stream(); // Must be manually synched by user!\n}\n@Override\npublic Stream&lt;E&gt; parallelStream() {\n    return c.parallelStream(); // Must be manually synched by user!\n}\n</code></pre></li>\n</ol>\n\n<p>The <code>mutex</code> used here is the same object as to which <em>all</em> operations of <code>Collections.synchronizedSet</code> lock to.</p>\n\n<p>Now we can, judging by the <em>implementation</em> say that it is thread safe to use <code>Collections.synchronizedSet(...).forEach(...)</code>, but is it also thread safe <em>by specification</em>?</p>\n\n<p>(Confusingly enough, <code>Collections.synchronizedSet(...).stream().forEach(...)</code> is <em>not</em> thread safe by implementation, and the verdict of the specification seems to be unknown aswell.)</p>\n    ","a":"\n<p>As you wrote, judging by implementation, <code>forEach()</code> is thread-safe <strong>for the collections  provided with JDK</strong> (see disclaimer below) as it requires monitor of mutex to be acquired to proceed.</p>\n\n<blockquote>\n  <p>Is it also thread safe by specification?</p>\n</blockquote>\n\n<p>My opinion - no, and here is an explanation. <code>Collections.synchronizedXXX()</code> javadoc, rewritten in short words, says - \"all methods are thread-safe except for those used for iterating over it\".</p>\n\n<p>My other, although very subjective argument is what <em>yshavit</em> wrote - unless told/read that, consider API/class/whatever not thread-safe.</p>\n\n<p>Now, let's take a closer look at the javadocs. I guess I may state that method <code>forEach()</code> is used to iterate over it, so, following the advice from javadoc, we should consider it not thread-safe, although it is opposite to reality (implementation).</p>\n\n<p>Anyway, I agree with <em>yshavit</em>'s statement that the documentation should be updated as this is most likely a documentation, not implementation flaw. But, no one can say for sure except for JDK developers, see concerns below.</p>\n\n<p>The last point I'd like to mention within this discussion - we can assume that custom collection can be wrapped with <code>Collections.synchronizedXXX()</code>, and the implementation of <code>forEach()</code> of this collection can be... can be anything. The collection might perform asynchronous processing of elements within the <code>forEach()</code> method, spawn a thread for each element... it is bounded only by author's imagination, and <strong>synchronized(mutex) wrap cannot guarantee thread-safety for such cases</strong>. That particular issue might be the reason not to declare <code>forEach()</code> method as thread-safe..</p>\n    "},{"t":"What is the difference between a lambda and a method reference at a runtime level","l":"http://stackoverflow.com/questions/30514995/what-is-the-difference-between-a-lambda-and-a-method-reference-at-a-runtime-leve","q":"\n\n<p>I've experienced a problem that was happening using a method reference but not with lambdas. That code was the following :</p>\n\n<pre><code>(Comparator&lt;ObjectNode&gt; &amp; Serializable) SOME_COMPARATOR::compare\n</code></pre>\n\n<p>or, with lambda,</p>\n\n<pre><code>(Comparator&lt;ObjectNode&gt; &amp; Serializable) (a,b) -&gt; SOME_COMPARATOR.compare(a,b)\n</code></pre>\n\n<p>Semantically, it is strictly the same, but in practice it is different as in the first case I get an exception in one of the Java serialization classes. My question is not about this exception, because the actual code is running in a more complicated context that has proved to have strange behaviour with serialization, so it would just make it too difficult to answer if I gave any more details.</p>\n\n<p>What I want to understand is the difference between those two ways of creating a lambda expression</p>\n    ","a":"\n<h2>Getting Started</h2>\n\n<p>To investigate this we start with the following class:</p>\n\n<pre><code>import java.io.Serializable;\nimport java.util.Comparator;\n\npublic final class Generic {\n\n    // Bad implementation, only used as an example.\n    public static final Comparator&lt;Integer&gt; COMPARATOR = (a, b) -&gt; (a &gt; b) ? 1 : -1;\n\n    public static Comparator&lt;Integer&gt; reference() {\n        return (Comparator&lt;Integer&gt; &amp; Serializable) COMPARATOR::compare;\n    }\n\n    public static Comparator&lt;Integer&gt; explicit() {\n        return (Comparator&lt;Integer&gt; &amp; Serializable) (a, b) -&gt; COMPARATOR.compare(a, b);\n    }\n\n}\n</code></pre>\n\n<p>After compilation, we can disassemble it using:</p>\n\n<blockquote>\n  <p>javap -c -p -s -v Generic.class</p>\n</blockquote>\n\n<p>Removing the irrelevant parts (and some other clutter, such as fully-qualified types and the initialisation of <code>COMPARATOR</code>) we are left with</p>\n\n<pre><code>  public static final Comparator&lt;Integer&gt; COMPARATOR;    \n\n  public static Comparator&lt;Integer&gt; reference();\n      0: getstatic     #2  // Field COMPARATOR:LComparator;    \n      3: dup    \n      4: invokevirtual #3   // Method Object.getClass:()LClass;    \n      7: pop    \n      8: invokedynamic #4,  0  // InvokeDynamic #0:compare:(LComparator;)LComparator;    \n      13: checkcast     #5  // class Serializable    \n      16: checkcast     #6  // class Comparator    \n      19: areturn\n\n  public static Comparator&lt;Integer&gt; explicit();\n      0: invokedynamic #7,  0  // InvokeDynamic #1:compare:()LComparator;    \n      5: checkcast     #5  // class Serializable    \n      8: checkcast     #6  // class Comparator    \n      11: areturn\n\n  private static int lambda$explicit$d34e1a25$1(Integer, Integer);\n     0: getstatic     #2  // Field COMPARATOR:LComparator;\n     3: aload_0\n     4: aload_1\n     5: invokeinterface #44,  3  // InterfaceMethod Comparator.compare:(LObject;LObject;)I\n    10: ireturn\n\nBootstrapMethods:    \n  0: #61 invokestatic invoke/LambdaMetafactory.altMetafactory:(Linvoke/MethodHandles$Lookup;LString;Linvoke/MethodType;[LObject;)Linvoke/CallSite;    \n    Method arguments:    \n      #62 (LObject;LObject;)I    \n      #63 invokeinterface Comparator.compare:(LObject;LObject;)I    \n      #64 (LInteger;LInteger;)I    \n      #65 5    \n      #66 0    \n\n  1: #61 invokestatic invoke/LambdaMetafactory.altMetafactory:(Linvoke/MethodHandles$Lookup;LString;Linvoke/MethodType;[LObject;)Linvoke/CallSite;    \n    Method arguments:    \n      #62 (LObject;LObject;)I    \n      #70 invokestatic Generic.lambda$explicit$df5d232f$1:(LInteger;LInteger;)I    \n      #64 (LInteger;LInteger;)I    \n      #65 5    \n      #66 0\n</code></pre>\n\n<p>Immediately we see that the bytecode for the <code>reference()</code> method is different to the bytecode for <code>explicit()</code>. However, the notable difference <a href=\"http://www.benf.org/other/cfr/java8lambda_instancemethodref_getclass.html\">isn't actually relevant</a>, but the bootstrap methods are interesting.</p>\n\n<blockquote>\n  <p>An invokedynamic call site is linked to a method by means of a <em>bootstrap method</em>, which is a method specified by the compiler for the dynamically-typed language that is called once by the JVM to link the site. </p>\n</blockquote>\n\n<p>(<a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/vm/multiple-language-support.html#challenges\">Java Virtual Machine Support for Non-Java Languages</a>, emphasis theirs)</p>\n\n<p>This is the code responsible for creating the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html\">CallSite</a> used by the lambda. The <code>Method arguments</code> listed below each bootstrap method are the values passed as the variadic parameter (i.e. <code>args</code>) of <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html#altMetafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.Object...-\">LambdaMetaFactory#altMetaFactory</a>.</p>\n\n<h2>Format of the Method arguments</h2>\n\n<ol>\n<li>samMethodType - Signature and return type of method to be implemented by the function object.</li>\n<li>implMethod - A direct method handle describing the implementation method which should be called (with suitable adaptation of argument types, return types, and with captured arguments prepended to the invocation arguments) at invocation time.</li>\n<li>instantiatedMethodType - The signature and return type that should be enforced dynamically at invocation time. This may be the same as samMethodType, or may be a specialization of it.</li>\n<li>flags indicates additional options; this is a bitwise OR of desired flags. Defined flags are FLAG_BRIDGES, FLAG_MARKERS, and FLAG_SERIALIZABLE.</li>\n<li>bridgeCount is the number of additional method signatures the function object should implement, and is present if and only if the FLAG_BRIDGES flag is set.</li>\n</ol>\n\n<p>In both cases here <code>bridgeCount</code> is 0, and so there is no 6, which would otherwise be <code>bridges</code> - a variable-length list of additional methods signatures to implement (given that <code>bridgeCount</code> is 0, I'm not entirely sure why FLAG_BRIDGES is set).</p>\n\n<p>Matching the above up with our arguments, we get:</p>\n\n<ol>\n<li>The function signature and return type <code>(Ljava/lang/Object;Ljava/lang/Object;)I</code>, which is the return type of <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-\">Comparator#compare</a>, because of generic type erasure.</li>\n<li>The method being called when this lambda is invoked (which is different).</li>\n<li>The signature and return type of the lambda, which will be checked when the lambda is invoked: <code>(LInteger;LInteger;)I</code> (note that these aren't erased, because this is part of the lambda specification).</li>\n<li>The flags, which in both cases is the composition of <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html#FLAG_BRIDGES\">FLAG_BRIDGES</a> and <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html#FLAG_SERIALIZABLE\">FLAG_SERIALIZABLE</a> (i.e. 5).</li>\n<li>The amount of bridge method signatures, 0.</li>\n</ol>\n\n<p>We can see that FLAG_SERIALIZABLE is set for both lambdas, so it's not that.</p>\n\n<h2>Implementation methods</h2>\n\n<p>The implementation method for the method reference lambda is <code>Comparator.compare:(LObject;LObject;)I</code>, but for the explicit lambda it's <code>Generic.lambda$explicit$df5d232f$1:(LInteger;LInteger;)I</code>. Looking at the disassembly, we can see that the former is essentially an inlined version of the latter. The only other notable difference is the method parameter types (which, as mentioned earlier, is because of generic type erasure).</p>\n\n<h2>When is a lambda actually serializable?</h2>\n\n<blockquote>\n  <p>You can serialize a lambda expression if its target type and its captured arguments are serializable.</p>\n</blockquote>\n\n<p><a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#serialization\">Lambda Expressions (The Java™ Tutorials)</a></p>\n\n<p>The important part of that is \"captured arguments\". Looking back at the disassembled bytecode, the invokedynamic instruction for the method reference certainly looks like it's capturing a Comparator (<code>#0:compare:(LComparator;)LComparator;</code>, in contrast to the explicit lambda, <code>#1:compare:()LComparator;</code>).</p>\n\n<h2>Confirming capturing is the issue</h2>\n\n<p><code>ObjectOutputStream</code> contains an <code>extendedDebugInfo</code> field, which we can set using the <code>-Dsun.io.serialization.extendedDebugInfo=true</code> VM argument:</p>\n\n<blockquote>\n  <p>$ java -Dsun.io.serialization.extendedDebugInfo=true Generic</p>\n</blockquote>\n\n<p>When we try to serialize the lambdas again, this gives a very satisfactory</p>\n\n<pre><code>Exception in thread \"main\" java.io.NotSerializableException: Generic$$Lambda$1/321001045\n        - element of array (index: 0)\n        - array (class \"[LObject;\", size: 1)\n/* ! */ - field (class \"invoke.SerializedLambda\", name: \"capturedArgs\", type: \"class [LObject;\") // &lt;--- !!\n        - root object (class \"invoke.SerializedLambda\", SerializedLambda[capturingClass=class Generic, functionalInterfaceMethod=Comparator.compare:(LObject;LObject;)I, implementation=invokeInterface Comparator.compare:(LObject;LObject;)I, instantiatedMethodType=(LInteger;LInteger;)I, numCaptured=1])\n    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1182)\n    /* removed */\n    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)\n    at Generic.main(Generic.java:27)\n</code></pre>\n\n<h2>What's actually going on</h2>\n\n<p>From the above, we can see that the explicit lambda is <strong>not</strong> capturing anything, whereas the method reference lambda is. Looking over the bytecode again makes this clear:</p>\n\n<pre><code>  public static Comparator&lt;Integer&gt; explicit();\n      0: invokedynamic #7,  0  // InvokeDynamic #1:compare:()LComparator;    \n      5: checkcast     #5  // class java/io/Serializable    \n      8: checkcast     #6  // class Comparator    \n      11: areturn\n</code></pre>\n\n<p>Which, as seen above, has an implementation method of:</p>\n\n<pre><code>  private static int lambda$explicit$d34e1a25$1(java.lang.Integer, java.lang.Integer);\n     0: getstatic     #2  // Field COMPARATOR:Ljava/util/Comparator;\n     3: aload_0\n     4: aload_1\n     5: invokeinterface #44,  3  // InterfaceMethod java/util/Comparator.compare:(Ljava/lang/Object;Ljava/lang/Object;)I\n    10: ireturn\n</code></pre>\n\n<p>The explicit lambda is actually calling <code>lambda$explicit$d34e1a25$1</code>, which in turn calls the <code>COMPARATOR#compare</code>. This layer of indirection means it's not capturing anything that isn't <code>Serializable</code> (or anything at all, to be precise), and so is safe to serialize. The method reference expression <strong>directly</strong> uses <code>COMPARATOR</code> (the value of which is then passed to the bootstrap method):</p>\n\n<pre><code>  public static Comparator&lt;Integer&gt; reference();\n      0: getstatic     #2  // Field COMPARATOR:LComparator;    \n      3: dup    \n      4: invokevirtual #3   // Method Object.getClass:()LClass;    \n      7: pop    \n      8: invokedynamic #4,  0  // InvokeDynamic #0:compare:(LComparator;)LComparator;    \n      13: checkcast     #5  // class java/io/Serializable    \n      16: checkcast     #6  // class Comparator    \n      19: areturn\n</code></pre>\n\n<p>The lack of indirection means that <code>COMPARATOR</code> must be serialized along with the lambda. As <code>COMPARATOR</code> does not refer to a <code>Serializable</code> value, this fails.</p>\n\n<h2>The fix</h2>\n\n<p>I hesitate to call this a compiler bug (I expect the lack of indirection serves as an optimisation), although it is very strange. The fix is trivial, but ugly; adding the explicit cast for <code>COMPARATOR</code> at declaration:</p>\n\n<pre><code>public static final Comparator&lt;Integer&gt; COMPARATOR = (Serializable &amp; Comparator&lt;Integer&gt;) (a, b) -&gt; a &gt; b ? 1 : -1;\n</code></pre>\n\n<p>This makes everything perform correctly on Java 1.8.0_45. It's also worth noting that the eclipse compiler produces that layer of indirection in the method reference case as well, and so the original code in this post does not require modification to execute correctly.</p>\n    "},{"t":"Reference to method is ambiguous when using lambdas and generics","l":"http://stackoverflow.com/questions/29323520/reference-to-method-is-ambiguous-when-using-lambdas-and-generics","q":"\n\n<p>I am getting an error on the following code, which I believe should not be there... Using JDK 8u40 to compile this code.</p>\n\n<pre><code>public class Ambiguous {\n    public static void main(String[] args) {\n        consumerIntFunctionTest(data -&gt; {\n            Arrays.sort(data);\n        }, int[]::new);\n\n        consumerIntFunctionTest(Arrays::sort, int[]::new);\n    }\n\n    private static &lt;T&gt; void consumerIntFunctionTest(final Consumer&lt;T&gt; consumer, final IntFunction&lt;T&gt; generator) {\n\n    }\n\n    private static &lt;T&gt; void consumerIntFunctionTest(final Function&lt;T, ?&gt; consumer, final IntFunction&lt;T&gt; generator) {\n\n    }\n}\n</code></pre>\n\n<p>The error is the following:</p>\n\n<blockquote>\n  <p>Error:(17, 9) java: reference to consumerIntFunctionTest is ambiguous\n    both method consumerIntFunctionTest(java.util.function.Consumer,java.util.function.IntFunction) in net.tuis.ubench.Ambiguous and method consumerIntFunctionTest(java.util.function.Function,java.util.function.IntFunction) in net.tuis.ubench.Ambiguous match</p>\n</blockquote>\n\n<p>The error occurs on the following line:</p>\n\n<pre><code>consumerIntFunctionTest(Arrays::sort, int[]::new);\n</code></pre>\n\n<p>I believe there should be no error, as all <code>Arrays::sort</code> references are of type <code>void</code>, and none of them return a value. As you can observe, it <em>does</em> work when I explicitly expand the <code>Consumer&lt;T&gt;</code> lambda.</p>\n\n<p>Is this really a bug in javac, or does the JLS state that the lambda cannot automatically be expanded in this case? If it is the latter, I would still think it is weird, as <code>consumerIntFunctionTest</code> with as first argument <code>Function&lt;T, ?&gt;</code> should not match.</p>\n    ","a":"\n<p>In your first example</p>\n\n<pre><code>consumerIntFunctionTest(data -&gt; {\n        Arrays.sort(data);\n    }, int[]::new);\n</code></pre>\n\n<p>the lambda expression has a <code>void</code>-compatible block which can be identified by the structure of the expression without the need to resolve the actual types.</p>\n\n<p>In contrast, in the example</p>\n\n<pre><code>consumerIntFunctionTest(Arrays::sort, int[]::new);\n</code></pre>\n\n<p>the method reference has to be resolved to find out, whether it conforms to either, a <code>void</code> function (<code>Consumer</code>) or a value returning function (<code>Function</code>). The same applies to the simplified lambda expression</p>\n\n<pre><code>consumerIntFunctionTest(data -&gt; Arrays.sort(data), int[]::new);\n</code></pre>\n\n<p>which could be both, <code>void</code>- compatible or value- compatible, depending on the resolved target method.</p>\n\n<p>The problem is that resolving the method requires knowledge about the required signature, which ought to be determined via target typing, but the target type isn’t known until the type parameters of the generic method are known. While in theory both could be determined at once, the (still being awfully complex) process has been simplified in the specification in that method overload resolution is performed first and type inference is applied last (see <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2\" rel=\"nofollow\">JLS §15.12.2</a>). Hence, the information that type inference could provide cannot be used for solving overload resolution.</p>\n\n<p>But note that the first step described in <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.2\" rel=\"nofollow\">15.12.2.1. Identify Potentially Applicable Methods</a> contains:</p>\n\n<blockquote>\n  <p>An expression is <em>potentially compatible</em> with a target type according to the following rules:</p>\n  \n  <ul>\n  <li><p>A lambda expression (§15.27) is potentially compatible with a functional interface type (§9.8) if all of the following are true:</p>\n  \n  <ul>\n  <li><p>The arity of the target type's function type is the same as the arity of the lambda expression.</p></li>\n  <li><p>If the target type's function type has a void return, then the lambda body is either a statement expression (§14.8) or a void-compatible block (§15.27.2).</p></li>\n  <li><p>If the target type's function type has a (non-void) return type, then the lambda body is either an expression or a value-compatible block (§15.27.2).</p></li>\n  </ul></li>\n  <li><p>A method reference expression (§15.13) is potentially compatible with a functional interface type if, where the type's function type arity is n, there exists at least one potentially applicable method for the method reference expression with arity n (§15.13.1), and one of the following is true:</p>\n  \n  <ul>\n  <li><p>The method reference expression has the form ReferenceType :: [TypeArguments] Identifier and at least one potentially applicable method is i) static and supports arity n, or ii) not static and supports arity n-1.</p></li>\n  <li><p>The method reference expression has some other form and at least one potentially applicable method is not static.</p></li>\n  </ul></li>\n  </ul>\n  \n  <p>…</p>\n  \n  <p><sup><em>The definition of potential applicability goes beyond a basic arity check to also take into account the presence and \"shape\" of functional interface target types. In some cases involving type argument inference, a lambda expression appearing as a method invocation argument cannot be properly typed until after overload resolution</em>.</sup></p>\n</blockquote>\n\n<p>So your in first example one of the methods is sorted out by the lambda’s shape while in case of a method reference or a lambda expression consisting of a sole invocation expression, both potentially applicable methods endure this first selection process and yield an “ambiguous” error before type inference can kick in to aid finding a target method to determine if it’s a <code>void</code> or value returning method.</p>\n\n<p>Note that like using <code>x-&gt;{ foo(); }</code> to make a lambda expression explicitly <code>void</code>-compatible, you can use <code>x-&gt;( foo() )</code> to make a lambda expression explicitly value-compatible.</p>\n\n<hr>\n\n<p>You mad further read <a href=\"http://stackoverflow.com/a/21951311/2711488\">this answer</a> explaining that this limitation of combined type inference and method overload resolution was a deliberate (but not easy) decision.</p>\n    "},{"t":"How to add elements of a Java8 stream into an existing List","l":"http://stackoverflow.com/questions/22753755/how-to-add-elements-of-a-java8-stream-into-an-existing-list","q":"\n\n<p><a href=\"http://download.java.net/lambda/b88/docs/api/java/util/stream/Collector.html\">Javadoc of Collector</a> shows how to collect elements of a stream into a new List. Is there an one-liner that adds the results into an existing ArrayList?</p>\n    ","a":"\n<p><strong>The short answer</strong> is no (or should be no). <strong>EDIT:</strong> yeah, it's possible (see assylias' answer below), but keep reading. <strong>EDIT2:</strong> but see Stuart Marks' answer for yet another reason why you still shouldn't do it!</p>\n\n<p><strong>The longer answer:</strong></p>\n\n<p>The purpose of these constructs in Java 8 is to introduce some concepts of <a href=\"https://en.wikipedia.org/wiki/Functional_programming\" rel=\"nofollow\">Functional Programming</a> to the language; in Functional Programming, data structures are not typically modified, instead, new ones are created out of old ones by means of transformations such as map, filter, fold/reduce and many others.</p>\n\n<p>If you <em>must</em> modify the old list, simply collect the mapped items into a fresh list:</p>\n\n<pre><code>final List&lt;Integer&gt; newList = list.stream().filter(n -&gt; n % 2 == 0).collect(Collectors.toList());\n</code></pre>\n\n<p>and then do <code>list.addAll(newList)</code> —again: if you really must.</p>\n\n<p>(or construct a new list concatenating the old one and the new one, and assign it back to the <code>list</code> variable—this is a <em>little bit</em> more in the spirit of FP than <code>addAll</code>)</p>\n\n<p>As to the API: even though the API allows it (again, see assylias' answer) you should try to avoid doing that regardless, at least in general. It's best not to fight the paradigm (FP) and try to learn it rather than fight it (even though Java generally isn't a FP language), and only resort to \"dirtier\" tactics if absolutely needed.</p>\n\n<p><strong>The really long answer:</strong> (i.e. if you include the effort of actually finding and reading an FP intro/book as suggested)</p>\n\n<p>To find out why modifying existing lists is in general a bad idea and leads to less maintainable code—unless you're modifying a local variable and your algorithm is short and/or trivial, which is out of the scope of the question of code maintainability—find a good introduction to Functional Programming (there are hundreds) and start reading. A \"preview\" explanation would be something like: it's more mathematically sound and easier to reason about to not modify data (in most parts of your program) and leads to higher level and less technical (as well as more human friendly, once your brain transitions away from the old-style imperative thinking) definitions of program logic.</p>\n    "},{"t":"Double a stream","l":"http://stackoverflow.com/questions/30782985/double-a-stream","q":"\n\n<p>I want to double a <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\">Stream</a> (no <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/DoubleStream.html\">DoubleStream</a>). Meaning I start with a stream and want to get a new stream where each element of the old stream is streamed twice. So 1,2,3,4,4,5 gives us 1,1,2,2,3,3,4,4,4,4,5,5. Is there such a stream operation?</p>\n    ","a":"\n<p>Create an inner stream which will contain current element two times and <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-\">flatMap</a> this stream.</p>\n\n<pre><code>stream.flatMap(e -&gt; Stream.of(e,e))\n</code></pre>\n\n<p>If you want to multiply the number of elements by <code>n</code> you can create a utility method like this one: </p>\n\n<pre><code>public static &lt;T&gt; Stream&lt;T&gt; multiplyElements(Stream&lt;T&gt; in, int n) {\n    return in.flatMap(e -&gt; IntStream.range(0, n).mapToObj(i -&gt; e));\n    //  we can also use    IntStream.rangeClosed(1, n) \n    //  but I am used to iterating from 0 to n (excluding n)\n}\n</code></pre>\n\n<p>(but try to use a better name for this method, since the current one may be ambiguous)</p>\n\n<p>Usage example:</p>\n\n<pre><code>multiplyElements(Stream.of(1,2), 3).forEach(System.out::println);\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>1\n1\n1\n2\n2\n2\n</code></pre>\n    "},{"t":"Main method in interface","l":"http://stackoverflow.com/questions/26522205/main-method-in-interface","q":"\n\n<p>Why did interface allows to have <code>main</code> method in <code>Java 8</code>?</p>\n\n<p>As stated in below code it works fine and produces output properly.</p>\n\n<pre><code>public interface Temp {\n    public static void main(String args[]){\n         System.out.println(\"Hello\");\n    }\n}\n</code></pre>\n\n<p><strong><em>OUTPUT</em></strong> (<em>After running Temp.java</em>)</p>\n\n<pre><code>Hello\n</code></pre>\n\n<p><em>So what is the difference between main method of <code>interface</code> and <code>class</code>?</em> </p>\n\n<p>Currently it is behaving like a class and <strong><em>I</em></strong><em> have executed <code>interface</code> with main method</em>.</p>\n\n<p><em>Why do we need this?</em></p>\n\n<hr>\n\n<p><strong><em>EDIT</em></strong></p>\n\n<p>Adding more to the <em>existing question</em>,from the comment stated below <em>(By  Brian Goetz)</em></p>\n\n<blockquote>\n  <p>Should we have explicitly disallowed <code>main</code> methods now that <code>static</code>\n  methods are permissible in <code>interfaces</code> (or, equivalently, exclude\n  <code>'interface classes'</code> as targets for the java launcher.)</p>\n</blockquote>\n\n<hr>\n    ","a":"\n<p>Since Java 8, static methods are allowed in interfaces.</p>\n\n<p>main() is a static method.</p>\n\n<p>Hence, main() is allowed in interfaces.</p>\n\n<p>We don't <strong>need</strong> this, since it wasn't allowed before, and yet we survived. But since static methods, by definition, are not bound to an instance of a class, but to the class itself, it makes sense to allow them in interfaces. It allows defining utility methods related to an interface (like the ones found in <code>Collections</code>, for example), in the interface itself, rather than a separate class).</p>\n\n<p>There is no difference between class static methods and interface static methods.</p>\n    "},{"t":"Java 8 Lambda syntax","l":"http://stackoverflow.com/questions/6137033/java-8-lambda-syntax","q":"\n\n<p>Can any one please describe this sort of code to understand Java closure.</p>\n\n<pre><code>public static &lt;T&gt; void sort(List&lt;T&gt; l, final {T, T=&gt;Number} block) {\n\n    Collections.sort(l, new Comparator&lt;T&gt;() {\n        public int compare(T arg0, T arg1) {\n            return block.invoke(arg0, arg1);\n        }\n    }\n}\n</code></pre>\n    ","a":"\n<p><strong>Important note:</strong> The question was regarding an earlier <em>proposal</em>. This was not the syntax chosen. See this Q/A as a \"historical reference\".</p>\n\n<hr>\n\n<p>This syntax is described in the <a href=\"http://javac.info/\" rel=\"nofollow\">BGGA-proposal</a> by Gilad Bracha, Neal Gafter, James Gosling, and Peter von der Ahé.</p>\n\n<p>This snippet of code can be described as follows:</p>\n\n<ol>\n<li><p>It takes as the second argument a function taking parameters <code>(T, T)</code> and returning <code>Number</code> (and assigns it to parameter <code>block</code>)</p></li>\n<li><p>It then creates a <code>Comparator&lt;T&gt;</code> out of it. This it does by implementing the <code>compare</code> method by delegating it to a call to <code>block</code>.</p></li>\n<li><p>Passes this comparator to the <code>Collections.sort</code> method.</p></li>\n</ol>\n\n<hr>\n\n<p>Here comes a break down of the syntax:</p>\n\n<pre><code>public static &lt;T&gt; void sort(List&lt;T&gt; l, final {T, T=&gt;Number} block) {\n                                             ^^^^^^^^^^^^^^^^^^^^\n</code></pre>\n\n<p>An argument called <code>block</code> which is of type <em>\"function that takes two <code>T</code> and returns a <code>Number</code>\"</em>.</p>\n\n<pre><code>    Collections.sort(l, new Comparator&lt;T&gt;() {\n        public int compare(T arg0, T arg1) {\n            ...\n        }\n    }\n}\n</code></pre>\n\n<p>An ordinary call to <code>Collections.sort</code> with an instance of an anonymous subclass of <code>Comparator</code> as second argument...</p>\n\n<pre><code>        ...\n            return block.invoke(arg0, arg1);\n        ...\n</code></pre>\n\n<p>...which returns the number computed by the function defined by the <code>block</code> argument.</p>\n\n<hr>\n\n<p>Put in terms of classical Java, your snippet would correspond to something like</p>\n\n<pre><code>interface Block&lt;T&gt; {\n    public int invoke(T arg1, T arg2);\n}\n\n\nclass Test {\n    public static &lt;T&gt; void sort(List&lt;T&gt; l, final Block&lt;T&gt; block) {\n        Collections.sort(l, new Comparator&lt;T&gt;() {\n            public int compare(T arg0, T arg1) {\n                return block.invoke(arg0, arg1);\n            }\n        });\n    }\n}\n</code></pre>\n    "},{"t":"Using JavaFX in JRE 8","l":"http://stackoverflow.com/questions/22812488/using-javafx-in-jre-8","q":"\n\n<p>When trying to use javafx related classes in my new java 8 project I get an access restriction error from eclipse. So far the only 'solution' I've been able to find is to tell eclipse to ignore the access restriction, but I am not satisfied with that.\nAn example of the error: </p>\n\n<pre><code>Access restriction: The type Pane is not accessible due to \nrestriction on required library C:\\Program Files\\Java\\jre8_0\\lib\\ext\\jfxrt.jar\n</code></pre>\n\n<p>I'm using Eclipse Kepler with the Eclipse JDT patch for java 8.</p>\n\n<p>This seems to be an issue related to the fact that JavaFX is not a part of the JavaSE execution environment.</p>\n\n<p>I am now toughly confused as according to <a href=\"http://en.wikipedia.org/wiki/JavaFX\">http://en.wikipedia.org/wiki/JavaFX</a> javaFX is a part of the JavaSE. Is it possible that Eclipse is not recognizing that it is a part of the javaSE?</p>\n    ","a":"\n<p>From the Eclipse Point of view the error it totally correct because JavaFX is coming from the extension classpath and is not available on ALL Java8 VMs (e.g. ibm!).</p>\n\n<p>As outlined you can suppress those warnings by add access-rules or IMHO the best solution is to install e(fx)clipse which does this automatically for you and beside that even provides you tooling for JavaFX CSS and FXML.</p>\n\n<p>You can grab an all in one package from <a href=\"http://efxclipse.bestsolution.at/install.html\">http://efxclipse.bestsolution.at/install.html</a></p>\n    "},{"t":"Can you inspect the byte code of a Java 8 lambda at runtime?","l":"http://stackoverflow.com/questions/24579276/can-you-inspect-the-byte-code-of-a-java-8-lambda-at-runtime","q":"\n\n<p>If you have an anonymous class like</p>\n\n<pre><code>Predicate&lt;String&gt; isEmpty = new Predicate&lt;String&gt;() {\n    public boolean test(String t) {\n        return t.isEmpty();\n    }\n};\n</code></pre>\n\n<p>A library which is passed the reference to <code>isEmpty</code> can inspect the byte code to see what it does and possibly manipulate it.  Is there a way you can do this for lambdas?</p>\n\n<pre><code>Predicate&lt;String&gt; isEmpty = String::isEmpty;\n</code></pre>\n\n<p>e.g Say have this code and byte code</p>\n\n<pre><code>public class Main {\n    public static void test(Predicate&lt;String&gt; tester) {\n        System.out.println(\"tester.getClass()= \" + tester.getClass());\n        System.out.println(\"tester.getClass().getClassLoader()=\"+ tester.getClass().getClassLoader());\n    }\n    public static void main(String... args) {\n        Predicate&lt;String&gt; isEmpty = String::isEmpty;\n        test(isEmpty);\n    }\n}\n\n$ javap -cp . -c -private Main.class\nCompiled from \"Main.java\"\npublic class Main {\n  public Main();\n    Code:\n       0: aload_0       \n       1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V\n       4: return        \n\n  public static void test(java.util.function.Predicate&lt;java.lang.String&gt;);\n    Code:\n       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: new           #3                  // class java/lang/StringBuilder\n       6: dup           \n       7: invokespecial #4                  // Method java/lang/StringBuilder.\"&lt;init&gt;\":()V\n      10: ldc           #5                  // String tester.getClass()= \n      12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n      15: aload_0       \n      16: invokevirtual #7                  // Method java/lang/Object.getClass:()Ljava/lang/Class;\n      19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;\n      22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n      25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      28: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      31: new           #3                  // class java/lang/StringBuilder\n      34: dup           \n      35: invokespecial #4                  // Method java/lang/StringBuilder.\"&lt;init&gt;\":()V\n      38: ldc           #11                 // String tester.getClass().getClassLoader()=\n      40: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n      43: aload_0       \n      44: invokevirtual #7                  // Method java/lang/Object.getClass:()Ljava/lang/Class;\n      47: invokevirtual #12                 // Method java/lang/Class.getClassLoader:()Ljava/lang/ClassLoader;\n      50: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;\n      53: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n      56: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      59: return        \n\n  public static void main(java.lang.String...);\n    Code:\n       0: invokedynamic #13,  0             // InvokeDynamic #0:test:()Ljava/util/function/Predicate;\n       5: astore_1      \n       6: aload_1       \n       7: invokestatic  #14                 // Method test:(Ljava/util/function/Predicate;)V\n      10: return        \n}\n</code></pre>\n\n<p>With a reference to <code>tester</code> in <code>test</code> how do I find which method is called?</p>\n    ","a":"\n<p>If you just want to SEE the bytecode:</p>\n\n<pre><code>javap -c -p -v classfile\n      ^disassemble\n         ^private methods\n            ^verbose, including constant pool and bootstrap methods attribute\n</code></pre>\n\n<p>But if you want to try to do this at runtime, you're pretty much out of luck (by design, we don't have anything like Expression Trees), as the other answer suggests.</p>\n    "},{"t":"Java 8 needs a cast while Java 7 didn't - enum.getClass/getDeclaringClass","l":"http://stackoverflow.com/questions/21640002/java-8-needs-a-cast-while-java-7-didnt-enum-getclass-getdeclaringclass","q":"\n\n<p>I realise Java 8 is still in Beta but this one struck me as odd:</p>\n\n<pre><code>public class Fields&lt;C extends Enum&lt;C&gt;&gt; {\n\n    public Fields(Set&lt;C&gt; columns) {\n        // A sample column used to find the universe of the enum of Columns.\n        C sampleCol = columns.iterator().next();\n        // Java 8 needs a cast here.\n        Set&lt;C&gt; allColumns = EnumSet.allOf((/*Class&lt;C&gt;)*/ sampleCol.getClass());\n        // ... there's more to this that I've deleted.\n    }\n\n}\n</code></pre>\n\n<p>The error reads:</p>\n\n<pre><code>error: incompatible types: inferred type does not conform to equality constraint(s)\n            Set&lt;C&gt; allColumns = EnumSet.allOf(sampleCol.getClass());\n    inferred: C\n    equality constraints(s): C,CAP#1\n  where C is a type-variable:\n    C extends Enum&lt;C&gt; declared in class Test.Fields\n  where CAP#1 is a fresh type-variable:\n    CAP#1 extends Enum from capture of ? extends Enum\n</code></pre>\n\n<p>Is this a bug or a new feature of Java 8?</p>\n    ","a":"\n<p>Interesting, this is a subtle change in the treatment of <a href=\"http://stackoverflow.com/questions/2770321/what-is-a-raw-type-and-why-shouldnt-we-use-it\">raw types</a>.</p>\n\n<p>First, let's clarify your example. The return type of <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#getClass%28%29\"><code>Object.getClass</code></a> is special:</p>\n\n<blockquote>\n  <p>The actual result type is <code>Class&lt;? extends |X|&gt;</code> where <code>|X|</code> is the erasure of the static type of the expression on which <code>getClass</code> is called.</p>\n</blockquote>\n\n<p>In this case, <code>X</code> would be the type parameter <code>C</code>, which <a href=\"http://docs.oracle.com/javase/tutorial/java/generics/erasure.html\">erases</a> to <code>Enum</code>. So <code>sampleCol.getClass()</code> returns <code>Class&lt;? extends Enum&gt;</code>. <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html#allOf%28java.lang.Class%29\"><code>EnumSet.allOf</code></a> declares the type parameter <code>E extends Enum&lt;E&gt;</code>, and in your case <code>? extends Enum</code> is being inferred as its type argument.</p>\n\n<p>The important part is that <code>Enum</code> is a raw type. The use of raw types has been seen to erase seemingly unrelated generics, for example on this post: <a href=\"http://stackoverflow.com/questions/662191/why-wont-this-generic-java-code-compile\">Why won't this generic java code compile?</a> In his answer there, Jon Skeet cites <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.8\">JLS §4.8</a> (\"Raw Types\") to cover this unintuitive behavior.</p>\n\n<p>Similar behavior seems to be happening in your example with Java 7: <code>EnumSet.allOf(sampleCol.getClass())</code> is allowed to compile with an \"unchecked invocation\" warning (this gets hidden by the subsequent \"unchecked conversion\" warning from assigning the resulting raw <code>EnumSet</code> to <code>Set&lt;C&gt;</code>).</p>\n\n<p>The question becomes: should the occurrence of a raw type in a generic wildcard's bounds allow unchecked conversions? JLS §4.8 makes no mention of this, so it's ambiguous. Possibly it's a bug, but it seems like a reasonable tightening of this behavior. While a standard raw type like <code>Enum</code> might itself be expected from legacy APIs, a \"half-baked\" type like <code>Class&lt;? extends Enum&gt;</code> could only occur post-generics and so it doesn't really make sense to let it disrupt generic type checking.</p>\n\n<p>Anyway I'm interested to see if anyone can point to documentation about this change - my search didn't turn anything up.</p>\n\n<hr>\n\n<p><strong>About your specific code:</strong> you should use <a href=\"http://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#getDeclaringClass%28%29\"><code>getDeclaringClass()</code></a> instead. The compiler can't know that calling <code>getClass</code> on a <code>C</code> will return exactly <code>Class&lt;C&gt;</code>; in fact, it won't if used on an enum with a constant-specific class. This is exactly the use case for which <code>Enum</code> declares that method. </p>\n    "},{"t":"ClassCast error: Java 7 vs Java 8","l":"http://stackoverflow.com/questions/23155907/classcast-error-java-7-vs-java-8","q":"\n\n<p>Is this a bug or feature? The following code runs fine in Java 7 but throws an exception in Java 8: </p>\n\n<p>The last command throws a ClassCast exception in Java8, all the \"equivalent\" commands above work the same way.</p>\n\n<p>The problem, I think, is that in Java 8, the compiler decides to use <code>String.value(char[])</code> on the last line instead of <code>String.value(Object)</code> as in Java 7. I would think this should behave the same way for backward compatibility. Am I missing something?</p>\n\n<p>Note: As Marko suggested this is probably related to target type inference introduced in Java 8. </p>\n\n<pre><code>public class Test {\n    public static void main(String[] args) {\n        System.out.println( getVal().getClass());  // String\n\n        System.out.println( String.valueOf(Test.&lt;Object&gt;getVal()) );   // \"abc\"\n\n        Object obj = getVal();\n        System.out.println( String.valueOf(obj) );  // \"abc\"\n\n        System.out.println( String.valueOf(getVal()) ); // 7: \"abc\", 8: Exception \n    }\n\n    // returns a string for simplicity; imagine that given a field, it fetches values from a database\n    @SuppressWarnings(\"unchecked\")\n    public static &lt;T&gt; T getVal() {\n        return (T) \"abc\";\n    }\n}\n</code></pre>\n\n<p>Result in Java 7:</p>\n\n<pre><code>class java.lang.String\nabc\nabc\nabc\n</code></pre>\n\n<p>Result in Java 8:</p>\n\n<pre><code>class java.lang.String\nabc\nabc\nException in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to [C\n    at Test.main(Test.java:11)\n</code></pre>\n\n<p>(Note: [C is an array of chars)</p>\n\n<p>Both Java's are on windows:</p>\n\n<pre><code>java version \"1.7.0_45\"\nJava(TM) SE Runtime Environment (build 1.7.0_45-b18)\nJava HotSpot(TM) Client VM (build 24.45-b08, mixed mode, sharing)\n\njava version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n</code></pre>\n    ","a":"\n<p><code>String.valueOf</code> is a heavily overloaded method and you are using it in a context where the argument type must be inferred from the context. On the other hand, the rules of type inference have received a significant overhaul in Java 8; most notably <em>target type inference</em> has been much improved. So, whereas before Java 8 the method argument site did not receive any inference, defaulting to <code>Object</code> in your case, in Java 8 the most specific applicable type was inferred, in this case <code>char[]</code>.</p>\n\n<p>However, keep in mind that in both cases the idiom you used is essentially broken so the change in compiler output should perhaps be designated as a \"pitfall\", but not a \"bug\". </p>\n\n<p>The unchecked cast is unfortunately sometimes unavoidable, but I can't think of any case where it makes sense to infer the type itself (as opposed to a type parameter) of something which is not created reflectively from a <code>Class</code> object. Therefore you are not likely to actually find yourself in the position shown here, where you infer the type based on the acceptable argument types on the call site. Moreover, it is certainly broken to do this with an overloaded method, leaving the choice of argument type to inference. This can only work \"by accident\".</p>\n    "},{"t":"Are Project Coin's collection enhancements going to be in JDK8? [closed]","l":"http://stackoverflow.com/questions/13692213/are-project-coins-collection-enhancements-going-to-be-in-jdk8","q":"\n\n<p>Initially <a href=\"http://openjdk.java.net/projects/coin/\">Project Coin</a> had <a href=\"http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html\">enhanced support for collections</a> e.g. <code>list[3]</code> instead of <code>list.get(3)</code> and <code>map[\"hello\"] = 27</code> instead of <code>map.put(\"hello\", 27)</code> but they were <a href=\"https://blogs.oracle.com/darcy/entry/project_coin_javaone_2010\">not in jdk7</a>. Are they going to be in jdk8? I could not find a definitive answer for either yes or no.</p>\n    ","a":"\n<p>Brian Goetz briefly mentions list, set, map (and other possible) literals in this post in the Project Lambda mailing list from 30th May:</p>\n\n<p><a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-May/004979.html\">http://mail.openjdk.java.net/pipermail/lambda-dev/2012-May/004979.html</a></p>\n\n<blockquote>\n  <p>To illustrate what I mean by \"we could do better\", here's an alternative \n  proposal that gets far more mileage out of #: structured literals. \n  While these plans are not in place for 8, we have already stated our \n  desire to add structured literals for lists, maps, sets, etc.  # as a \n  prefix symbol, combined with delimiters, gives us a far higher \n  return-on-syntax as a structured literal builder (as a bonus, # is \n  already associated with structured literals in a lot of languages, going \n  all the way back to many early assembly languages where # was the \n  immediate addressing mode.)</p>\n</blockquote>\n\n<p>So to me it seems that even the collection literals won't make it into JDK 8, let alone the get/set/put operators. It's a pity.</p>\n\n<p>Also I do not see anything relating to collection literals or new operators in the list of JDK 8 milestones:</p>\n\n<p><a href=\"http://openjdk.java.net/projects/jdk8/milestones\">http://openjdk.java.net/projects/jdk8/milestones</a></p>\n    "},{"t":"Is Java 8 missing an OptionalBoolean?","l":"http://stackoverflow.com/questions/23922134/is-java-8-missing-an-optionalboolean","q":"\n\n<p>As a primitive version of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html\"><code>Optional</code></a>*, Java 1.8 provides <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/OptionalInt.html\"><code>OptionalInt</code></a>, <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/OptionalLong.html\"><code>OptionalLong</code></a> and <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/OptionalDouble.html\"><code>OptionalDouble</code></a>.</p>\n\n<p>But I cannot find the equivalent <code>OptionalBoolean</code> class.</p>\n\n<p>Are there any technical reasons against having an <code>OptionalBoolean</code>?</p>\n\n<p>*\n<em>An <code>Optional</code> may or may not have the presence of a value, is used as an alternative to <code>null</code>.</em></p>\n    ","a":"\n<p>This quote explains the considerations behind having primitive streams. I'm assuming the same applied to primitive Optionals. In short, primitive streams (and probably Optionals as well) were created for performance reasons. They didn't create them for all 8 primitive types to reduce code duplication and interface pollution.</p>\n\n<p>Quoting the words of Brian Goetz in the <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-November/006750.html\">lambda mailing list</a>:</p>\n\n<blockquote>\n  <p>More generally: the philosophy behind having specialized\n  primitive streams (e.g., IntStream) is fraught with nasty tradeoffs.\n  On the one hand, it's lots of ugly code duplication, interface\n  pollution, etc. On the other hand, any kind of arithmetic on boxed ops\n  sucks, and having no story for reducing over ints would be terrible.\n  So we're in a tough corner, and we're trying to not make it worse.</p>\n  \n  <p>Trick #1 for not making it worse is: we're not doing all eight\n  primitive types. We're doing int, long, and double; all the others\n  could be simulated by these. Arguably we could get rid of int too, but\n  we don't think most Java developers are ready for that. Yes, there\n  will be calls for Character, and the answer is \"stick it in an int.\"\n  (Each specialization is projected to ~100K to the JRE footprint.)</p>\n  \n  <p>Trick #2 is: we're using primitive streams to expose things that are best done in the primitive domain (sorting, reduction) but not\n  trying to duplicate everything you can do in the boxed domain. For\n  example, there's no IntStream.into(), as Aleksey points out. (If there\n  were, the next question(s) would be \"Where is IntCollection?\n  IntArrayList? IntConcurrentSkipListMap?) The intention is many streams\n  may start as reference streams and end up as primitive streams, but\n  not vice versa. That's OK, and that reduces the number of conversions\n  needed (e.g., no overload of map for int -&gt; T, no specialization of\n  Function for int -&gt; T, etc.) </p>\n</blockquote>\n\n<p>And I should mention that I found that quote in the answer to <a href=\"http://stackoverflow.com/questions/22918847/why-are-new-java-util-arrays-methods-in-java-8-not-overloaded-for-all-the-primit\">this question</a>.</p>\n    "},{"t":"Stream.skip behavior with unordered terminal operation","l":"http://stackoverflow.com/questions/30843279/stream-skip-behavior-with-unordered-terminal-operation","q":"\n\n<p>I've already read <a href=\"http://stackoverflow.com/q/28259636/4856258\">this</a> and <a href=\"http://stackoverflow.com/q/28521382/4856258\">this</a> questions, but still doubt whether the observed behavior of <code>Stream.skip</code> was intended by JDK authors.</p>\n\n<p>Let's have simple input of numbers 1..20:</p>\n\n<pre><code>List&lt;Integer&gt; input = IntStream.rangeClosed(1, 20).boxed().collect(Collectors.toList());\n</code></pre>\n\n<p>Now let's create a parallel stream, combine the <code>unordered()</code> with <code>skip()</code> in different ways and collect the result:</p>\n\n<pre><code>System.out.println(\"skip-skip-unordered-toList: \"\n        + input.parallelStream().filter(x -&gt; x &gt; 0)\n            .skip(1)\n            .skip(1)\n            .unordered()\n            .collect(Collectors.toList()));\nSystem.out.println(\"skip-unordered-skip-toList: \"\n        + input.parallelStream().filter(x -&gt; x &gt; 0)\n            .skip(1)\n            .unordered()\n            .skip(1)\n            .collect(Collectors.toList()));\nSystem.out.println(\"unordered-skip-skip-toList: \"\n        + input.parallelStream().filter(x -&gt; x &gt; 0)\n            .unordered()\n            .skip(1)\n            .skip(1)\n            .collect(Collectors.toList()));\n</code></pre>\n\n<p>Filtering step does essentially nothing here, but adds more difficulty for stream engine: now it does not know the exact size of the output, thus some optimizations are turned off. I have the following results:</p>\n\n<pre><code>skip-skip-unordered-toList: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n// absent values: 1, 2\nskip-unordered-skip-toList: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20]\n// absent values: 1, 15\nunordered-skip-skip-toList: [1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20]\n// absent values: 7, 18\n</code></pre>\n\n<p>The results are completely fine, everything works as expected. In the first case I asked to skip first two elements, then collect to list in no particular order. In the second case I asked to skip the first element, then turn into unordered and skip one more element (I don't care which one). In the third case I turned into unordered more first, then skip two arbitrary elements.</p>\n\n<p>Let's skip one element and collect to the custom collection in unordered mode. Our custom collection will be a <code>HashSet</code>:</p>\n\n<pre><code>System.out.println(\"skip-toCollection: \"\n        + input.parallelStream().filter(x -&gt; x &gt; 0)\n        .skip(1)\n        .unordered()\n        .collect(Collectors.toCollection(HashSet::new)));\n</code></pre>\n\n<p>The output is satisfactory:</p>\n\n<pre><code>skip-toCollection: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n// 1 is skipped\n</code></pre>\n\n<p>So in general I expect that as long as stream is ordered, <code>skip()</code> skips the first elements, otherwise it skips arbitrary ones.</p>\n\n<p>However let's use an equivalent unordered terminal operation <code>collect(Collectors.toSet())</code>:</p>\n\n<pre><code>System.out.println(\"skip-toSet: \"\n        + input.parallelStream().filter(x -&gt; x &gt; 0)\n            .skip(1)\n            .unordered()\n            .collect(Collectors.toSet()));\n</code></pre>\n\n<p>Now the output is:</p>\n\n<pre><code>skip-toSet: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20]\n// 13 is skipped\n</code></pre>\n\n<p>The same result can be achieved with any other unordered terminal operation (like <code>forEach</code>, <code>findAny</code>, <code>anyMatch</code>, etc.). Removing <code>unordered()</code> step in this case changes nothing. Seems that while <code>unordered()</code> step correctly makes the stream unordered starting from the current operation, the unordered terminal operation makes the whole stream unordered starting from very beginning despite that this can affect the result if <code>skip()</code> was used. This seems completely misleading for me: I expect that using the unordered collector is the same as turning the stream into unordered mode <em>just before the terminal operation</em> and using the equivalent ordered collector.</p>\n\n<p>So my questions are:</p>\n\n<ol>\n<li>Is this behavior intended or it's a bug?</li>\n<li>If yes is it documented somewhere? I've read <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#skip-long-\">Stream.skip()</a> documentation: it does not say anything about unordered terminal operations. Also <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#UNORDERED\">Characteristics.UNORDERED</a> documentation is not very comprehend and does not say that ordering will be lost for the whole stream. Finally, <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Ordering\">Ordering</a> section in package summary does not cover this case either. Probably I'm missing something?</li>\n<li>If it's intended that unordered terminal operation makes the whole stream unordered, why <code>unordered()</code> step makes it unordered only since this point? Can I rely on this behavior? Or I was just lucky that my first tests work nicely?</li>\n</ol>\n    ","a":"\n<p>Recall that the goal of stream flags (ORDERED, SORTED, SIZED, DISTINCT) is to enable operations to avoid doing unnecessary work.  Examples of optimizations that involve stream flags are:</p>\n\n<ul>\n<li>If we know the stream is already sorted, then <code>sorted()</code> is a no-op;</li>\n<li>If we know the size of the stream, we can pre-allocate a correct-sized array in <code>toArray()</code>, avoiding a copy;</li>\n<li>If we know that the input has no meaningful encounter order, we need not take extra steps to preserve encounter order.</li>\n</ul>\n\n<p>Each stage of a pipeline has a set of stream flags.  Intermediate operations can inject, preserve, or clear stream flags.  For example, filtering preserves sorted-ness / distinct-ness but not sized-ness; mapping preserves sized-ness but not sorted-ness or distinct-ness.  Sorting injects sorted-ness.  The treatment of flags for intermediate operations is fairly straightforward, because all decisions are local.  </p>\n\n<p>The treatment of flags for terminal operations is more subtle.  ORDERED is the most relevant flag for terminal ops.  And if a terminal op is UNORDERED, then we do back-propagate the unordered-ness.  </p>\n\n<p>Why do we do this?  Well, consider this pipeline:</p>\n\n<pre><code>set.stream()\n   .sorted()\n   .forEach(System.out::println);\n</code></pre>\n\n<p>Since <code>forEach</code> is not constrained to operate in order, the work of sorting the list is completely wasted effort.  So we back-propagate this information (until we hit a short-circuiting operation, such as <code>limit</code>), so as not to lose this optimization opportunity.  Similarly, we can use an optimized implementation of <code>distinct</code> on unordered streams.  </p>\n\n<blockquote>\n  <p>Is this behavior intended or it's a bug?</p>\n</blockquote>\n\n<p>Yes :)  The back-propagation is intended, as it is a useful optimization that should not produce incorrect results.  However, the bug part is that we are propagating past a previous <code>skip</code>, which we shouldn't.  So the back-propagation of the UNORDERED flag is overly aggressive, and that's a bug.  We'll post a bug.</p>\n\n<blockquote>\n  <p>If yes is it documented somewhere? </p>\n</blockquote>\n\n<p>It should be just an implementation detail; if it were correctly implemented, you wouldn't notice (except that your streams are faster.)</p>\n    "},{"t":"How to use the unsigned integer in java 8?","l":"http://stackoverflow.com/questions/25556017/how-to-use-the-unsigned-integer-in-java-8","q":"\n\n<p>In the oracle \"Primitive data types\" page, it mentions that java 8 adds support for unsinged ints and longs: </p>\n\n<blockquote>\n  <p>int: By default, the int data type is a 32-bit signed two's complement integer, which has a minimum value of -2^31 and a maximum value of 2^31-1. <strong>In Java SE 8 and later, you can use the int data type to represent an unsigned 32-bit integer, which has a minimum value of 0 and a maximum value of 2^32-1.</strong> Use the Integer class to use int data type as an unsigned integer. See the section The Number Classes for more information. Static methods like compareUnsigned, divideUnsigned etc have been added to the Integer class to support the arithmetic operations for unsigned integers.</p>\n  \n  <p>long: The long data type is a 64-bit two's complement integer. The signed long has a minimum value of -2^63 and a maximum value of 2^63-1. <strong>In Java SE 8 and later, you can use the long data type to represent an unsigned 64-bit long, which has a minimum value of 0 and a maximum value of 2^64-1.</strong> Use this data type when you need a range of values wider than those provided by int. The Long class also contains methods like compareUnsigned, divideUnsigned etc to support arithmetic operations for unsigned long.</p>\n</blockquote>\n\n<p>However, I find no way to declare an unsigned long or integer. The following code, for example, gives an \"the literal is out of range\" error (I'm using java 8, of course), when it should be in range (the value assigned is precisely 2^64-1):</p>\n\n<pre><code>public class Foo {\n    static long values = 18446744073709551615L;\n\n    public static void main(String[] args){\n        System.out.println(values);\n    }  \n}\n</code></pre>\n\n<p>So, is there any way to declare an unsigned int or long?</p>\n    ","a":"\n<p>Per the documentation you posted, and <a href=\"https://blogs.oracle.com/darcy/entry/unsigned_api\">this blog post</a> - there's no difference when declaring the primitive between an unsigned int/long and a signed one.  The \"new support\" is the addition of the static methods in the Integer and Long classes, e.g. <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#divideUnsigned-int-int-\">Integer.divideUnsigned</a>.  If you're not using those methods, your \"unsigned\" long above 2^63-1 is just a plain old long with a negative value.</p>\n\n<p>From a quick skim, it doesn't look like there's a way to declare integer constants in the range outside of +/- 2^31-1, or +/- 2^63-1 for longs.  You would have to manually compute the negative value corresponding to your out-of-range positive value.</p>\n    "},{"t":"Why did Java 8 introduce a new “::” operator for method references?","l":"http://stackoverflow.com/questions/26590453/why-did-java-8-introduce-a-new-operator-for-method-references","q":"\n\n<p>In Java 8 method references are done using the <code>::</code> operator. </p>\n\n<p><strong>For Example</strong></p>\n\n<pre><code>// Class that provides the functionality via it's static method\npublic class AddableUtil {\n  public static int addThemUp(int i1, int i2){\n    return i1+i2;\n  }\n}\n\n// Test class\npublic class AddableTest {\n  // Lambda expression using static method on a separate class\n  IAddable addableViaMethodReference = AddableUtil::addThemUp;\n  ...\n}\n</code></pre>\n\n<p>You can see that the <code>addableViaMethodReference</code> now acts like an alias to <code>AddableUtil::addThemUp</code>. So <code>addableViaMethodReference()</code> will perform the same action as  <code>AddableUtil.addThemUp()</code> and return the same value.</p>\n\n<p>Why did they choose to introduce a new operator instead of using an existing one ? I mean, execute a function when the function name ends with <code>()</code> and return the function reference when there is no trailing <code>()</code>.</p>\n\n<p><strong>Method Execution</strong></p>\n\n<pre><code>AddableUtil.addThemUp();\n</code></pre>\n\n<p><strong>Method reference</strong></p>\n\n<pre><code>AddableUtil.addThemUp;\n</code></pre>\n\n<p>Wouldn't this be much simpler and intuitive ? AFAIK, <code>AddableUtil.addThemUp</code> doesn't currently (Java 7) serve any other purpose and throws a compilation error. Why not use that opportunity instead of creating an entirely new operator ?</p>\n    ","a":"\n<p>The following piece of code compiles fine in Java 8, but would be ambiguous without a new operator:</p>\n\n<pre><code>import java.util.function.IntBinaryOperator;\n\npublic class A {\n\n  public static IntBinaryOperator addThemUp;\n\n  public static int addThemUp(int i1, int i2) {\n    return i1 + i2;\n  }\n\n  public static void main(String[] args) throws Exception {\n    IntBinaryOperator operator = A::addThemUp;\n  }\n}\n</code></pre>\n\n<p>It wouldn't be clear whether <code>A.addThemUp</code> refers to the public <code>IntBinaryOperator</code> field or is an attempt to create a method reference.</p>\n\n<p><em>Yes, it's a bit contrived. But you can't allow edge cases in programming language syntax</em>.</p>\n    "},{"t":"Anonymous class replaced with lambda expressions","l":"http://stackoverflow.com/questions/20287581/anonymous-class-replaced-with-lambda-expressions","q":"\n\n<p>I have sample code which uses Java 8 new <a href=\"http://download.java.net/jdk8/docs/api/java/util/stream/package-summary.html\">stream functionality</a> (get a range of int values 1 .. 20, skip the first 9, then take remaining 10, each int value: reduce by one and multiply by 2).\n</p>\n\n<pre><code>System.out.println(Arrays.toString(\n    IntStream.rangeClosed(1, 20).skip(9).limit(10).map((new IntUnaryOperator() {\n        @Override\n        public int applyAsInt(int operand) {\n            return operand - 1;\n        }\n    }).andThen(new IntUnaryOperator() {\n        @Override\n        public int applyAsInt(int operand) {\n            return operand * 2;\n        }\n    })).toArray()));\n</code></pre>\n\n<p>The output is as follows:</p>\n\n<pre><code>[18, 20, 22, 24, 26, 28, 30, 32, 34, 36]\n</code></pre>\n\n<p>Now I want to replace anonymous classes with <a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\">Lambda expressions</a>. The following conversion works fine (the second anonymous class replaced with <code>i -&gt; i * 2</code> lambda expression) and I get the same output:\n</p>\n\n<pre><code>System.out.println(Arrays.toString(\n    IntStream.rangeClosed(1, 20).skip(9).limit(10).map((new IntUnaryOperator() {\n        @Override\n        public int applyAsInt(int operand) {\n            return operand - 1;\n        }\n    }).andThen(i -&gt; i * 2)).toArray()));\n</code></pre>\n\n<p>However, when I replace the first anonymous class with lambda expression:\n</p>\n\n<pre><code>System.out.println(\n    Arrays.toString(\n        IntStream.rangeClosed(1, 20).skip(9).limit(10)\n            .map((v -&gt; v - 1).andThen(i -&gt; i * 2)).toArray()));\n</code></pre>\n\n<p>I am not able to compile my code. The error says <code>Operator '-' cannot be applied to '&lt;lambda parameter&gt;', 'int'</code></p>\n\n<p><img src=\"http://i.stack.imgur.com/EtHsI.png\" alt=\"Compilation error\"></p>\n\n<p>Do you know how to combine two lambda expressions with <code>IntUnaryOperator.andThen</code>?</p>\n\n<p>I know I could use ... <code>.limit(10).map(v -&gt; v - 1).map(i -&gt; i * 2).toArray() ...</code> which works fine but I would like to find out how to use <code>IntUnaryOperator.andThen</code> with lambdas (if that possible).</p>\n    ","a":"\n<p>You have to explicitly cast the first lambda expression to IntUnaryOperator. The following code works:</p>\n\n<pre><code>System.out.println(\n        Arrays.toString(\n                IntStream.rangeClosed(1, 20).skip(9).limit(10)\n                        .map(((IntUnaryOperator) v -&gt; v - 1).andThen(i -&gt; i * 2)).toArray()));\n</code></pre>\n    "},{"t":"Why use Optional.of over Optional.ofNullable?","l":"http://stackoverflow.com/questions/31696485/why-use-optional-of-over-optional-ofnullable","q":"\n\n<p>When using the Java 8 <code>Optional</code> class, there are two ways in which a value can be wrapped in an optional.</p>\n\n<pre><code>String foobar = &lt;value or null&gt;;\nOptional.of(foobar);         // May throw NullPointerException\nOptional.ofNullable(foobar); // Safe from NullPointerException\n</code></pre>\n\n<p>I understand <code>Optional.ofNullable</code> the only safe way of using using <code>Optional</code>, but why does <code>Optional.of</code> exist at all? Why not just use <code>Optional.ofNullable</code>  and be on the safe side at all times?</p>\n    ","a":"\n<p>Your question is based on assumption that the code which may throw <code>NullPointerException</code> is worse than the code which may not. This assumption is wrong. If you expect that your <code>foobar</code> is never null due to the program logic, it's much better to use <code>Optional.of(foobar)</code> as you will see a <code>NullPointerException</code> which will indicate that your program has a bug. If you use <code>Optional.ofNullable(foobar)</code> and the <code>foobar</code> happens to be <code>null</code> due to the bug, then your program will silently continue working incorrectly, which may be a bigger disaster. This way an error may occur much later and it would be much harder to understand at which point it went wrong.</p>\n    "},{"t":"Does Java 8 Support Closures?","l":"http://stackoverflow.com/questions/17204279/does-java-8-support-closures","q":"\n\n<p>I'm confused. I thought Java8 was going to emerge from the stone age and start supporting lambdas / closures. But when I try:</p>\n\n<pre><code>public static void main(String[] args) {\n    int number = 5;\n\n    ObjectCallback callback = () -&gt; {\n        return (number = number + 1);\n    };\n\n    Object result = callback.Callback();\n    System.out.println(result);\n}\n</code></pre>\n\n<p>it says that <code>number should be effectively final</code>. That's uh, not a closure I think. That just sounds like it's copying the environment by value, rather than by reference.</p>\n\n<p><strong>Bonus question!</strong></p>\n\n<p>Will android support Java-8 features?</p>\n    ","a":"\n<blockquote>\n  <p>Why oh why, Java. Why oh why.</p>\n</blockquote>\n\n<p>You would need to hold a long discussion with the relevant Oracle Java team members for the true answer.</p>\n\n<hr>\n\n<p>But I suspect it is a combination of backwards compatibility and project resourcing constraints.  And the fact that the current approach is \"good enough\" from a pragmatic perspective.</p>\n\n<p>Implementing procedure contexts as first-class objects (i.e. closures) requires that the lifetime of certain local variables extends beyond the return of the declaring method call.  That means that you cannot just put them on the stack.  Instead you end up with a situation where <em>some</em> local variables have to be fields of an heap object.  That means you need a new kind of hidden class OR fundamental changes to the JVM architecture.</p>\n\n<p>While it is technically possible to implement this kind of thing, the Java language is not a \"green field\" language.  A change of the nature need to support \"real closures\" would be difficult:</p>\n\n<ul>\n<li><p>It would take a huge amount of effort from Oracle and 3rd party implementors to update all of the tool chains.  (And we are not just talking about compilers.  There are debuggers, profilers, obfuscators, bytecode engineering frameworks, persistence frameworks ...)</p></li>\n<li><p>Then there is the risk that some of these changes would impact on backwards compatibility for the millions of existing deployed Java applications out there.</p></li>\n<li><p>There is the potential impact on <em>other</em> languages, etc that leverage the JVM in some way.  For example, Android depends on the JVM architecture / bytecode files as the \"input language\" for its Davlik tool-chain.  There are language implementations for Python, Ruby and various functional languages that code generate for the JVM platform.</p></li>\n</ul>\n\n<hr>\n\n<p>In short \"real closures\" in Java would be a big scary proposition for everyone concerned.  The \"closures for finals\" hack is a pragmatic compromise that does work, and that is good enough in practice.</p>\n\n<p>Lastly, there is always the possibility that the <code>final</code> restriction could be removed in a future edition.  (I wouldn't hold my breath though ....)</p>\n\n<hr>\n\n<blockquote>\n  <p>Will android support Java-8 features?</p>\n</blockquote>\n\n<p>That is impossible to answer unless someone has credible inside knowledge.  And if they did, they would be crazy to reveal it here. Certainly Google have not announced support for Java 8.</p>\n\n<p><sup>But the good news is that Java 7 syntax extensions are now supported with KitKat and corresponding versions of Android Studio or Eclipse ADT.</sup></p>\n    "},{"t":"Bug in java.time.Duration","l":"http://stackoverflow.com/questions/28958870/bug-in-java-time-duration","q":"\n\n<p>I need to parse <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/Duration.html\">Durations</a> from strings. Java 8 provide a method for that taking the <a href=\"http://en.wikipedia.org/wiki/ISO_8601\">ISO-8601</a> standard as a basis:</p>\n\n<pre><code>Duration.parse(\"p10d\"); // parses as ten days\nDuration.parse(\"pt1h\"); // parses as one hour\n</code></pre>\n\n<p>As the standard states that \"it is permitted to omit the 'T' character by mutual agreement\" some of the Javadoc examples of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-\">Durations.parse()</a> leave out the <code>T</code>. According to them, the following expression should parse as \"-6 hours and +3 minutes\":</p>\n\n<pre><code>\"P-6H3M\"\n</code></pre>\n\n<p>But I found that all expressions ommitting the <code>T</code> throw a <code>DateTimeParseException</code>. Is that a bug in the <code>parse()</code> method or am I missing something?</p>\n    ","a":"\n<p>In the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-\">JavaDoc</a> of <code>parse()</code>:</p>\n\n<blockquote>\n  <p>The ASCII letter \"T\" <strong>must</strong> occur before the first occurrence, if any, of an <strong>hour</strong>, <strong>minute</strong> or <strong>second</strong> section.</p>\n</blockquote>\n\n<p>That means you have to include <code>T</code> whenever you use <code>H</code>, <code>M</code>, or <code>S</code>.</p>\n\n<hr>\n\n<p>The examples are wrong though:</p>\n\n<pre><code>\"P-6H3M\"    -- parses as \"-6 hours and +3 minutes\"\n\"-P6H3M\"    -- parses as \"-6 hours and -3 minutes\"\n\"-P-6H+3M\"  -- parses as \"+6 hours and -3 minutes\"\n</code></pre>\n    "},{"t":"Very confused by Java 8 Comparator type inference","l":"http://stackoverflow.com/questions/24436871/very-confused-by-java-8-comparator-type-inference","q":"\n\n<p>I've been looking at the difference between <code>Collections.sort</code> and <code>list.sort</code>, specifically regarding using the <code>Comparator</code> static methods and whether param types are required in the lambda expressions. Before we start, I know I could use method references, e.g. <code>Song::getTitle</code> to overcome my problems, but my query here is not so much something I want to fix but something I want an answer to, i.e. why is the Java compiler handling it in this way. </p>\n\n<p>These are my finding. Suppose we have an <code>ArrayList</code> of type <code>Song</code>, with some songs added, there are 3 standard get methods:</p>\n\n<pre><code>    ArrayList&lt;Song&gt; playlist1 = new ArrayList&lt;Song&gt;();\n\n    //add some new Song objects\n    playlist.addSong( new Song(\"Only Girl (In The World)\", 235, \"Rhianna\") );\n    playlist.addSong( new Song(\"Thinking of Me\", 206, \"Olly Murs\") );\n    playlist.addSong( new Song(\"Raise Your Glass\", 202,\"P!nk\") );\n</code></pre>\n\n<p>Here is a call to both types of sort method that works, no problem:</p>\n\n<pre><code>Collections.sort(playlist1, \n            Comparator.comparing(p1 -&gt; p1.getTitle()));\n\nplaylist1.sort(\n            Comparator.comparing(p1 -&gt; p1.getTitle()));\n</code></pre>\n\n<p>As soon as I start to chain <code>thenComparing</code>, the following happens:</p>\n\n<pre><code>Collections.sort(playlist1,\n            Comparator.comparing(p1 -&gt; p1.getTitle())\n            .thenComparing(p1 -&gt; p1.getDuration())\n            .thenComparing(p1 -&gt; p1.getArtist())\n            );\n\nplaylist1.sort(\n        Comparator.comparing(p1 -&gt; p1.getTitle())\n        .thenComparing(p1 -&gt; p1.getDuration())\n        .thenComparing(p1 -&gt; p1.getArtist())\n        );\n</code></pre>\n\n<p>i.e. syntax errors because it does not know the type of <code>p1</code> anymore. So to fix this I add the type <code>Song</code> to the first parameter (of comparing):</p>\n\n<pre><code>Collections.sort(playlist1,\n            Comparator.comparing((Song p1) -&gt; p1.getTitle())\n            .thenComparing(p1 -&gt; p1.getDuration())\n            .thenComparing(p1 -&gt; p1.getArtist())\n            );\n\nplaylist1.sort(\n        Comparator.comparing((Song p1) -&gt; p1.getTitle())\n        .thenComparing(p1 -&gt; p1.getDuration())\n        .thenComparing(p1 -&gt; p1.getArtist())\n        );\n</code></pre>\n\n<p>Now here comes the CONFUSING part. For p<code>laylist1.sort</code>, i.e. the List, this solve all compilation errors, for both the following <code>thenComparing</code> calls. However, for <code>Collections.sort</code>, it solves it for the first one, but not the last one. I tested added several extra calls to <code>thenComparing</code> and it always shows an error for the last one, unless I put <code>(Song p1)</code> for the parameter.</p>\n\n<p>Now I went on to test this further with creating a <code>TreeSet</code> and with using <code>Objects.compare</code>:</p>\n\n<pre><code>int x = Objects.compare(t1, t2, \n                Comparator.comparing((Song p1) -&gt; p1.getTitle())\n                .thenComparing(p1 -&gt; p1.getDuration())\n                .thenComparing(p1 -&gt; p1.getArtist())\n                );\n\n\n    Set&lt;Song&gt; set = new TreeSet&lt;Song&gt;(\n            Comparator.comparing((Song p1) -&gt; p1.getTitle())\n            .thenComparing(p1 -&gt; p1.getDuration())\n            .thenComparing(p1 -&gt; p1.getArtist())\n            );\n</code></pre>\n\n<p>The same thing happens as in, for the <code>TreeSet</code>, there are no compilation errors but for <code>Objects.compare</code> the last call to <code>thenComparing</code> shows an error.</p>\n\n<p>Can anyone please explain why this is happening and also why there is no need to use <code>(Song p1)</code> at all when simply calling the comparing method (without further <code>thenComparing</code> calls).</p>\n\n<p>One other query on the same topic is when I do this to the <code>TreeSet</code>:</p>\n\n<pre><code>Set&lt;Song&gt; set = new TreeSet&lt;Song&gt;(\n            Comparator.comparing(p1 -&gt; p1.getTitle())\n            .thenComparing(p1 -&gt; p1.getDuration())\n            .thenComparing(p1 -&gt; p1.getArtist())\n            );\n</code></pre>\n\n<p>i.e. remove the type <code>Song</code> from the first lambda parameter for the comparing method call, it shows syntax errors under the call to comparing and the first call to <code>thenComparing</code> but not to the final call to <code>thenComparing</code> - almost the opposite of what was happening above! Whereas, for all the other 3 examples i.e. with <code>Objects.compare</code>, <code>List.sort</code> and <code>Collections.sort</code> when I remove that first <code>Song</code> param type it shows syntax errors for all the calls.</p>\n\n<p>Many thanks in advance.</p>\n\n<p>Edited to include screenshot of errors I was receiving in Eclipse Kepler SR2, which I have now since found are Eclipse specific because when compiled using the JDK8 java compiler on the command-line it compiles OK. </p>\n\n<p><img src=\"http://i.stack.imgur.com/cPEfH.jpg\" alt=\"Sort errors in Eclipse\"></p>\n    ","a":"\n<p>First, all the examples you say cause errors compile fine with the reference implementation (javac from JDK 8.)  They also work fine in IntelliJ, so its quite possible the errors you're seeing are Eclipse-specific.  </p>\n\n<p>Your underlying question seems to be: \"why does it stop working when I start chaining.\"  The reason is, while lambda expressions and generic method invocations are <em>poly expressions</em> (their type is context-sensitive) when they appear as method parameters, when they appear instead as method receiver expressions, they are not.  </p>\n\n<p>When you say</p>\n\n<pre><code>Collections.sort(playlist1, \n                 comparing(p1 -&gt; p1.getTitle()));\n</code></pre>\n\n<p>there is enough type information to solve for both the type argument of <code>comparing()</code> and the argument type <code>p1</code>.  The <code>comparing()</code> call gets its target type from the signature of <code>Collections.sort</code>, so it is known <code>comparing()</code> must return a <code>Comparator&lt;Song&gt;</code>, and therefore <code>p1</code> must be <code>Song</code>.  </p>\n\n<p>But when you start chaining:</p>\n\n<pre><code>Collections.sort(playlist1,\n                 comparing(p1 -&gt; p1.getTitle())\n                     .thenComparing(p1 -&gt; p1.getDuration())\n                     .thenComparing(p1 -&gt; p1.getArtist()));\n</code></pre>\n\n<p>now we've got a problem.  We know that the compound expression <code>comparing(..).thenComparing(...)</code> has a target type of <code>Comparator&lt;Song&gt;</code>, but because the receiver expression for the chain (<code>comparing(p -&gt; p.getTitle())</code>) is a generic method call, and we can't infer its type parameters from its other arguments, we're kind of out of luck.  Since we don't know the type of this expression, we don't know that it has a <code>thenComparing</code> method, etc.  </p>\n\n<p>There are several ways to fix this, all of which involve injecting more type information so that the initial object in the chain can be properly typed.  In rough order of decreasing desirability and increasing intrusiveness:</p>\n\n<ul>\n<li>Use an exact method reference (one with no overloads), like <code>Song::getTitle</code>.  This then gives enough type information to infer the type variables for the <code>comparing()</code> call, and therefore give it a type, and therefore continue down the chain.</li>\n<li>Use an explicit lambda (as you did in your example)</li>\n<li>Provide a type witness for the <code>comparing()</code> call: <code>Comparator.&lt;Song&gt;comparing(...)</code>.  </li>\n<li>Provide an explicit target type with a cast, casting the receiver expression to <code>Comparator&lt;Song&gt;</code>.  </li>\n</ul>\n    "},{"t":"Java 8 Collections concurrent processing","l":"http://stackoverflow.com/questions/21786548/java-8-collections-concurrent-processing","q":"\n\n<p>I am planning to do an internal presentation in my company on new features and concepts in Java 8. </p>\n\n<p>What I would like to focus is on the parallel processing capabilities of new collection libraries.</p>\n\n<p>Wherever I read about <strong><em>Java 8</em></strong> and the need for more functional style iterators of the collection library, it is mentioned that this will help to leverage the multi-core servers that are normal nowadays. But very rarely it is mentioned how this is made possible and <em>whether this is a universal truth</em>, let alone any benchmarks on performance.</p>\n\n<p>As even experienced developers in my company who claims to know about threads have no clue how actual threading works at the lower level, I am trying to collect some knowledge in this area. I have made a set of following assertions based on reading several blogs etc. </p>\n\n<p>I would be thankful for some feedback for the following points <strong>(true/false)</strong>..</p>\n\n<ol>\n<li><p>A thread is the lowest unit of scheduling in an OS (yeah basic stuff, but not all application programmers know this ;-))</p></li>\n<li><p>A single threaded program can run only on one core at a time. So in a quad core CPU, 75% of the CPU is not utilized for example.</p></li>\n<li><p>The problem with present Java collection iterator is that it is an external iterator and it is not possible (atleast out of the box) to distribute a bulky collection iteration to multiple threads. The new collection library operations makes it possible to have concurrency without having the need to deal with low level concurrency issues</p></li>\n<li><p>Java 8 makes it possible using an enhanced collection library to parallellize iteration using an internal iterator</p>\n\n<p>Instead of Java 7 </p>\n\n<p><code>for (Shape s : shapes) {if (s.getColor() == RED)s.setColor(BLUE);  }</code></p>\n\n<p>we have in Java 8</p>\n\n<p><code>shapes.forEach(s -&gt; { \n    if (s.getColor() == RED)\n        s.setColor(BLUE);  })</code></p></li>\n<li><p>But inorder to parallellize the above iteration, one must explicitly use <code>parallel()</code> method of <code>Stream API</code> </p>\n\n<p><code>private static void printUsingCoolLambda (final List&lt;String&gt; names) {\n      names.parallelStream().forEach(s -&gt; System.out.println(s));\n    System.out.println(\"Printed using printUsingCoolLambda\");\n}</code></p>\n\n<p>But even then there is no guarantee that the operation will be done in parallel as the Javadoc of <code>parallelStream()</code> says the following <a href=\"http://download.java.net/jdk8/docs/api/java/util/Collection.html#parallelStream--\">\"Returns a possibly parallel {@code Stream} with this collection as its source. It is allowable for this method to return a sequential stream\"</a></p></li>\n<li><p>Ultimately, there is no guarantee that all the cores will be utilized as thread scheduling is NOT a JVM responsibility, rather dictated by OS.</p></li>\n</ol>\n\n<p><strong>edit</strong></p>\n\n<p>I have most difficulty in getting points 5 and 6 right. As various Java 8 blogs says just that <em>\"use this new parallelStream() and you will get parallel processing out of the box(for free and you as an application programmer are freed from having to worry about that)\"</em>, my question in one sentence would have been <strong><em>is that really correct all the time</em></strong>?</p>\n    ","a":"\n<blockquote>\n  <p>I would be thankful for some feedback for the following points\n  (true/false)..</p>\n</blockquote>\n\n<p>Unfortunately none of the answers are either true or false. They are all \"it depends\" or \"it's complicated\". :-)</p>\n\n<blockquote>\n  <p>1: A thread is the lowest unit of scheduling in an OS.</p>\n</blockquote>\n\n<p>This is basically true. OSes schedule threads, and for the most part a Java thread corresponds to an OS thread.</p>\n\n<p>However, there's more to the story. I'd encourage you not to think too much about threads. They are a very low-level construct to use to structure a parallel application.</p>\n\n<p>Of course it's possible to write applications using threads, but it's often preferable to use a higher level construct. One such construct is a <strong>task</strong>, which is an application-specific chunk of work. If you can divide your workload into separate tasks, you can submit these tasks to an <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html\">Executor</a>, which will manage the scheduling of tasks onto threads and the creation and destruction of threads. This is the <code>java.util.concurrent</code> stuff that went into Java SE 5.</p>\n\n<p>Another way to structure a parallel applications is using <strong>data parallelism</strong>. Java SE 7 introduced the Fork-Join framework. This refers to forking and joining not of <em>threads</em> but of <em>tasks</em>, specifically, tasks representing recursively-splittable portions of data. The FJ framework is quite effective for some workloads, but the splitting and joining of tasks is the responsibility of the programmer, and this can be burdensome.</p>\n\n<p>New in Java SE 8 is the streams API, which supports data parallelism in a much more convenient fashion.</p>\n\n<p>I've extrapolated quite a bit from your question about threads, but your questions seemed focused on threads, and there is much more to parallelism than threads. (One of my colleagues recently said, \"Threads are a false God.\")</p>\n\n<blockquote>\n  <p>2: A single threaded program can run only on one core at a time. So in a quad core CPU, 75% of the CPU is not utilized for example.</p>\n</blockquote>\n\n<p>Mostly true. If you consider just the application thread, a single thread can never use more than 25% of a quad core CPU. However, if you consider a Java thread running in a JVM, even a single-threaded Java application will likely run faster on a multi-core system than on a single-core system. The reason is that JVM service threads like the garbage collector can run in parallel with the application thread on a multi-core system, whereas they have to pre-empt the application thread on a single-core system.</p>\n\n<blockquote>\n  <p>3: The problem with present Java collection iterator is that it is an external iterator and it is not possible (at least out of the box) to distribute a bulky collection iteration to multiple threads. The new collection library operations makes it possible to have concurrency without having the need to deal with low level concurrency issues.</p>\n</blockquote>\n\n<p>Mostly yes. <em>External iteration</em> and <em>internal iteration</em> are concepts. External iteration is embodied by the actual <code>Iterator</code> interface. Internal iteration might use an <code>Iterator</code>, a simple for-loop, a set of fork-join tasks, or something else.</p>\n\n<p>It's not so much the new collection library, but the new Streams API in Java 8 will provide a much more convenient way to distribute work across threads.</p>\n\n<blockquote>\n  <p>4: Java 8 makes it possible using an enhanced collection library to parallellize iteration using an internal iterator (... <code>shapes.forEach</code> example ...)</p>\n</blockquote>\n\n<p>Close. Again, it's the new Streams library, not collections, that provides convenient parallelism. There's nothing like <code>Collection.parallelForEach</code>. To process elements of a collection in parallel, you have to pull a parallel stream from it. There are also a variety of parallel operations for arrays in the <code>java.util.Arrays</code> class.</p>\n\n<blockquote>\n  <p>5: But in order to parallelize the above iteration, one must explicitly use the <code>parallel</code> method of the Stream API .... But even then there is no guarantee that the operation will be done in parallel.</p>\n</blockquote>\n\n<p>Right, you need to request parallelism with the <code>parallel</code> or <code>parallelStream</code> method, depending on whether you're starting with a stream or a collection.</p>\n\n<p>Regarding no guarantees, sure, there are never any guarantees in life. :-) After all, if you're running on a single-core system, nothing can run in parallel. Another scenario is, in an applet, the security manager might prohibit the application from using more than a single thread. In practice, in most environments, requesting a parallel stream will indeed split up the workload and run the tasks in parallel. By default, these tasks run in the <a href=\"http://download.java.net/jdk8/docs/api/java/util/concurrent/ForkJoinPool.html\">common fork-join pool</a>, which by default has as many threads as there are cores in the system. But somebody might have set the number of threads to a different number, or even to 1, which is one reason the API itself cannot provide any guarantees.</p>\n\n<blockquote>\n  <p>6: Ultimately, there is no guarantee that all the cores will be utilized as thread scheduling is NOT a JVM responsibility, rather dictated by OS. ... As various Java 8 blogs says just that <em>\"use this new parallelStream() and you will get parallel processing out of the box (for free and you as an application programmer are freed from having to worry about that)\",</em> my question in one sentence would have been <strong>is that really correct all the time?</strong></p>\n</blockquote>\n\n<p>As above, no guarantees. There are many layers in the system where things can take a left turn. Even if your common FJ pool has as many threads as there are cores, there are no guarantees that each Java thread has its own OS thread. (In the Hotspot JVM I think this is always true though. It depends on the JVM.) There could be other processes -- even other JVMs -- on the same system competing for cores, so your application might not get as many cores as you'd like. In that sense the JVM is at the mercy of the OS to schedule threads for it.</p>\n\n<p>I'm not sure where that blog entry came from, but the bit about parallel processing \"for free\" and the \"you don't have to worry\" sentiment is overblown. In fact, it's basically wrong.</p>\n\n<p>It's true that it's possible to write a parallel stream much more conveniently than using earlier APIs. But it's also possible to get it very, very wrong. If you put side effects into your stream pipeline, you'll have race conditions, and you might get a different wrong answer every time. Or, even if you take care to synchronize around side effects, you might create enough contention so that a parallel stream might run even slower than a sequential one.</p>\n\n<p>Even if you've managed to avoid these pitfalls, it's not the case that running a parallel stream on an N-core system will give you an N times speedup. It just doesn't work that way. For small workloads the overhead of splitting and joining parallel tasks dominates, which can cause the computation to be slower than a sequential one. For larger workloads, the overhead is offset by the parallel speedup, but the overhead is still there. The amount of speedup also depends on the nature of the workload, the splitting characteristics, lumpiness of the data, etc. Tuning a parallel application is something of a black art.</p>\n\n<p>For easily-parallelizable workloads, in my experience, it's pretty easy to max out a two-core system. A four-core system usually can get at least 3x speedup. With more cores, it's not too difficult to get a 5x-6x speedup, but getting speedup beyond that requires actual work.</p>\n\n<p>For not-so-easily parallelizable workloads, you might have to do a lot of thinking and restructuring of the application before you can even try running it in parallel.</p>\n\n<p>I would not say that Java 8 gives you parallelism \"for free\" or \"without worry\" or anything like that. I <em>would</em> say that Java 8 gives you the opportunity to write parallel programs much more conveniently than before. But you still have to work to get it correct, and you will probably still have to work to achieve the speedup that you want.</p>\n    "},{"t":"When does JVM decide to reuse old lambda?","l":"http://stackoverflow.com/questions/29674645/when-does-jvm-decide-to-reuse-old-lambda","q":"\n\n<p>Consider the following code fragment:</p>\n\n<pre><code>public static Object o = new Object();\n\npublic static Callable x1() {\n    Object x = o;\n    return () -&gt; x;\n}\n\npublic static Callable x2() {\n    return () -&gt; o;\n}\n</code></pre>\n\n<p>Method <code>x2()</code> will always return the same lamba object, while <code>x1()</code> will always create new one:</p>\n\n<pre><code>    System.out.println(x1());\n    System.out.println(x1());\n    System.out.println(x2());\n    System.out.println(x2());\n</code></pre>\n\n<p>will printout something like this:</p>\n\n<pre><code>TestLambda$$Lambda$1/821270929@4a574795\nTestLambda$$Lambda$1/821270929@f6f4d33\nTestLambda$$Lambda$2/603742814@7adf9f5f\nTestLambda$$Lambda$2/603742814@7adf9f5f\n</code></pre>\n\n<p>Where (in JVM specification I guess?) is this rule of lambda reuse described? How does JVM decide where do reuse or not?</p>\n    ","a":"\n<p>You can't be sure about the identity of the object returned for a lambda expression. It can be a new instance, or a pre-existing instance.</p>\n\n<p>This is specified in <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.4\">JLS §15.27.4</a>:</p>\n\n<blockquote>\n  <p>At run time, evaluation of a lambda expression is similar to evaluation of a class instance creation expression, insofar as normal completion produces a reference to an object. Evaluation of a lambda expression is distinct from execution of the lambda body.</p>\n  \n  <p>Either a new instance of a class with the properties below is allocated and initialized, or an existing instance of a class with the properties below is referenced. If a new instance is to be created, but there is insufficient space to allocate the object, evaluation of the lambda expression completes abruptly by throwing an OutOfMemoryError.</p>\n</blockquote>\n    "},{"t":"Why don't primitive Stream have collect(Collector)?","l":"http://stackoverflow.com/questions/30310749/why-dont-primitive-stream-have-collectcollector","q":"\n\n<p>I'm writing a library for novice programmers so I'm trying to keep the API as clean as possible.</p>\n\n<p>One of the things my Library needs to do is perform some complex computations on a large collection of ints or longs.  There are lots of scenarios and business objects that my users need to compute these values from, so I thought the best way would be to use streams to allow users to map business objects to <code>IntStream</code> or <code>LongStream</code> and then compute the computations inside of a collector.  </p>\n\n<p>However IntStream and LongStream only have the 3 parameter collect method:</p>\n\n<pre><code>collect(Supplier&lt;R&gt; supplier, ObjIntConsumer&lt;R&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)\n</code></pre>\n\n<p>And doesn't have the simplier <code>collect(Collector)</code> method that <code>Stream&lt;T&gt;</code> has.</p>\n\n<p>So instead of being able to do</p>\n\n<pre><code>Collection&lt;T&gt; businessObjs = ...\nMyResult result = businessObjs.stream()\n                              .mapToInt( ... )\n                              .collect( new MyComplexComputation(...));\n</code></pre>\n\n<p>I have to do provide Suppliers, accumulators and combiners like this:</p>\n\n<pre><code>MyResult result = businessObjs.stream()\n                              .mapToInt( ... )\n                              .collect( \n                                  ()-&gt; new MyComplexComputationBuilder(...),\n                                  (builder, v)-&gt; builder.add(v),\n                                  (a,b)-&gt; a.merge(b))\n                              .build(); //prev collect returns Builder object\n</code></pre>\n\n<p>This is way too complicated for my novice users and is very error prone.</p>\n\n<p>My work around is to make static methods that take an <code>IntStream</code> or <code>LongStream</code> as input and hide the collector creation and execution for you </p>\n\n<pre><code>public static MyResult compute(IntStream stream, ...){\n       return .collect( \n                        ()-&gt; new MyComplexComputationBuilder(...),\n                        (builder, v)-&gt; builder.add(v),\n                        (a,b)-&gt; a.merge(b))\n               .build();\n}\n</code></pre>\n\n<p>But that doesn't follow the normal conventions of working with Streams:</p>\n\n<pre><code>IntStream tmpStream = businessObjs.stream()\n                              .mapToInt( ... );\n\n MyResult result = MyUtil.compute(tmpStream, ...);\n</code></pre>\n\n<p>Because you have to either save a temp variable and pass that to the static method, or create the Stream inside the static call which may be confusing when it's is mixed in with the other parameters to my computation.</p>\n\n<p>Is there a cleaner way to do this while still working with <code>IntStream</code> or <code>LongStream</code> ?</p>\n    ","a":"\n<p>We did in fact prototype some <code>Collector.OfXxx</code> specializations.  What we found -- in addition to the obvious annoyance of more specialized types -- was that this was not really very useful without having a full complement of primitive-specialized collections (like Trove does, or GS-Collections, but which the JDK does not have).  Without an IntArrayList, for example, a Collector.OfInt merely pushes the boxing somewhere else -- from the Collector to the container -- which no big win, and lots more API surface.  </p>\n    "},{"t":"smooth rounded corners in swing","l":"http://stackoverflow.com/questions/25031328/smooth-rounded-corners-in-swing","q":"\n\n<p>I want to make smooth rounded corners for my swing application, but I can't get my desired result...</p>\n\n<p>here's the screenshots:</p>\n\n<p>1.<code>setShape()</code> for JFrame :</p>\n\n<p><img src=\"http://i.stack.imgur.com/NdqeN.png\" alt=\"enter image description here\"></p>\n\n<p>2.overriding <code>paintComponent()</code> method for JPanel instead of using <code>setShape()</code> :</p>\n\n<p><img src=\"http://i.stack.imgur.com/xVnKl.png\" alt=\"enter image description here\"></p>\n\n<p>3.<code>setBackground(new Color(0, 0, 0, 0))</code> for JFrame :</p>\n\n<p><img src=\"http://i.stack.imgur.com/ZoCre.png\" alt=\"enter image description here\"></p>\n\n<p>well, but there's a problem with text quality:</p>\n\n<p>before step 3 :</p>\n\n<p><img src=\"http://i.stack.imgur.com/bljp8.png\" alt=\"enter image description here\"></p>\n\n<p>after step 3 :</p>\n\n<p><img src=\"http://i.stack.imgur.com/DSIFF.png\" alt=\"enter image description here\"></p>\n\n<p>guys I'm confused, I've searched many times but nothing helped me...\nwhat should I do? please help me</p>\n\n<p>here's the full code :</p>\n\n<pre><code>public class WelcomePage extends JFrame {\n\nprivate Point initialClick;\nprivate boolean end = false;\nprivate JLabel jLabelAppTitle;\nprivate JPanel jPanelExit;\nprivate JLabel jLabelHint;\nprivate int r = 220, g = 0, b = 0;\nprivate int r2 = 10, g2 = 10, b2 = 10;\nprivate boolean flag = false;\n\npublic WelcomePage() {\n    initComponents();\n//    setShape(new RoundRectangle2D.Double(0, 0, getWidth(), getHeight(), 15, 15));\n    centerLocation();\n    refreshPage();\n}\n\npublic static void main(String args[]) {\n    try {\n        for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {\n            if (\"Nimbus\".equals(info.getName())) {\n                UIManager.setLookAndFeel(info.getClassName());\n                break;\n            }\n        }\n    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException e) {\n        e.printStackTrace();\n    }\n    EventQueue.invokeLater(() -&gt; FadeTransitions.fadeIn(new WelcomePage(), FadeTransitions.NORMAL_FADE, true));\n}\n\nprivate void refreshPage() {\n    Timer timer = new Timer(20, e -&gt; {\n        if (!end) {\n            if (r == 220 &amp;&amp; b == 0 &amp;&amp; g &lt; 220) {\n                g++;\n            } else if (g == 220 &amp;&amp; b == 0 &amp;&amp; r &gt; 0) {\n                r--;\n            } else if (g == 220 &amp;&amp; r == 0 &amp;&amp; b &lt; 220) {\n                b++;\n            } else if (b == 220 &amp;&amp; r == 0 &amp;&amp; g &gt; 0) {\n                g--;\n            } else if (b == 220 &amp;&amp; g == 0 &amp;&amp; r &lt; 220) {\n                r++;\n            } else if (r == 220 &amp;&amp; g == 0 &amp;&amp; b &gt; 0) {\n                b--;\n            }\n            if (!flag) {\n                r2 += 5;\n                g2 += 5;\n                b2 += 5;\n                if (r2 == 250) {\n                    flag = true;\n                }\n            } else {\n                r2 -= 5;\n                g2 -= 5;\n                b2 -= 5;\n                if (r2 == 10) {\n                    flag = false;\n                }\n            }\n            jLabelAppTitle.setForeground(new Color(r, g, b));\n            jLabelHint.setForeground(new Color(r2, g2, b2));\n        } else {\n            ((Timer) e.getSource()).stop();\n        }\n    });\n    timer.setCoalesce(true);\n    timer.setRepeats(true);\n    timer.start();\n}\n\nprivate void centerLocation() throws HeadlessException {\n    final Toolkit toolkit = Toolkit.getDefaultToolkit();\n    final Dimension screenSize = toolkit.getScreenSize();\n    final int x = (screenSize.width - this.getWidth()) / 2;\n    final int y = (screenSize.height - this.getHeight()) / 2;\n    this.setLocation(x, y);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void initComponents() {\n\n    JPanel jPanelMain = new JPanel() {\n        @Override\n        protected void paintComponent(Graphics g) {\n            Graphics2D g2 = (Graphics2D) g.create();\n            RenderingHints qualityHints = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n            qualityHints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n            g2.setRenderingHints(qualityHints);\n            g2.setPaint(Color.WHITE);\n            g2.fillRoundRect(0, 0, getWidth(), getHeight(), 25, 25);\n            g2.dispose();\n        }\n    };\n    jPanelExit = new JPanel();\n    JLabel jLabelExit = new JLabel();\n    JLabel jLabelWelcome = new JLabel();\n    jLabelAppTitle = new JLabel();\n    jLabelHint = new JLabel();\n    JButton jButtonGo = new JButton();\n    setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);\n    setTitle(\"welcome to My App!\");\n    setUndecorated(true);\n    setBackground(new Color(0, 0, 0, 0));\n\n    addWindowListener(new WindowAdapter() {\n        @Override\n        public void windowClosing(WindowEvent e) {\n            close();\n        }\n    });\n    addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {\n        public void mouseDragged(MouseEvent evt) {\n            thisMouseDragged(evt);\n        }\n    });\n    addMouseListener(new java.awt.event.MouseAdapter() {\n        public void mousePressed(MouseEvent evt) {\n            thisMousePressed(evt);\n        }\n    });\n\n    jPanelMain.setBackground(Color.WHITE);\n    jPanelExit.setBackground(new Color(160, 0, 20));\n\n    jLabelExit.setFont(new Font(\"Tahoma\", Font.BOLD, 13));\n    jLabelExit.setForeground(new Color(255, 255, 255));\n    jLabelExit.setHorizontalAlignment(SwingConstants.CENTER);\n    jLabelExit.setText(\"X\");\n    jLabelExit.setCursor(new Cursor(Cursor.HAND_CURSOR));\n    jLabelExit.addMouseListener(new java.awt.event.MouseAdapter() {\n        public void mouseClicked(MouseEvent evt) {\n            jLabelExitMouseClicked();\n        }\n\n        public void mouseEntered(MouseEvent evt) {\n            jLabelExitMouseEntered();\n        }\n\n        public void mouseExited(MouseEvent evt) {\n            jLabelExitMouseExited();\n        }\n    });\n\n    GroupLayout jPanelExitLayout = new GroupLayout(jPanelExit);\n    jPanelExit.setLayout(jPanelExitLayout);\n    jPanelExitLayout.setHorizontalGroup(\n            jPanelExitLayout.createParallelGroup(GroupLayout.Alignment.LEADING)\n                    .addGroup(GroupLayout.Alignment.TRAILING, jPanelExitLayout.createSequentialGroup()\n                            .addGap(0, 0, Short.MAX_VALUE)\n                            .addComponent(jLabelExit, GroupLayout.PREFERRED_SIZE, 45, GroupLayout.PREFERRED_SIZE))\n    );\n    jPanelExitLayout.setVerticalGroup(\n            jPanelExitLayout.createParallelGroup(GroupLayout.Alignment.LEADING)\n                    .addGroup(GroupLayout.Alignment.TRAILING, jPanelExitLayout.createSequentialGroup()\n                            .addGap(0, 0, Short.MAX_VALUE)\n                            .addComponent(jLabelExit, GroupLayout.PREFERRED_SIZE, 22, GroupLayout.PREFERRED_SIZE))\n    );\n\n    jLabelWelcome.setFont(new Font(\"Tahoma\", 0, 25));\n    jLabelWelcome.setForeground(new Color(0, 0, 100));\n    jLabelWelcome.setHorizontalAlignment(SwingConstants.CENTER);\n    jLabelWelcome.setText(\"Welcome\");\n\n    jLabelAppTitle.setFont(new Font(\"MV Boli\", 0, 29));\n    jLabelAppTitle.setHorizontalAlignment(SwingConstants.CENTER);\n    jLabelAppTitle.setText(\"My Swing App\");\n\n    jButtonGo.setBackground(new Color(100, 20, 80));\n    jButtonGo.setFont(new Font(\"Tahoma\", 0, 15));\n    jButtonGo.setForeground(new Color(255, 255, 255));\n    jButtonGo.setText(\"GO\");\n    jButtonGo.addActionListener(evt -&gt; jButtonGoActionPerformed());\n\n    jLabelHint.setFont(new Font(\"Tahoma\", 0, 11));\n    jLabelHint.setHorizontalAlignment(SwingConstants.CENTER);\n    jLabelHint.setText(\"press GO button\");\n\n    javax.swing.GroupLayout jPanelMainLayout = new javax.swing.GroupLayout(jPanelMain);\n    jPanelMain.setLayout(jPanelMainLayout);\n    jPanelMainLayout.setHorizontalGroup(\n            jPanelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanelMainLayout.createSequentialGroup()\n                            .addContainerGap(48, Short.MAX_VALUE)\n                            .addGroup(jPanelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanelMainLayout.createSequentialGroup()\n                                            .addGap(0, 0, Short.MAX_VALUE)\n                                            .addComponent(jPanelExit, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                            .addGap(15, 15, 15))\n                                    .addGroup(jPanelMainLayout.createSequentialGroup()\n                                            .addGroup(jPanelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                                                    .addComponent(jLabelWelcome, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                                    .addComponent(jLabelAppTitle, javax.swing.GroupLayout.DEFAULT_SIZE, 220, Short.MAX_VALUE)\n                                                    .addComponent(jLabelHint, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                                                    .addComponent(jButtonGo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                                            .addContainerGap(48, Short.MAX_VALUE))))\n    );\n    jPanelMainLayout.setVerticalGroup(\n            jPanelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanelMainLayout.createSequentialGroup()\n                            .addComponent(jPanelExit, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addGap(64, 64, 64)\n                            .addComponent(jLabelWelcome, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addGap(98, 98, 98)\n                            .addComponent(jLabelAppTitle)\n                            .addGap(86, 86, 86)\n                            .addComponent(jLabelHint)\n                            .addGap(24, 24, 24)\n                            .addComponent(jButtonGo, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addGap(86, 86, 86))\n    );\n\n    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n    getContentPane().setLayout(layout);\n    layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                            .addGap(0, 0, 0)\n                            .addComponent(jPanelMain, javax.swing.GroupLayout.DEFAULT_SIZE, 316, Short.MAX_VALUE)\n                            .addGap(0, 0, 0))\n    );\n    layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                            .addGap(0, 0, 0)\n                            .addComponent(jPanelMain, javax.swing.GroupLayout.DEFAULT_SIZE, 473, Short.MAX_VALUE)\n                            .addGap(0, 0, 0))\n    );\n\n    pack();\n}\n\nprivate void thisMousePressed(MouseEvent evt) {\n    initialClick = evt.getPoint();\n}\n\nprivate void thisMouseDragged(MouseEvent evt) {\n    int thisX = this.getLocation().x;\n    int thisY = this.getLocation().y;\n    int xMoved = (thisX + evt.getX()) - (thisX + initialClick.x);\n    int yMoved = (thisY + evt.getY()) - (thisY + initialClick.y);\n    int x = thisX + xMoved;\n    int y = thisY + yMoved;\n    this.setLocation(x, y);\n}\n\nprivate void jLabelExitMouseClicked() {\n    close();\n}\n\nprivate void close() {\n    end = true;\n    FadeTransitions.fadeOut(this, FadeTransitions.FAST_FADE, FadeTransitions.EXIT_ON_CLOSE);\n}\n\nprivate void jLabelExitMouseEntered() {\n    jPanelExit.setBackground(new Color(200, 0, 20));\n}\n\nprivate void jLabelExitMouseExited() {\n    jPanelExit.setBackground(new Color(160, 0, 20));\n}\n\nprivate void jButtonGoActionPerformed() {\n    end = true;\n    FadeTransitions.run(this, new ServerManager(this), FadeTransitions.NORMAL_FADE, FadeTransitions.DISPOSE_ON_CLOSE);\n}\n\n}\n</code></pre>\n\n<p>thanks.</p>\n    ","a":"\n<p>Sorry, not an answer, but hopefully at least one step towards an acceptable answer: From my analysis so far, it <em>might</em> be that this is simply a bug somewhere deep (deeeep!) inside the rendering pipeline. </p>\n\n<p>The following <a href=\"http://stackoverflow.com/help/mcve\">MVCE</a> shows two (undecorated) frames, each containing a button. They are equal, <em>except</em> for the background of the frames. For one frame, the color is transparent, and for the other one, it is opaque.</p>\n\n<pre><code>import java.awt.Color;\nimport java.awt.Font;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\nimport javax.swing.UIManager;\n\npublic class TextRenderBug extends JFrame {\n\n    public static void main(String[] args)\n    {\n        setLookAndFeel();\n        SwingUtilities.invokeLater(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                createAndShowGUI(new Color(0,0,0  ), 400);\n                createAndShowGUI(new Color(0,0,0,0), 600);\n            }\n        });\n    }\n\n    private static void setLookAndFeel()\n    {\n        try\n        {\n            for (UIManager.LookAndFeelInfo info : \n                    UIManager.getInstalledLookAndFeels())\n            {\n                if (\"Nimbus\".equals(info.getName()))\n                {\n                    UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n\n    private static void createAndShowGUI(Color background, int x)\n    {\n        JFrame f = new JFrame();\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.setUndecorated(true);\n        f.setBackground(background);\n        JButton b = new JButton(\"Text\");\n        b.setFont(new Font(\"Tahoma\", 0, 15));\n        f.getContentPane().add(b);\n        f.setBounds(x, 400, 200, 50);\n        f.setVisible(true);\n    }\n}\n</code></pre>\n\n<p>It clearly shows that the text is rendered <em>differently</em>, solely depending on the background being transparent - and of course, this should not be the case. </p>\n\n<p><img src=\"http://i.stack.imgur.com/pkhD0.png\" alt=\"TextRenderBug\"></p>\n\n<p>(This is not Nimbus-specific, by the way: It also applies to other LookAndFeels. Just remove the line where the LaF is set).</p>\n\n<p>What I found out so far: </p>\n\n<ul>\n<li>The behavior is somehow caused by the <code>drawString</code> method of the <code>sun.swing.SwingUtilities2</code> class</li>\n<li>It does not appear in all components. It can be observed on <code>JButton</code> and <code>JLabel</code>, but not on a normal <code>JComponent</code> </li>\n<li>Update: It also does not depend on the font (although with other fonts, the effect is not so noticable). When rendered correctly, the font looks a little bit more bold, but of course, it is not simply the same font as a <code>Font.BOLD</code>. </li>\n<li>The painting process is rather complicated.</li>\n</ul>\n\n<p>(OK, some of you might already have known the latter). </p>\n\n<p>Here is an example that shows the last observations, maybe it can serve as a starting point for further research of others:</p>\n\n<pre><code>import java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.GridLayout;\nimport java.lang.reflect.Method;\n\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class TextRenderBugTest\n{\n    public static void main(String[] args)\n    {\n        SwingUtilities.invokeLater(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                createAndShowGUI(new Color(0,0,0  ), 400);\n                createAndShowGUI(new Color(0,0,0,0), 600);\n            }\n        });\n    }\n\n    private static void createAndShowGUI(Color background, int x)\n    {\n        JFrame f = new JFrame();\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.setUndecorated(true);\n        f.setBackground(background);\n\n        JButton b = new JButton(\"Text\");\n        b.setFont(new Font(\"Tahoma\", 0, 15));\n\n        JComponent c = new ExampleComponent();\n        c.setFont(new Font(\"Tahoma\", 0, 15));\n\n        f.getContentPane().setLayout(new GridLayout(0,1));\n        f.getContentPane().add(b);\n        f.getContentPane().add(c);\n\n        f.setBounds(x, 400, 200, 100);\n        f.setVisible(true);\n    }\n\n    static class ExampleComponent \n        //extends JComponent\n        extends JButton\n    {\n        @Override\n        protected void paintComponent(Graphics g)\n        {\n            super.paintComponent(g);\n            g.setColor(getBackground());\n            g.fillRect(0, 0, getWidth(), getHeight());\n            g.setColor(getForeground());\n            g.drawString(\"Text\", 10, 20);\n            drawStringWithSwingUtilities(g, 60, 20);\n        }\n\n        private void drawStringWithSwingUtilities(Graphics g, int x, int y)\n        {\n            try\n            {\n                Class&lt;?&gt; c = Class.forName(\"sun.swing.SwingUtilities2\");\n                Method m = c.getMethod(\"drawString\", JComponent.class,\n                    Graphics.class, String.class, int.class, int.class);\n                m.invoke(null, this, g, \"Text\", x, y);\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n            }\n\n        }\n\n    }\n\n}\n</code></pre>\n\n<p>I already tried to analyze this further, and played around with <code>RenderingHints</code> like <code>KEY_TEXT_ANTIALIASING</code> and <code>KEY_TEXT_LCD_CONTRAST</code> and other settings that are changed in the painting pipeline while it is heading towards the pixels that are finally placed on the screen, but no further insights until now.</p>\n\n<p>(If you want to, you can add this information to your original question, then I'll delete this (not-)answer)</p>\n    "},{"t":"Some scene not loading after maven build","l":"http://stackoverflow.com/questions/30144403/some-scene-not-loading-after-maven-build","q":"\n\n<p>I am developing JavaFx application in netbeans, in netbeans the project is building and running fine. </p>\n\n<p>I made a build (mvn package) from my project its finished without error but when I launch the program its not loading all the scenes and the FXMLLoader return with null value in this cases. </p>\n\n<p>All .fxml file in the same folder. </p>\n\n<pre><code>public class JavaFXApplication extends Application {\n\n    public static final String TOOLBAR_MAIN = \"toolbarMain\";\n    public static final String TOOLBAR_MAIN_FXML = \"/fxml/ToolbarMain.fxml\";\n    public static final String TOOLBAR_SUB = \"toolbarSub\";\n    public static final String TOOLBAR_SUB_FXML = \"/fxml/ToolbarSub.fxml\";\n\n    public static final String NEW_SESSION_PANEL = \"newSession\";\n    public static final String NEW_SESSION_PANEL_FXML = \"/fxml/NewSessionPanel.fxml\";\n    public static final String OPEN_SESSION_PANEL = \"openSession\";\n    public static final String OPEN_SESSION_PANEL_FXML = \"/fxml/OpenSessionPanel.fxml\";\n    public static final String CONNECTIONS_PANEL = \"connections\";\n    public static final String CONNECTIONS_PANEL_FXML = \"/fxml/ConnectionsPanel.fxml\";\n    public static final String LOGS_PANEL = \"logs\";\n    public static final String LOGS_PANEL_FXML = \"/fxml/LogsPanel.fxml\";\n    public static final String EXCEPTIONS_PANEL = \"exceptions\";\n    public static final String EXCEPTIONS_PANEL_FXML = \"/fxml/ExceptionsPanel.fxml\";\n    public static final String MESSAGES_PANEL = \"messages\";\n    public static final String MESSAGES_PANEL_FXML = \"/fxml/MessagesPanel.fxml\";\n\n    public static ScreensController menuContainer = new ScreensController();\n    public static ScreensController contentContainer = new ScreensController();\n\n    public static ServerService server = new ServerService();\n\n    public static Stage STAGE;\n\n    @Override\n    public void start(Stage primaryStage) throws Exception {\n\n        STAGE = primaryStage;\n\n        primaryStage.setOnCloseRequest((WindowEvent t) -&gt; {\n            if (server.isRunning()) {\n                server.cancel();\n            }\n        });\n\n        menuContainer.loadScreen(JavaFXApplication.TOOLBAR_MAIN,\n                JavaFXApplication.TOOLBAR_MAIN_FXML);\n        menuContainer.loadScreen(JavaFXApplication.TOOLBAR_SUB,\n                JavaFXApplication.TOOLBAR_SUB_FXML);\n\n        contentContainer.loadScreen(JavaFXApplication.NEW_SESSION_PANEL,\n                JavaFXApplication.NEW_SESSION_PANEL_FXML);\n        contentContainer.loadScreen(JavaFXApplication.OPEN_SESSION_PANEL,\n                JavaFXApplication.OPEN_SESSION_PANEL_FXML);\n        contentContainer.loadScreen(JavaFXApplication.NEW_SESSION_PANEL,\n                JavaFXApplication.NEW_SESSION_PANEL_FXML);\n        contentContainer.loadScreen(JavaFXApplication.CONNECTIONS_PANEL,\n                JavaFXApplication.CONNECTIONS_PANEL_FXML);\n        contentContainer.loadScreen(JavaFXApplication.LOGS_PANEL,\n                JavaFXApplication.LOGS_PANEL_FXML);\n        contentContainer.loadScreen(JavaFXApplication.EXCEPTIONS_PANEL,\n                JavaFXApplication.EXCEPTIONS_PANEL_FXML);\n        contentContainer.loadScreen(JavaFXApplication.MESSAGES_PANEL,\n                JavaFXApplication.MESSAGES_PANEL_FXML);\n        menuContainer.setScreen(JavaFXApplication.TOOLBAR_MAIN);\n        contentContainer.setScreen(JavaFXApplication.NEW_SESSION_PANEL);\n\n        SplitPane root = new SplitPane();\n\n        root.getItems().addAll(menuContainer, contentContainer);\n        Scene scene = new Scene(root);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n        primaryStage.setResizable(false);\n        primaryStage.setTitle(\"Exam Supervisor\");\n\n    }\n</code></pre>\n\n<p>Screen controller where the screens loaded:</p>\n\n<pre><code>public class ScreensController extends StackPane {\n\n    private HashMap&lt;String, Node&gt; screens = new HashMap&lt;&gt;();\n\n    public void addScreen(String name, Node screen) {\n        screens.put(name, screen);\n    }\n\n    public boolean loadScreen(String name, String resource) {\n        try {\n            FXMLLoader myLoader = new FXMLLoader(getClass().getResource(resource));\n            System.out.println(\"name:\" + name + \" ,resource\" + resource + \" ,loader:\" + myLoader.getLocation());\n            Parent loadScreen = myLoader.load();\n            ControlledScreen myScreenControler\n                    = myLoader.getController();\n            myScreenControler.setScreenParent(this);\n            addScreen(name, loadScreen);\n            return true;\n        } catch (Exception e) {\n            System.out.println(\"name: \" + name + \", resource\" + resource + \" ,exception: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public boolean setScreen(final String name) {\n\n        if (screens.get(name) != null) {\n            final DoubleProperty opacity = opacityProperty();\n\n            if (!getChildren().isEmpty()) {\n                getChildren().remove(0);\n                getChildren().add(0, screens.get(name));\n            } else {\n                getChildren().add(screens.get(name));\n            }\n            return true;\n        } else {\n            System.out.println(screens.get(name) + \" ,screen hasn't been loaded!\\n\");\n            return false;\n        }\n\n    }\n\n    public boolean unloadScreen(String name) {\n        if (screens.remove(name) == null) {\n            System.out.println(\"Screen didn't exist\");\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n</code></pre>\n\n<p>My github repo: <a href=\"https://github.com/eszikk/ExamSuperVisorServer\">https://github.com/eszikk/ExamSuperVisorServer</a></p>\n    ","a":"\n<p>I looked into your netbeans project files and the maven pom and found nothing strange. The fact that the javafx libs are not contained in the classpath of both configurations tells me that, you are using it from the Java Installation. </p>\n\n<p>Perhaps you use a differrent Java installation from netbeans and when you start the maven target. Then, the fxml module might be missing or there is no java fx installed with the second installation or something else is not compatible. </p>\n\n<p>Did you start the maven target from a console? e.g.</p>\n\n<blockquote>\n  <p>java -jar xyz.jar</p>\n</blockquote>\n\n<p>Try </p>\n\n<blockquote>\n  <p>java -version</p>\n</blockquote>\n\n<p>and compare the version with the java version used by netbeans (Help &gt; About).</p>\n\n<p>Netbeans build are done by an internal maven version. But there is also a chance that an external maven build uses a different version of the java compiler than the internal netbeans build.</p>\n\n<p>I hope that helps!</p>\n    "},{"t":"Lambdas and functional interfaces with generic throw clauses","l":"http://stackoverflow.com/questions/24199148/lambdas-and-functional-interfaces-with-generic-throw-clauses","q":"\n\n<p>Consider this snippet of java 8 code:</p>\n\n<pre><code>public class Generics {\n  public static &lt;V, E extends Exception&gt; V f(CheckedCallable1&lt;V, E&gt; callable) throws E {\n    return callable.call();\n  }\n  public static &lt;V, E extends Exception&gt; V g(CheckedCallable2&lt;V, E&gt; callable) throws E {\n    return callable.call();\n  }\n  public static void main(String[] args) {\n    f(() -&gt; 1);\n    g(() -&gt; 1);\n  }\n}\n\ninterface Callable&lt;V&gt; {\n  V call() throws Exception;\n}\n\ninterface CheckedCallable1&lt;V, E extends Exception&gt; {\n  V call() throws E;\n}\n\ninterface CheckedCallable2&lt;V, E extends Exception&gt; extends Callable&lt;V&gt; {\n  @Override V call() throws E;\n}\n</code></pre>\n\n<p>The lambda at the call to <code>f</code> compiles fine, whereas the lambda at the call to <code>g</code> does not compile, but rather gives this compile error:</p>\n\n<pre><code>Error:(10, 7) java: call() in &lt;anonymous Generics$&gt; cannot implement call() in CheckedCallable2\n  overridden method does not throw java.lang.Exception\n</code></pre>\n\n<p>Why is this?</p>\n\n<p>It seems to me that both the <code>CheckedCallable1.call</code> and <code>CheckedCallable2.call</code> methods are equivalent: by the rules of type erasure, <code>V</code> becomes <code>Object</code> as it is unbounded, and <code>E</code> becomes <code>Exception</code>, as that's the upper type bound. So why does the compiler think the overridden method does not throw java.lang.Exception?</p>\n\n<p>Even disregarding type erasure, which is likely not relevant here because this is all happening at compile time, it still does not make sense to me: I don't see a reason why this pattern, if allowed, would result in, say, unsound java code.</p>\n\n<p>So can someone enlighten me as to why this isn't allowed?</p>\n\n<p><em>Update:</em></p>\n\n<p>So I found something that's maybe even more interesting. Take the above file, change each occurrence of <code>Exception</code> to <code>IOException</code> and add throws clause to <code>main</code>. Compile works! Change back to <code>Exception</code>: compile breaks!</p>\n\n<p>This compiles fine:</p>\n\n<pre><code>import java.io.IOException;\n\npublic class Generics {\n  public static &lt;V, E extends IOException&gt; V f(CheckedCallable1&lt;V, E&gt; callable) throws E {\n    return callable.call();\n  }\n  public static &lt;V, E extends IOException&gt; V g(CheckedCallable2&lt;V, E&gt; callable) throws E {\n    return callable.call();\n  }\n  public static void main(String[] args) throws IOException {\n    f(() -&gt; 1);\n    g(() -&gt; 1);\n  }\n}\n\ninterface Callable&lt;V&gt; {\n  V call() throws IOException;\n}\n\ninterface CheckedCallable1&lt;V, E extends IOException&gt; {\n  V call() throws E;\n}\n\ninterface CheckedCallable2&lt;V, E extends IOException&gt; extends Callable&lt;V&gt; {\n  @Override V call() throws E;\n}\n</code></pre>\n\n<p>At this point it's starting to look more and more like a java bug...</p>\n    ","a":"\n<p>I don’t think that there is a rule forbidding this pattern. It’s rather likely you found a compiler bug.</p>\n\n<p>It’s easy to show that this pattern does not result in unsound code by just writing down the equivalent inner class code of <code>g(() -&gt; 1);</code>:</p>\n\n<pre><code>g(new CheckedCallable2&lt;Integer, RuntimeException&gt;() {\n    public Integer call() {\n        return 1;\n    }\n});\n</code></pre>\n\n<p>This compiles and runs without any problems, even under Java&nbsp;6 (I assume it would even run on Java&nbsp;5 but I had no JDK to test it) and there is no reason why it shouldn’t work when doing the same with a lambda. Writing down this code in Netbeans results even in the recommendation to convert it to a lambda.</p>\n\n<p>There is also no runtime restriction which would forbid such a construct. Besides the fact that under the hood there are no exception rules enforced and everything relies on the compile-time checks, we can even prove that it would work if the compiler accepted our code by creating the code manually that the compiler would create:</p>\n\n<pre><code>CheckedCallable2&lt;Integer,RuntimeException&gt; c;\ntry\n{\n  MethodHandles.Lookup l = MethodHandles.lookup();\n  c=(CheckedCallable2)\n    LambdaMetafactory.metafactory(l, \"call\",\n      MethodType.methodType(CheckedCallable2.class),\n      MethodType.methodType(Object.class),\n      l.findStatic(Generics.class, \"lambda$1\", MethodType.methodType(int.class)),\n      MethodType.methodType(Integer.class)).getTarget().invokeExact();\n} catch(Throwable t) { throw new AssertionError(t); }\nint i=g(c);\nSystem.out.println(i);\n// verify that the inheritance is sound:\nCallable&lt;Integer&gt; x=c;\ntry { System.out.println(x.call()); }// throws Exception\ncatch(Exception ex) { throw new AssertionError(ex); }\n\n…\nstatic int lambda$1() { return 1; }// the synthetic method for ()-&gt;1\n</code></pre>\n\n<p>This code runs and produces <code>1</code> as expected, regardless of which <code>interface</code> we use to <code>call()</code>. Only the exceptions we have to catch differ. But as said, that’s a compile-time artifact.</p>\n    "},{"t":"Why didn't Stream have a toList() method?","l":"http://stackoverflow.com/questions/28782165/why-didnt-stream-have-a-tolist-method","q":"\n\n<p>When using the Java 8 streams, it's quite common to take a list, create a stream from it, do the business and convert it back. Something like:</p>\n\n<pre><code> Stream.of(-2,1,2,-5)\n        .filter(n -&gt; n &gt; 0)\n        .map(n -&gt; n * n)\n        .collect(Collectors.toList());\n</code></pre>\n\n<p>Why there is no short-cut/convenient method for the '<code>.collect(Collectors.toList())</code>' part? On Stream interface, there is method for converting the results to array called <code>toArray()</code>, why the <code>toList()</code> is missing?</p>\n\n<p>IMHO, converting the result to list is more common than to array. I can live with that, but it is quite annoying to call this ugliness.</p>\n\n<p>Any ideas?</p>\n    ","a":"\n<p>Recently I wrote a small library called <a href=\"https://github.com/amaembo/streamex\" rel=\"nofollow\">StreamEx</a> which extends Java streams and provides this exact method among many other features:</p>\n\n<pre><code>StreamEx.of(-2,1,2,-5)\n    .filter(n -&gt; n &gt; 0)\n    .map(n -&gt; n * n)\n    .toList();\n</code></pre>\n\n<p>Also toSet(), toCollection(Supplier), joining(), groupingBy() and other shortcut methods are available there.</p>\n    "},{"t":"How can I throw CHECKED exceptions from inside Java 8 streams?","l":"http://stackoverflow.com/questions/27644361/how-can-i-throw-checked-exceptions-from-inside-java-8-streams","q":"\n\n<p>How can I throw CHECKED exceptions from inside Java 8 streams/lambdas?</p>\n\n<p>In other words, I want to make code like this compile:</p>\n\n<pre><code>public List&lt;Class&gt; getClasses() throws ClassNotFoundException {     \n\n    List&lt;Class&gt; classes = \n        Stream.of(\"java.lang.Object\", \"java.lang.Integer\", \"java.lang.String\")\n              .map(className -&gt; Class.forName(className))\n              .collect(Collectors.toList());\n\n    return classes;\n    }\n</code></pre>\n\n<p>This code does not compile, since the <code>Class.forName()</code> method above throws <code>ClassNotFoundException</code>, which is checked.</p>\n\n<p>Please note I do NOT want to wrap the checked exception inside a runtime exception and throw the wrapped unchecked exception instead. <strong>I want to throw the checked exception itself</strong>, and without adding ugly <code>try</code>/<code>catches</code> to the stream.</p>\n    ","a":"\n<p>This <code>UtilException</code> helper class lets you use any checked exceptions in Java streams, like this:</p>\n\n<pre><code>Stream.of(\"java.lang.Object\", \"java.lang.Integer\", \"java.lang.String\")\n      .map(rethrowFunction(Class::forName))\n      .collect(Collectors.toList());\n</code></pre>\n\n<p>Note <code>Class::forName</code> throws <code>ClassNotFoundException</code>, which is <strong>checked</strong>. The stream itself also throws <code>ClassNotFoundException</code>, and NOT some wrapping unchecked exception.</p>\n\n<pre><code>public final class UtilException {\n\n@FunctionalInterface\npublic interface Consumer_WithExceptions&lt;T&gt; {\n    void accept(T t) throws Exception;\n    }\n\n@FunctionalInterface\npublic interface Function_WithExceptions&lt;T, R&gt; {\n    R apply(T t) throws Exception;\n    }\n\n@FunctionalInterface\npublic interface Supplier_WithExceptions&lt;T&gt; {\n    T get() throws Exception;\n    }\n\n@FunctionalInterface\npublic interface Runnable_WithExceptions {\n    void accept() throws Exception;\n    }\n\n/** .forEach(rethrowConsumer(name -&gt; System.out.println(Class.forName(name)))); or .forEach(rethrowConsumer(ClassNameUtil::println)); */\npublic static &lt;T&gt; Consumer&lt;T&gt; rethrowConsumer(Consumer_WithExceptions&lt;T&gt; consumer) {\n    return t -&gt; {\n    try { consumer.accept(t); }\n    catch (Exception exception) { throwAsUnchecked(exception); }\n    };\n    }\n\n/** .map(rethrowFunction(name -&gt; Class.forName(name))) or .map(rethrowFunction(Class::forName)) */\npublic static &lt;T, R&gt; Function&lt;T, R&gt; rethrowFunction(Function_WithExceptions&lt;T, R&gt; function) {\n    return t -&gt; {\n    try { return function.apply(t); }\n    catch (Exception exception) { throwAsUnchecked(exception); return null; }\n    };\n    }\n\n/** rethrowSupplier(() -&gt; new StringJoiner(new String(new byte[]{77, 97, 114, 107}, \"UTF-8\"))), */\npublic static &lt;T&gt; Supplier&lt;T&gt; rethrowSupplier(Supplier_WithExceptions&lt;T&gt; function) {\n    return () -&gt; {\n    try { return function.get(); }\n    catch (Exception exception) { throwAsUnchecked(exception); return null; }\n    };\n    }\n\n/** uncheck(() -&gt; Class.forName(\"xxx\")); */\npublic static void uncheck(Runnable_WithExceptions t)\n    {\n    try { t.accept(); }\n    catch (Exception exception) { throwAsUnchecked(exception); }\n    }\n\n/** uncheck(() -&gt; Class.forName(\"xxx\")); */\npublic static &lt;R&gt; R uncheck(Supplier_WithExceptions&lt;R&gt; supplier)\n    {\n    try { return supplier.get(); }\n    catch (Exception exception) { throwAsUnchecked(exception); return null; }\n    }\n\n/** uncheck(Class::forName, \"xxx\"); */\npublic static &lt;T, R&gt; R uncheck(Function_WithExceptions&lt;T, R&gt; function, T t) {\n    try { return function.apply(t); }\n    catch (Exception exception) { throwAsUnchecked(exception); return null; }\n    }\n\n@SuppressWarnings (\"unchecked\")\nprivate static &lt;E extends Throwable&gt; void throwAsUnchecked(Exception exception) throws E { throw (E)exception; }\n</code></pre>\n\n<p>Many other examples on how to use it (after statically importing <code>UtilException</code>):</p>\n\n<pre><code>@Test\npublic void test_Consumer_with_checked_exceptions() throws IllegalAccessException {\n    Stream.of(\"java.lang.Object\", \"java.lang.Integer\", \"java.lang.String\")\n          .forEach(rethrowConsumer(className -&gt; System.out.println(Class.forName(className))));\n\n    Stream.of(\"java.lang.Object\", \"java.lang.Integer\", \"java.lang.String\")\n          .forEach(rethrowConsumer(System.out::println));\n    }\n\n@Test\npublic void test_Function_with_checked_exceptions() throws ClassNotFoundException {\n    List&lt;Class&gt; classes1\n          = Stream.of(\"Object\", \"Integer\", \"String\")\n                  .map(rethrowFunction(className -&gt; Class.forName(\"java.lang.\" + className)))\n                  .collect(Collectors.toList());\n\n    List&lt;Class&gt; classes2\n          = Stream.of(\"java.lang.Object\", \"java.lang.Integer\", \"java.lang.String\")\n                  .map(rethrowFunction(Class::forName))\n                  .collect(Collectors.toList());\n    }\n\n@Test\npublic void test_Supplier_with_checked_exceptions() throws ClassNotFoundException {\n    Collector.of(\n          rethrowSupplier(() -&gt; new StringJoiner(new String(new byte[]{77, 97, 114, 107}, \"UTF-8\"))),\n          StringJoiner::add, StringJoiner::merge, StringJoiner::toString);\n    }\n\n@Test    \npublic void test_uncheck_exception_thrown_by_method() {\n    Class clazz1 = uncheck(() -&gt; Class.forName(\"java.lang.String\"));\n\n    Class clazz2 = uncheck(Class::forName, \"java.lang.String\");\n    }\n\n@Test (expected = ClassNotFoundException.class)\npublic void test_if_correct_exception_is_still_thrown_by_method() {\n    Class clazz3 = uncheck(Class::forName, \"INVALID\");\n    }\n</code></pre>\n\n<p><strong>But don't use it before understanding the following advantages, disadvantages, and limitations</strong>:</p>\n\n<p>• If the calling-code is to handle the checked exception you MUST add it to the throws clause of the method that contains the stream.\n The compiler will not force you to add it anymore, so it's easier to forget it.</p>\n\n<p>• If the calling-code already handles the checked exception, the compiler WILL remind you to add the throws clause to the method declaration\n that contains the stream (if you don't it will say: Exception is never thrown in body of corresponding try statement).</p>\n\n<p>• In any case, you won't be able to surround the stream itself to catch the checked exception INSIDE the method that contains the stream\n (if you try, the compiler will say: Exception is never thrown in body of corresponding try statement).</p>\n\n<p>• If you are calling a method which literally can never throw the exception that it declares, then you should not include the throws clause.\n For example: new String(byteArr, \"UTF-8\") throws UnsupportedEncodingException, but UTF-8 is guaranteed by the Java spec to always be present.\n Here, the throws declaration is a nuisance and any solution to silence it with minimal boilerplate is welcome.</p>\n\n<p>• If you hate checked exceptions and feel they should never be added to the Java language to begin with (a growing number of people think this way,\n and I am NOT one of them), then just don't add the checked exception to the throws clause of the method that contains the stream. The checked\n exception will, then, behave just like an UNchecked exception.</p>\n\n<p>• If you are implementing a strict interface where you don't have the option for adding a throws declaration, and yet throwing an exception is\n entirely appropriate, then wrapping an exception just to gain the privilege of throwing it results in a stacktrace with spurious exceptions which\n contribute no information about what actually went wrong. A good example is Runnable.run(), which does not throw any checked exceptions.\n In this case, you may decide not to add the checked exception to the throws clause of the method that contains the stream.</p>\n\n<p>• In any case, if you decide NOT to add (or forget to add) the checked exception to the throws clause of the method that contains the stream,\n be aware of these 2 consequences of throwing CHECKED exceptions:</p>\n\n<p>1) The calling-code won't be able to catch it by name (if you try, the compiler will say: Exception is never thrown in body of corresponding try\n statement). It will bubble and probably be catched in the main program loop by some \"catch Exception\" or \"catch Throwable\", which may be what you\n want anyway.</p>\n\n<p>2) It violates the principle of least surprise: it will no longer be enough to catch RuntimeException to be able to guarantee catching all\n possible exceptions. For this reason, I believe this should not be done in framework code, but only in business code that you completely control.</p>\n\n<p><strong>In conclusion: I believe the limitations here are not serious, and the <code>UtilException</code> class may be used without fear. However, it's up to you!</strong></p>\n\n<ul>\n<li>References:\n<ul>\n<li><a href=\"http://www.philandstuff.com/2012/04/28/sneakily-throwing-checked-exceptions.html\">http://www.philandstuff.com/2012/04/28/sneakily-throwing-checked-exceptions.html</a></li>\n<li><a href=\"http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html\">http://www.mail-archive.com/javaposse@googlegroups.com/msg05984.html</a></li>\n<li>Project Lombok annotation: @SneakyThrows</li>\n<li>Brian Goetz opinion (against) here: <a href=\"http://stackoverflow.com/questions/27644361/how-can-i-throw-checked-exceptions-from-inside-java-8-streams\">How can I throw CHECKED exceptions from inside Java 8 streams?</a></li>\n<li><a href=\"http://programmers.stackexchange.com/questions/225931/workaround-for-java-checked-exceptions?newreg=ddf0dd15e8174af8ba52e091cf85688e\">http://programmers.stackexchange.com/questions/225931/workaround-for-java-checked-exceptions?newreg=ddf0dd15e8174af8ba52e091cf85688e</a> *</li>\n</ul></li>\n</ul>\n    "},{"t":"Purpose of Default or Defender methods in Java 8","l":"http://stackoverflow.com/questions/19998309/purpose-of-default-or-defender-methods-in-java-8","q":"\n\n<p>Java 8 has included a new feature called <a href=\"http://java.dzone.com/articles/introduction-default-methods\">Defender methods</a> which allows creation of default method implementation in interface.</p>\n\n<p>Now first of all this is a huge paradigm shift for all condensed programmers in Java. I viewed  a JavaOne 13 presentation given by Brain Goetz where he was discussing about the new <code>stream()</code> and <code>parallelStream()</code> implementations in Collections library.</p>\n\n<p>For adding new methods in <code>Collection</code> interface, they could not have just added a new method without breaking the previous versions. So he told that for catering this a new feature of Default methods was added.</p>\n\n<pre><code>public interface SimpleInterface {\n  public void doSomeWork();\n\n  //A default method in the interface created using \"default\" keyword\n  default public void doSomeOtherWork(){\n    System.out.println(\"DoSomeOtherWork implementation in the interface\");\n  }\n}\n</code></pre>\n\n<p>Now my question is basically that are default methods just helpful when needed to add new methods to interface without breaking client code? Or are there some other uses to it too?</p>\n    ","a":"\n<p>Besides having the possibility of adding methods to the interface in future versions, there is the important point of allowing an <code>interface</code> to stay a <em>functional interface</em> even if it has more than one method.</p>\n\n<p>A functional interface has only one non-default abstract method which can be implemented via a lambda expression. One example is <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html\">the <code>Predicate</code> interface</a> which has only one abstract method (<code>test</code>) while providing default methods for negating a <code>Predicate</code> or combining it with another <code>Predicate</code>. Without default methods these methods had to be provided in another utility class like the pre-Java&nbsp;8 <code>Collections</code> class (as you don’t want to give up the possibility of lambda implementations for such an <code>interface</code>).</p>\n    "},{"t":"Why doesn't java.util.Collection implement the new Stream interface?","l":"http://stackoverflow.com/questions/24472312/why-doesnt-java-util-collection-implement-the-new-stream-interface","q":"\n\n<p>I just took some time to start looking into the java-8 buzz about streams and lambdas. What surprised me is that you cannot apply the Stream operations, like <code>.map()</code>, <code>.filter()</code> directly on a <code>java.util.Collection</code>. Is there a technical reason why the <code>java.util.Collection</code> interface was not extended with \ndefault implementations of these Stream operations?</p>\n\n<p>Googling a bit, I see lots of examples of people coding along the pattern of:</p>\n\n<pre><code>List&lt;String&gt; list = someListExpression;\nList&lt;String&gt; anotherList = list.stream().map(x -&gt; f(x)).collect(Collectors.toList());\n</code></pre>\n\n<p>which becomes very clumsy, if you have a lot of these stream-operations in your code. Since <code>.stream()</code> and <code>.collect()</code> are completely irrelevant to what you want to express, you would rather like to say:</p>\n\n<pre><code>List&lt;String&gt; list = someListExpression;\nList&lt;String&gt; anotherList = list.map(x -&gt; f(x));\n</code></pre>\n    ","a":"\n<p>Yes, there are excellent reasons for these decisions :)</p>\n\n<p>The key is the difference between <em>eager</em> and <em>lazy</em> operations.  The examples you give under the first question show eager operations where mapping or filtering a list produces a new list.  There's nothing wrong with this, but it is often not what you want, because you're often doing way more work than you need; an eager operation must operate on every element, and produce a new collection.  If you're composing multiple operations (filter-map-reduce), you're doing a lot of extra work.  On the other hand, lazy operations compose beautifully; if you do:</p>\n\n<pre><code> int tallestGuy = people.stream()\n                        .filter(p -&gt; p.getGender() == MALE)\n                        .maxBy(comparing(Person::getHeight));\n</code></pre>\n\n<p>the filter and reduce (max) operations are fused together into a single pass.  This is very efficient.  </p>\n\n<p>So, why not expose the Stream methods right on List?  Well, we tried it like that.  Among numerous other reasons, we found that mixing lazy methods like <code>filter()</code> and eager methods like <code>removeAll()</code> was confusing to users.  By grouping the lazy methods into a separate abstraction, it becomes much clearer; the methods on <code>List</code> are those that mutate the list; the methods on <code>Stream</code> are those that deal in composible, lazy operations on data sequences regardless of where that data lives.  </p>\n\n<p>So, the way you suggest it is great if you want to do really simple things, but starts to fall apart when you try to build on it.  Is the extra <code>stream()</code> method annoying?  Sure.  But keeping the abstractions for data structures (which are largely about organizing data in memory) and streams (which are largely about composing aggregate behavior) separate scales better to more sophisticated operations.  </p>\n\n<p>To your second question, you can do this relatively easily: implement the stream methods like this:</p>\n\n<pre><code>public&lt;U&gt; Stream&lt;U&gt; map(Function&lt;T,U&gt; mapper) { return convertToStream().map(mapper); }\n</code></pre>\n\n<p>But that's just swimming against the tide; better to just implement an efficient stream() method.</p>\n    "},{"t":"Java Lambdas and Closures","l":"http://stackoverflow.com/questions/11404218/java-lambdas-and-closures","q":"\n\n<p>I hear lambdas are coming soon to a Java near you (J8). I found an example of what they will look like on some blog:</p>\n\n<pre><code>SoccerService soccerService = (teamA, teamB) -&gt; {\n    SoccerResult result = null;\n    if (teamA == teamB) {\n        result = SoccerResult.DRAW;\n    }\n    else if(teamA &lt; teamB) {\n        result = SoccerResult.LOST;\n    }\n    else {\n        result = SoccerResult.WON;\n    }\n\n    return result;\n};\n</code></pre>\n\n<p>So right off the bat:</p>\n\n<ul>\n<li>Where are <code>teamA</code> and <code>teamB</code> typed? Or aren't they (like some weird form of generics)?</li>\n<li>Is a lambda a <em>type</em> of closure, or is it the other way around?</li>\n<li>What benefits will this give me over a typical anonymous function?    </li>\n</ul>\n    ","a":"\n<p>The Lambda expression is just syntactic sugar to implement a target interface, this means that you will be implementing a particular method in the interface through a lambda expression. The compiler can infer the types of the parameters in the interface and that's why you do not need to explicitly define them in the lambda expression.</p>\n\n<p>For instance:</p>\n\n<pre><code>Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareToIgnoreCase(s2);\n</code></pre>\n\n<p>In this expression, the lambda expression evidently implements a <code>Comparator</code> of strings, therefore, this implies the lambda expression is syntactic sugar for implementing <code>compare(String, String)</code>.</p>\n\n<p>Thus, the compiler can safely assume the type of <code>s1</code> and <code>s2</code> is <code>String</code>.</p>\n\n<p>Your target interface type provides all the information the compiler needs to determine what are the actual types of the lambda parameters.</p>\n\n<p>Briant Goetz, Java Language Architect at Oracle Corportion has published a couple of articles of the work in progress in JDK 8 Lambdas. I believe the answers to your questions are there:</p>\n\n<ul>\n<li><a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html\" rel=\"nofollow\">State of Lambda</a>.</li>\n<li><a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html\" rel=\"nofollow\">State of Lambda Libraries Edition</a>.</li>\n<li><a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html\" rel=\"nofollow\">Translation of Lambda Expressions</a></li>\n<li><a href=\"http://medianetwork.oracle.com/video/player/1785479333001\" rel=\"nofollow\">JVMLS 2012: Implementing Lambda Expressions in Java</a></li>\n</ul>\n\n<p>This second article explains how the lambda expressions are implemented at the bytecode level and may help you delve into the details of your second question.</p>\n    "},{"t":"Why did Java 8 introduce *Integer.sum(int a, int b)* [duplicate]","l":"http://stackoverflow.com/questions/30731055/why-did-java-8-introduce-integer-sumint-a-int-b","q":"\n\n<div class=\"question-status question-originals-of-duplicate\">\n    <p>This question already has an answer here:</p>\n    <ul>\n        <li>\n            <a href=\"/questions/28140193/purpose-of-objects-isnull-objects-nonnull\" dir=\"ltr\">Purpose of Objects.isNull(…) / Objects.nonNull(…)</a>\n                <span class=\"question-originals-answer-count\">\n                    1 answer\n                </span>\n        </li>\n    </ul>\n</div>\n<p>I just noticed that JDK8 introduced this method for <code>Integer</code> class:</p>\n\n<pre><code> /**\n * Adds two integers together as per the + operator.\n *\n * @param a the first operand\n * @param b the second operand\n * @return the sum of {@code a} and {@code b}\n * @see java.util.function.BinaryOperator\n * @since 1.8\n */\npublic static int sum(int a, int b) {\n    return a + b;\n}\n</code></pre>\n\n<p>What's the point of this method? Why should i call this method instead of using the <code>+</code> operator? The only possibility I can think of is that, for instance, when mixing strings and ints the <code>+</code> operator changes meaning, so</p>\n\n<pre><code>System.out.println(\"1\"+2+3); // prints 123\nSystem.out.println(\"1\"+Integer.sum(2,3)); // prints 15\n</code></pre>\n\n<p>but using parenthesis would work anyway</p>\n\n<pre><code>System.out.println(\"1\"+(2+3)); // prints 15\n</code></pre>\n    ","a":"\n<p>It can be useful as a method reference (<code>Integer::sum</code>) passed to a method that requires a relevant functional interface (<code>IntBinaryOperator</code>).</p>\n\n<p>For example :</p>\n\n<pre><code>int sum = IntStream.range(1,500).reduce(0,Integer::sum);\n</code></pre>\n\n<p>Of course, this example can use <code>.sum()</code> instead of reduce. I just noticed that the Javadoc for <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#sum--\">IntStream.sum</a> mention this exact reduction as being equivalent to sum().</p>\n    "},{"t":"How to use Java 8 streams to find all values preceding a larger value?","l":"http://stackoverflow.com/questions/30089761/how-to-use-java-8-streams-to-find-all-values-preceding-a-larger-value","q":"\n\n<h1>Use Case</h1>\n\n<p>Through some coding Katas posted at work, I stumbled on this problem that I'm not sure how to solve.</p>\n\n<blockquote>\n  <p>Using Java 8 Streams, given a list of positive integers, produce a\n  list of integers where the integer preceded a larger value.</p>\n\n<pre><code>[10, 1, 15, 30, 2, 6]\n</code></pre>\n  \n  <p>The above input would yield:</p>\n\n<pre><code>[1, 15, 2]\n</code></pre>\n  \n  <p>since 1 precedes 15, 15 precedes 30, and 2 precedes 6.</p>\n</blockquote>\n\n<h2>Non-Stream Solution</h2>\n\n<pre><code>public List&lt;Integer&gt; findSmallPrecedingValues(final List&lt;Integer&gt; values) {\n\n    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n    for (int i = 0; i &lt; values.size(); i++) {\n        Integer next = (i + 1 &lt; values.size() ? values.get(i + 1) : -1);\n        Integer current = values.get(i);\n        if (current &lt; next) {\n            result.push(current);\n        }\n    }\n    return result;\n}\n</code></pre>\n\n<h2>What I've Tried</h2>\n\n<p>The problem I have is I can't figure out how to access next in the lambda.</p>\n\n<pre><code>return values.stream().filter(v -&gt; v &lt; next).collect(Collectors.toList());\n</code></pre>\n\n<h2>Question</h2>\n\n<ul>\n<li>Is it possible to retrieve the next value in a stream?</li>\n<li>Should I be using <code>map</code> and mapping to a <code>Pair</code> in order to access next?</li>\n</ul>\n    ","a":"\n<p>Using <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#range-int-int-\"><code>IntStream.range</code></a>:</p>\n\n<pre><code>static List&lt;Integer&gt; findSmallPrecedingValues(List&lt;Integer&gt; values) {\n    return IntStream.range(0, values.size() - 1)\n        .filter(i -&gt; values.get(i) &lt; values.get(i + 1))\n        .mapToObj(values::get)\n        .collect(Collectors.toList());\n}\n</code></pre>\n\n<p>It's certainly nicer than an imperative solution with a large loop, but still a bit meh as far as the goal of \"using a stream\" in an idiomatic way.</p>\n\n<blockquote>\n  <p>Is it possible to retrieve the next value in a stream?</p>\n</blockquote>\n\n<p>Nope, not really. The best cite I know of for that is in the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description\"><code>java.util.stream</code> package description</a>:</p>\n\n<blockquote>\n  <p>The elements of a stream are only visited once during the life of a stream. Like an <code>Iterator</code>, a new stream must be generated to revisit the same elements of the source.</p>\n</blockquote>\n\n<p>(Retrieving elements besides the current element being operated on would imply they could be visited more than once.)</p>\n\n<p>We could also technically do it in a couple other ways:</p>\n\n<ul>\n<li>Statefully (very meh).</li>\n<li>Using a stream's <code>iterator</code> is <em>technically</em> still using the stream.</li>\n</ul>\n    "},{"t":"Can you split a stream into two streams?","l":"http://stackoverflow.com/questions/19940319/can-you-split-a-stream-into-two-streams","q":"\n\n<p>I have a data set represented by a Java 8 stream:</p>\n\n<pre><code>Stream&lt;T&gt; stream = ...;\n</code></pre>\n\n<p>I can see how to filter it to get a random subset - for example</p>\n\n<pre><code>Random r = new Random();\nPrimitiveIterator.OfInt coin = r.ints(0, 2).iterator();   \nStream&lt;T&gt; heads = stream.filter((x) -&gt; (coin.nextInt() == 0));\n</code></pre>\n\n<p>I can also see how I could reduce this stream to get, for example, two lists representing two random halves of the data set, and then turn those back into streams.\nBut, is there a direct way to generate two streams from the initial one? Something like</p>\n\n<pre><code>(heads, tails) = stream.[some kind of split based on filter]\n</code></pre>\n\n<p>Thanks for any insight.</p>\n    ","a":"\n<p>Not exactly.  You can't get two <code>Stream</code>s out of one; this doesn't make sense -- how would you iterate over one without needing to generate the other at the same time?  A stream can only be operated over once.</p>\n\n<p>However, if you want to dump them into a list or something, you could do</p>\n\n<pre><code>stream.forEach((x) -&gt; ((x == 0) ? heads : tails).add(x));\n</code></pre>\n    "},{"t":"Java Generic code","l":"http://stackoverflow.com/questions/31638904/java-generic-code","q":"\n\n<p>I am new to generics, You can see I am repeating some code after knowing the exact type of val, filterSmall, filterGreat. I want to write generic code for comparing val against filter values. I could write something like this </p>\n\n<pre><code>  private  &lt;T&gt; boolean  compareAgainstFilters(T val, T filterSmall, T filterGreat) {\n    if (!(filterSmall != null &amp;&amp; filterSmall &lt;= val)) {\n        return true;\n    } \n\n    if (!(filterGreat != null &amp;&amp; val &lt;= filterGreat)) {\n        return true;\n    }\n    return true;\n}\n</code></pre>\n\n<p>but at compile time, java wouldn't know if &lt;= operator is valid for type T.\nI don't want to repeat the code, how can I achieve that ?</p>\n\n<pre><code>if (value != null) {\n        switch (value.getClass().getName()) {\n        case \"java.lang.Long\":\n            Long filterSmall = (Long) filterSmaller;\n            Long filterGreat = (Long) filterGreater;\n            Long val = (Long) value;\n\n            if (!(filterSmall != null &amp;&amp; filterSmall &lt;= val)) {\n                return true;\n            } \n\n            if (!(filterGreat != null &amp;&amp; val &lt;= filterGreat)) {\n                return true;\n            }\n            break;\n\n        case \"java.lang.Float\":\n            Float filterSmallFloat = (Float) filterSmaller;\n            Float filterGreatFloat = (Float) filterGreater;\n            Float valFloat = (Float) value;\n\n            if (!(filterSmallFloat != null &amp;&amp; filterSmallFloat &lt;= valFloat)) {\n                return true;\n            } \n\n            if (!(filterGreatFloat != null &amp;&amp; valFloat &lt;= filterGreatFloat)) {\n                return true;\n            }\n        }\n    }\n</code></pre>\n    ","a":"\n<p>You can use the <code>Comparable</code> interface for comparing numbers, since all the wrapper classes of numeric primitives implement it :</p>\n\n<pre><code>  private  &lt;T extends Comparable&lt;T&gt;&gt; boolean  compareAgainstFilters(T val, T filterSmall, T filterGreat) {\n    if (!(filterSmall != null &amp;&amp; filterSmall.compareTo(val)&lt;=0)) {\n        return true;\n    } \n\n    if (!(filterGreat != null &amp;&amp; val.compareTo(filterGreat)&lt;=0)) {\n        return true;\n    }\n    return true;\n}\n</code></pre>\n\n<p><code>&lt;T extends Comparable&lt;T&gt;&gt;</code> restricts the types that can be used as type arguments instead of T. In this case they are required to implement <code>Comparable&lt;T&gt;</code>.</p>\n    "},{"t":"java 8 parallelStream() with sorted()","l":"http://stackoverflow.com/questions/19529982/java-8-parallelstream-with-sorted","q":"\n\n<p>JDK 8 EA is out now, and I am just trying to get used to the lambda and the new Stream API. I've tried to sort a list with parallel stream, but the result is always wrong:</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\n\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"C\");\n        list.add(\"H\");\n        list.add(\"A\");\n        list.add(\"A\");\n        list.add(\"B\");\n        list.add(\"F\");\n        list.add(\"\");\n\n        list.parallelStream() // in parallel, not just concurrently!\n            .filter(s -&gt; !s.isEmpty()) // remove empty strings\n            .distinct() // remove duplicates\n            .sorted() // sort them\n            .forEach(s -&gt; System.out.println(s)); // print each item\n    }\n}\n</code></pre>\n\n<p><strong>OUTPUT:</strong></p>\n\n<pre><code>C\nF\nB\nH\nA\n</code></pre>\n\n<p>Note that each time the output is different. My questions is, is it a bug? or is it not possible to sort a list in parallel? if so, then why the JavaDoc doesn't state that? Last question, is there another operation whose output would differ depending on the stream type?</p>\n    ","a":"\n<p>You need to use <code>forEachOrdered</code>, not <code>forEach</code>.</p>\n\n<p>As per the <code>forEach</code> doc:</p>\n\n<blockquote>\n  <p>For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.</p>\n</blockquote>\n    "},{"t":"In Java 8 how do I transform a Map<K,V> to another Map<K,V> using a lambda?","l":"http://stackoverflow.com/questions/22742974/in-java-8-how-do-i-transform-a-mapk-v-to-another-mapk-v-using-a-lambda","q":"\n\n<p>I've just started looking at Java 8 and to try out lambdas I thought I'd try to rewrite a very simple thing I wrote recently.  I need to turn a Map of String to Column into another Map of String to Column where the Column in the new Map is a defensive copy of the Column in the first Map.  Column has a copy constructor.  The closest I've got so far is:</p>\n\n<pre><code>    Map&lt;String, Column&gt; newColumnMap= new HashMap&lt;&gt;();\n    originalColumnMap.entrySet().stream().forEach(x -&gt; newColumnMap.put(x.getKey(), new Column(x.getValue())));\n</code></pre>\n\n<p>but I'm sure there must be a nicer way to do it and I'd be grateful for some advice.</p>\n    ","a":"\n<p>You could use a <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html\">Collector</a>:</p>\n\n<pre><code>import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Defensive {\n\n  public static void main(String[] args) {\n    Map&lt;String, Column&gt; original = new HashMap&lt;&gt;();\n    original.put(\"foo\", new Column());\n    original.put(\"bar\", new Column());\n\n    Map&lt;String, Column&gt; copy = original.entrySet()\n        .stream()\n        .collect(Collectors.toMap(Map.Entry::getKey,\n                                  e -&gt; new Column(e.getValue())));\n\n    System.out.println(original);\n    System.out.println(copy);\n  }\n\n  static class Column {\n    public Column() {}\n    public Column(Column c) {}\n  }\n}\n</code></pre>\n    "},{"t":"Why can't I use from the static method of the implemented interface?","l":"http://stackoverflow.com/questions/27471284/why-cant-i-use-from-the-static-method-of-the-implemented-interface","q":"\n\n<p>As you, specialists, know in Java 8, interfaces can have static methods which have implementations inside themselves.</p>\n\n<p>As I have read in a related tutorial, the classes which implement such interface can use its static methods. But, I have a problem which, here, I show it in a simpler example than what I have</p>\n\n<pre><code>public interface Interface1{\n    public static void printName(){\n        System.out.println(\"Interface1\");\n    }\n}\n</code></pre>\n\n<p>when I implement such interface</p>\n\n<pre><code>public class Class1 implements Interface1{\n    public void doSomeThing() {\n        printName();\n    }\n}\n</code></pre>\n\n<p>I encounter compile error.</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>The method printName() is undefined for the type Class1\n</code></pre>\n\n<p>What's the problem?</p>\n    ","a":"\n<p><a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.8\" rel=\"nofollow\">From the Java Language Specification</a>,</p>\n\n<blockquote>\n  <p>A class C inherits from its direct superclass all concrete methods m\n  (both static and instance) of the superclass for which all of the\n  following are true:</p>\n  \n  <ul>\n  <li>[...]</li>\n  </ul>\n  \n  <p>A class C inherits from its direct superclass and direct\n  superinterfaces all abstract and default (§9.4) methods m for which\n  all of the following are true:</p>\n  \n  <ul>\n  <li>[...]</li>\n  </ul>\n  \n  <p><strong>A class does not inherit static methods from its superinterfaces.</strong> </p>\n</blockquote>\n\n<p>So that method is not inherited. </p>\n\n<p>You can statically import the member</p>\n\n<pre><code>import static com.example.Interface1.printName;\n...\nprintName();\n</code></pre>\n\n<p>or use it with the fully qualified type name</p>\n\n<pre><code>com.example.Interface1.printName();\n</code></pre>\n\n<p>or import the type to which <code>printName</code> belongs and invoke it with its short name</p>\n\n<pre><code>import static com.example.Interface1;\n...\nInterface1.printName();\n</code></pre>\n    "},{"t":"Java 8 Double curly bracket initialization and name collision","l":"http://stackoverflow.com/questions/26913341/java-8-double-curly-bracket-initialization-and-name-collision","q":"\n\n<p>The following class has an inner class called <code>Entry</code>. This code will not compile in Java 8 as the compiler assumes the <code>Entry</code> referenced within the double curly brace initializer is of type <code>Map.Entry</code> and not <code>Scope.Entry</code>. This code compiles in previous versions (at least 6 and 7) of the JDK but is broken in JDK 8. My question is \"why?\" <code>Map.Entry</code> is not imported in this class, so there is no reason for the compiler to assume that the value is of type <code>Map.Entry</code>. Is there some implicit scope being brought in or something for anonymous classes? </p>\n\n<p><strong>Error:</strong></p>\n\n<pre><code>scope/Scope.java:23: error: incompatible types: scope.Scope.Entry cannot be converted to java.util.Map.Entry for (final Entry entry : entries) {\nscope/Scope.java:22: error: cannot find symbol put(entry.getName(), entry);\n</code></pre>\n\n<p><strong>Example Code:</strong></p>\n\n<pre><code>package scope;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Scope {\n\n    public static class Entry&lt;T&gt; {\n        public String getName() {\n            return \"Scope\";\n        }\n    }\n\n    public static void main(String[] args) {\n        final Set&lt;Entry&gt; entries = new HashSet&lt;&gt;();\n\n        new HashMap&lt;String, Entry&gt;() {{\n            // Why does the Java 8 compiler assume this is a Map.Entry\n            // as it is not imported? \n            for (final Entry entry : entries) {\n                put(entry.getName(), entry);\n            }\n        }};\n    }\n}\n</code></pre>\n    ","a":"\n<p>It's definitely not a bug, it is entirely because of the anonymous inner class inheriting from <code>HashMap</code>:</p>\n\n<pre><code>new HashMap&lt;String, Entry&gt;() {{\n    for (final Entry entry : entries) {\n        put(entry.getName(), entry);\n    }\n}};\n</code></pre>\n\n<p>It's a side-effect of using double-brace initialization.  What you're doing is creating an anonymous class that extends <code>HashMap</code> within your <code>Scope</code> class.  When you refer to <code>Entry</code> in this scope, it's looking at <code>java.util.Map.Entry</code>.  This is explained by <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.4.1\">shadowing</a>.</p>\n\n<p>From <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.6\">8.1.6. Class Body and Member Declarations</a></p>\n\n<blockquote>\n  <p>If C itself is a nested class, there may be definitions of the same\n  kind (variable, method, or type) and name as m in enclosing scopes.\n  (The scopes may be blocks, classes, or packages.) In all such cases,\n  the member m declared in <strong>or inherited by C</strong> shadows (§6.4.1) the other\n  definitions of the same kind and name. <em>[emphasis mine]</em></p>\n</blockquote>\n\n<p>Here, <code>C</code> is the anonymous inner class declared.  Since it inherits from <code>HashMap</code>, <code>java.util.Map.Entry</code> shadows <code>scope.Scope.Entry</code>.</p>\n\n<p>As for why it compiled as you wanted it to with previous versions, I have no idea.  This behavior was present in those versions (the docs I referenced are from <code>7</code>), so it shouldn't have worked.  So maybe those versions are bugged.</p>\n    "},{"t":"Spring 4 and Java 8 Invalid byte tag exception","l":"http://stackoverflow.com/questions/23801950/spring-4-and-java-8-invalid-byte-tag-exception","q":"\n\n<p>I am trying to run a simple JUnit test using Spring and Java 8 JDK:</p>\n\n<pre><code>@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\n@WebAppConfiguration\npublic class UserServicesTest{\n\n  @Test\n  public void testJava8() {\n    Set&lt;String&gt; strings = new HashSet&lt;&gt;();\n    strings.add(\"a\");\n    strings.add(\"b\");\n    strings.add(\"c\");\n    strings.stream().filter(a -&gt; a.equals(\"a\")).forEach(p -&gt; p.toString());\n  }\n</code></pre>\n\n<p>And I get this runtime error on startup:</p>\n\n<pre><code>org.aspectj.apache.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 18\n    at org.aspectj.apache.bcel.classfile.Constant.readConstant(Constant.java:133)\n    at org.aspectj.apache.bcel.classfile.ConstantPool.&lt;init&gt;(ConstantPool.java:45)\n    at org.aspectj.apache.bcel.classfile.ClassParser.readConstantPool(ClassParser.java:186)\n    at org.aspectj.apache.bcel.classfile.ClassParser.parse(ClassParser.java:131)\n    at org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository.loadJavaClass(NonCachingClassLoaderRepository.java:262)\n    at org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository.loadClass(NonCachingClassLoaderRepository.java:242)\n    at org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository.loadClass(NonCachingClassLoaderRepository.java:249)\n    at org.aspectj.weaver.reflect.Java15AnnotationFinder.getAnnotations(Java15AnnotationFinder.java:202)\n    at org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl.unpackAnnotations(ReflectionBasedResolvedMemberImpl.java:211)\n    at org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl.hasAnnotation(ReflectionBasedResolvedMemberImpl.java:163)\n    at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:109)\n    at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:96)\n    at org.aspectj.weaver.patterns.AnnotationPointcut.matchInternal(AnnotationPointcut.java:156)\n    at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)\n    at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.getShadowMatch(PointcutExpressionImpl.java:239)\n    at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesExecution(PointcutExpressionImpl.java:105)\n    at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesMethodExecution(PointcutExpressionImpl.java:96)\n    at org.springframework.aop.aspectj.AspectJExpressionPointcut.getShadowMatch(AspectJExpressionPointcut.java:404)\n    at org.springframework.aop.aspectj.AspectJExpressionPointcut.matches(AspectJExpressionPointcut.java:271)\n    at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:224)\n    at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:262)\n    at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:294)\n    at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:118)\n    at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:88)\n    at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:69)\n    at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:376)\n    at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:339)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:421)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1558)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:398)\n    at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:111)\n    at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:75)\n    at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:331)\n    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:213)\n    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:290)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:292)\n    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:233)\n    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:87)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)\n    at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)\n    at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:236)\n    at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:176)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:157)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)\n</code></pre>\n\n<p>I am using those aop libraries:</p>\n\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;\n  &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;\n  &lt;version&gt;1.6.11&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;\n  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;\n  &lt;version&gt;1.6.11&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n\n<p>Any idea?</p>\n    ","a":"\n<p>You need <code>aspectJ</code> 1.8 to get Java 8 support.</p>\n    "},{"t":"How to create a List<T> from Map<K,V> and List<K> of keys?","l":"http://stackoverflow.com/questions/30538647/how-to-create-a-listt-from-mapk-v-and-listk-of-keys","q":"\n\n<p>Using Java 8 lambdas, what's the \"best\" way to effectively create a new <code>List&lt;T&gt;</code> given a <code>List&lt;K&gt;</code> of possible keys and a <code>Map&lt;K,V&gt;</code>?  This is the scenario where you are given a <code>List</code> of possible <code>Map</code> keys and are expected to generate a <code>List&lt;T&gt;</code> where <code>T</code> is some type that is constructed based on some aspect of <code>V</code>, the map value types.  </p>\n\n<p>I've explored a few and don't feel comfortable claiming one way is better than another (with maybe one exception -- see code).  I'll clarify \"best\" as a combination of code clarity and runtime efficiency.  These are what I came up with.  I'm sure someone can do better, which is one aspect of this question.  I don't like the <code>filter</code> aspect of most as it means needing to create intermediate structures and multiple passes over the names <code>List</code>.  Right now, I'm opting for Example 6 -- a plain 'ol loop.  (<em>NOTE: Some cryptic thoughts are in the code comments, especially \"need to reference externally...\" This means external from the lambda.</em>)</p>\n\n<pre><code>public class Java8Mapping {\n    private final Map&lt;String,Wongo&gt; nameToWongoMap = new HashMap&lt;&gt;();\n    public Java8Mapping(){\n        List&lt;String&gt; names = Arrays.asList(\"abbey\",\"normal\",\"hans\",\"delbrook\");\n        List&lt;String&gt; types = Arrays.asList(\"crazy\",\"boring\",\"shocking\",\"dead\");\n        for(int i=0; i&lt;names.size(); i++){\n            nameToWongoMap.put(names.get(i),new Wongo(names.get(i),types.get(i)));\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"in main\");\n        Java8Mapping j = new Java8Mapping();\n        List&lt;String&gt; testNames = Arrays.asList(\"abbey\", \"froderick\",\"igor\");\n        System.out.println(j.getBongosExample1(testNames).stream().map(Bongo::toString).collect(Collectors.joining(\", \")));\n        System.out.println(j.getBongosExample2(testNames).stream().map(Bongo::toString).collect(Collectors.joining(\", \")));\n        System.out.println(j.getBongosExample3(testNames).stream().map(Bongo::toString).collect(Collectors.joining(\", \")));\n        System.out.println(j.getBongosExample4(testNames).stream().map(Bongo::toString).collect(Collectors.joining(\", \")));\n        System.out.println(j.getBongosExample5(testNames).stream().map(Bongo::toString).collect(Collectors.joining(\", \")));\n        System.out.println(j.getBongosExample6(testNames).stream().map(Bongo::toString).collect(Collectors.joining(\", \")));\n    }\n\n    private static class Wongo{\n        String name;\n        String type;\n        public Wongo(String s, String t){name=s;type=t;}\n        @Override public String toString(){return \"Wongo{name=\"+name+\", type=\"+type+\"}\";}\n    }\n\n    private static class Bongo{\n        Wongo wongo;\n        public Bongo(Wongo w){wongo = w;}\n        @Override public String toString(){ return \"Bongo{wongo=\"+wongo+\"}\";}\n    }\n\n    // 1:  Create a list externally and add items inside 'forEach'.\n    //     Needs to externally reference Map and List\n    public List&lt;Bongo&gt; getBongosExample1(List&lt;String&gt; names){\n        final List&lt;Bongo&gt; listOne = new ArrayList&lt;&gt;();\n        names.forEach(s -&gt; {\n                  Wongo w = nameToWongoMap.get(s);\n                  if(w != null) {\n                      listOne.add(new Bongo(nameToWongoMap.get(s)));\n                  }\n              });\n        return listOne;\n    }\n\n    // 2: Use stream().map().collect()\n    //    Needs to externally reference Map\n    public List&lt;Bongo&gt; getBongosExample2(List&lt;String&gt; names){\n        return names.stream()\n              .filter(s -&gt; nameToWongoMap.get(s) != null)\n              .map(s -&gt; new Bongo(nameToWongoMap.get(s)))\n              .collect(Collectors.toList());\n    }\n\n    // 3: Create custom Collector\n    //    Needs to externally reference Map\n    public List&lt;Bongo&gt; getBongosExample3(List&lt;String&gt; names){\n        Function&lt;List&lt;Wongo&gt;,List&lt;Bongo&gt;&gt; finisher = list -&gt; list.stream().map(Bongo::new).collect(Collectors.toList());\n        Collector&lt;String,List&lt;Wongo&gt;,List&lt;Bongo&gt;&gt; bongoCollector =\n              Collector.of(ArrayList::new,getAccumulator(),getCombiner(),finisher, Characteristics.UNORDERED);\n\n        return names.stream().collect(bongoCollector);\n    }\n    // example 3 helper code\n    private BiConsumer&lt;List&lt;Wongo&gt;,String&gt; getAccumulator(){\n        return (list,string) -&gt; {\n            Wongo w = nameToWongoMap.get(string);\n            if(w != null){\n                list.add(w);\n            }\n        };\n    }\n    // example 3 helper code\n    private BinaryOperator&lt;List&lt;Wongo&gt;&gt; getCombiner(){\n        return (l1,l2) -&gt; {\n            l1.addAll(l2);\n            return l1;\n        };\n    }\n\n    // 4: Use internal Bongo creation facility\n    public List&lt;Bongo&gt; getBongosExample4(List&lt;String&gt; names){\n        return names.stream().filter(s-&gt;nameToWongoMap.get(s) != null).map(s-&gt; new Bongo(nameToWongoMap.get(s))).collect(Collectors.toList());\n    }\n\n    // 5: Stream the Map EntrySet.  This avoids referring to anything outside of the stream, \n    // but bypasses the lookup benefit from Map.\n    public List&lt;Bongo&gt; getBongosExample5(List&lt;String&gt; names){\n        return nameToWongoMap.entrySet().stream().filter(e-&gt;names.contains(e.getKey())).map(e -&gt; new Bongo(e.getValue())).collect(Collectors.toList());\n    }\n\n    // 6: Plain-ol-java loop\n    public List&lt;Bongo&gt; getBongosExample6(List&lt;String&gt; names){\n        List&lt;Bongo&gt; bongos = new ArrayList&lt;&gt;();\n        for(String s : names){\n            Wongo w = nameToWongoMap.get(s);\n            if(w != null){\n                bongos.add(new Bongo(w));\n            }\n        }\n        return bongos;\n    }\n}\n</code></pre>\n    ","a":"\n<p>If <code>namesToWongoMap</code> is an instance variable, you can't really avoid a capturing lambda.</p>\n\n<p>You can clean up the stream by splitting up the operations a little more:</p>\n\n\n\n<pre class=\"lang-java prettyprint-override\"><code>return names.stream()\n    .map(n -&gt; namesToWongoMap.get(n))\n    .filter(w -&gt; w != null)\n    .map(w -&gt; new Bongo(w))\n    .collect(toList());\n</code></pre>\n\n\n\n<pre class=\"lang-java prettyprint-override\"><code>return names.stream()\n    .map(namesToWongoMap::get)\n    .filter(Objects::nonNull)\n    .map(Bongo::new)\n    .collect(toList());\n</code></pre>\n\n<p>That way you don't call <code>get</code> twice.</p>\n\n<p>This is very much like the <code>for</code> loop, except, for example, it could theoretically be parallelized if <code>namesToWongoMap</code> can't be mutated concurrently.</p>\n\n<blockquote>\n  <p>I don't like the <code>filter</code> aspect of most as it means needing to create intermediate structures and multiple passes over the names <code>List</code>.</p>\n</blockquote>\n\n<p>There are no intermediate structures and there is only one pass over the <code>List</code>. A stream pipeline says \"for each element...do this sequence of operations\". Each element is visited once and the pipeline is applied.</p>\n\n<p>Here are some relevant quotes from the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description\"><code>java.util.stream</code> package description</a>:</p>\n\n<blockquote>\n  <p>A stream is not a data structure that stores elements; instead, it conveys elements from a source such as a data structure, an array, a generator function, or an I/O channel, through a pipeline of computational operations.</p>\n  \n  <p>Processing streams lazily allows for significant efficiencies; in a pipeline such as the filter-map-sum example above, filtering, mapping, and summing can be fused into a single pass on the data, with minimal intermediate state.</p>\n</blockquote>\n    "},{"t":"Why does lambda translation need generation of a static method?","l":"http://stackoverflow.com/questions/30014200/why-does-lambda-translation-need-generation-of-a-static-method","q":"\n\n<p>Lambda translation is a two step process, <strong>One</strong>: desugaring the lambda into a static method in same class.</p>\n\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        Runnable r = () -&gt; System.out.println(\"Hello\");\n        System.out.println(Arrays.asList(Main.class.getDeclaredMethods()));\n    }\n}\n</code></pre>\n\n<blockquote>\n  <p>[<strong>private static void Main.lambda$main$0()</strong>, public static void\n  Main.main(java.lang.String[])]</p>\n</blockquote>\n\n<p><strong>Two</strong>: generation of a class that implements the Functional Interface.</p>\n\n<pre><code>System.out.println(\"A class has been generated: \" + r.getClass());\nSystem.out.println(\"That implements a Functional Interface: \" + Arrays.asList(r.getClass().getInterfaces()));\n</code></pre>\n\n<blockquote>\n  <p>A class has been generated: class Main$$Lambda$1/149928006 </p>\n  \n  <p>That implements a Functional Interface: [interface java.lang.Runnable]</p>\n</blockquote>\n\n<p><strong>Question</strong>: <strong>What is the need of this static method?</strong> Why can't the lambda body be put directly into the interface method? Something like: </p>\n\n<pre><code>class Main$$Lambda$1 {\n    public void run() {\n        /* Lambda body here */\n    }\n}\n</code></pre>\n    ","a":"\n<p>In addition to the correct answers given here (because the current scheme is more efficient, reducing capture/linkage costs for lambdas and reducing code duplication), there are a few other reasons why your idea simply doesn't make sense.</p>\n\n<ul>\n<li>Where would the bytecode come from in the first place?  The lambda proxy class is generated at runtime, not compile time.  If we were to stuff the bytecode into the proxy class, it would have to come from somewhere.  That would mean we'd have to put it into the capturing class file <em>and then copy</em> it into the proxy class.  Here, it just lives in the capturing class and we're done.  </li>\n<li>Access control.  What if the lambda body calls a private method?  By desugaring it into the capturing class, it automatically acquires the access control context of the capturing class (which it is logically a part of.)  If we put the bytecode in the proxy class, we'd have to do additional magic to give it the right access control context.</li>\n</ul>\n    "},{"t":"JPA support for Java 8 new date and time API","l":"http://stackoverflow.com/questions/23718383/jpa-support-for-java-8-new-date-and-time-api","q":"\n\n<p>I'm using Java 8 for my new project.</p>\n\n<p>I'm trying to use new date and time api in java 8 however I don't know if <code>JPA 2.1</code> fully supports this new Date and Time API or not.</p>\n\n<p>Please share your experience/opinion in JPA`s supports for new date and time API in Java 8.</p>\n\n<p><strong>Can I use new date and time api in Java 8 safely with JPA 2.1?</strong></p>\n\n<p><strong>UPDATE:</strong></p>\n\n<p>I'm using Hibernate (4.3.5.Final) as JPA implementation.</p>\n    ","a":"\n<p>JPA 2.1 is a spec that came out before Java 1.8, so doesn't mandate any support for it. Obviously some implementations may support some Java 1.8 features. Some have problems with Java 1.8 bytecode (e.g EclipseLink). I know DataNucleus supports java.time and Java 1.8 since that's the one I use. You'd have to check your implementation for what its support level is</p>\n    "},{"t":"Constructor reference for inner class fails with VerifyError at runtime","l":"http://stackoverflow.com/questions/22738962/constructor-reference-for-inner-class-fails-with-verifyerror-at-runtime","q":"\n\n<p>I am creating a supplier for an inner class constructor using the lambda <code>ctx -&gt; new SpectatorSwitcher(ctx)</code>. IntelliJ suggested that I change it to <code>SpectatorSwitcher::new</code> instead. SpectatorSwitcher is a non-static inner class of the class I'm working in. The suggested code compiles fine (using maven) but I get the following VerifyError on execution:</p>\n\n<pre><code>Exception in thread \"main\" java.lang.VerifyError: Bad type on operand stack\nException Details:\n  Location:\n    Test.lambda$runTest$8(LTest$Worker;)V @2: invokedynamic\n  Reason:\n    Type 'Test$Worker' (current frame, stack[1]) is not assignable to 'Test'\n  Current Frame:\n    bci: @2\n    flags: { }\n    locals: { 'Test$Worker' }\n    stack: { 'Test$Worker', 'Test$Worker' }\n  Bytecode:\n    0000000: 2a2a ba00 0b00 00b6 000c b1            \n\n    at java.lang.Class.getDeclaredMethods0(Native Method)\n    at java.lang.Class.privateGetDeclaredMethods(Class.java:2688)\n    at java.lang.Class.getMethod0(Class.java:2937)\n    at java.lang.Class.getMethod(Class.java:1771)\n    at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)\n    at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)\n</code></pre>\n\n<p>Why is javac / maven not failing while compiling but still producing invalid byte code?</p>\n\n<p><strong>Edit:</strong> The problem appears to be far more complex than the simple call, this is the code needed to reproduce it:</p>\n\n<pre><code>import java.util.function.Function;\n\n/**\n * @author Yawkat\n */\npublic class Test {\n    public static void main(String[] args) { new Test().runTest(); }\n\n    private void runTest() {\n        Worker worker = new Worker();\n        run(() -&gt; worker.print(field -&gt; new SomeClass(field)));\n        run(() -&gt; worker.print(SomeClass::new));\n    }\n\n    private void run(Runnable runnable) {\n        runnable.run();\n    }\n\n    private class SomeClass {\n        final Object field;\n\n        SomeClass(Object field) {\n            this.field = field;\n        }\n    }\n\n    private static class Worker {\n        void print(Function&lt;Object, Object&gt; i) {\n            System.out.println(i.apply(null));\n        }\n    }\n}\n</code></pre>\n    ","a":"\n<p>Even after smacking my head into the bytecode for almost an hour, I've not been able to come to a reasonable conclusion as to why this is happening. Surprisingly, changing your method to this:</p>\n\n<pre><code>private void runTest() {\n    Worker worker = new Worker();\n    run(() -&gt; worker.print(field -&gt; new SomeClass(field)));\n    Function&lt;Object, Object&gt; function = SomeClass::new;\n    run(() -&gt; worker.print(function));\n}\n</code></pre>\n\n<p>works fine. Also, getting rid of <code>run()</code> method invocation, and just calling <code>worker.print()</code>:</p>\n\n<pre><code>private void runTest() {\n    Worker worker = new Worker();\n    worker.print(field -&gt; new SomeClass(field));\n    worker.print(SomeClass::new);\n}\n</code></pre>\n\n<p>also works. </p>\n\n<p>It seems like, using the constructor reference as in your case is not able to pass the enclosing instance of <code>Test</code> class to the <code>SomeClass</code> constructor which is required. While the two cases here are able to pass <code>Test</code> instance to the <code>SomeClass</code> constructor.</p>\n\n<p>But I couldn't come to the exact reason. The above reasoning might very well be wrong. But I've just come to that after getting to those working approach.</p>\n\n<p>You might want to go through <a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html\">lambda translation</a>, to understand the inner working. I'm still not very much clear about how lambdas and method references are translated.</p>\n\n<p>I found a <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2012-September/005938.html\">thread in lambda mailing list</a> about similar issue. Also, <a href=\"http://stackoverflow.com/q/13219297/1679863\">this SO post</a> is also related.</p>\n\n<p>The following <code>runtTest()</code> method:</p>\n\n<pre><code>public void runTest() {\n    Worker worker = new Worker();\n    run(() -&gt; worker.print((field) -&gt; new SomeClass(field)));\n    run(() -&gt; worker.print(SomeClass::new));\n\n    Function&lt;Object, Object&gt; func = SomeClass::new;\n    run(() -&gt; worker.print(func));\n\n    worker.print(SomeClass::new);\n}\n</code></pre>\n\n<p>Is compiled to following bytecode:</p>\n\n<pre><code>  public void runTest();\n    Code:\n       0: new           #2                  // class SO$Worker\n       3: dup\n       4: invokespecial #3                  // Method SO$Worker.\"&lt;init&gt;\":()V\n       7: astore_1\n       8: aload_0\n       9: aload_0\n      10: aload_1\n      11: invokedynamic #4,  0              // InvokeDynamic #0:run:(LSO;LSO$Worker;)Ljava/lang/Runnable;\n      16: invokevirtual #5                  // Method run:(Ljava/lang/Runnable;)V\n      19: aload_0\n      20: aload_1\n      21: invokedynamic #6,  0              // InvokeDynamic #1:run:(LSO$Worker;)Ljava/lang/Runnable;\n      26: invokevirtual #5                  // Method run:(Ljava/lang/Runnable;)V\n      29: aload_0\n      30: invokedynamic #7,  0              // InvokeDynamic #2:apply:(LSO;)Ljava/util/function/Function;\n      35: astore_2\n      36: aload_0\n      37: aload_1\n      38: aload_2\n      39: invokedynamic #8,  0              // InvokeDynamic #3:run:(LSO$Worker;Ljava/util/function/Function;)Ljava/lang/Runnable;\n      44: invokevirtual #5                  // Method run:(Ljava/lang/Runnable;)V\n      47: aload_1\n      48: aload_0\n      49: invokedynamic #7,  0              // InvokeDynamic #2:apply:(LSO;)Ljava/util/function/Function;\n      54: invokevirtual #9                  // Method SO$Worker.print:(Ljava/util/function/Function;)V\n      57: return\n</code></pre>\n\n<p>I can see only the second <code>run()</code> method invocation doesn't pass <code>LSO</code> argument, while others do pass it. You can run the command - <code>javap -c -s -verbose Test</code>, to see Bootstrap methods for <code>#0</code>, <code>#1</code>, etc. I guess we can definitely say that this is a bug. Perhaps you can file one.</p>\n    "},{"t":"Java 8 Lambda Expressions - what about multiple methods in nested class","l":"http://stackoverflow.com/questions/21833537/java-8-lambda-expressions-what-about-multiple-methods-in-nested-class","q":"\n\n<p>I'm reading about the new features at: <a href=\"http://www.javaworld.com/article/2078836/java-se/love-and-hate-for-java-8.html\">http://www.javaworld.com/article/2078836/java-se/love-and-hate-for-java-8.html</a></p>\n\n<p>I saw the example below:</p>\n\n<p><strong>Using Anonymous Class:</strong></p>\n\n<pre><code>button.addActionListener(new ActionListener() {\n  public void actionPerformed(ActionEvent ae) {\n    System.out.println(“Action Detected”);\n  }\n});\n</code></pre>\n\n<p><strong>With Lambda:</strong></p>\n\n<pre><code>button.addActionListener(e -&gt; {\n  System.out.println(“Action Detected”);\n});\n</code></pre>\n\n<p>What would someone do with a <code>MouseListener</code> if they wanted to implement multiple methods within the anonymous class, e.g.:</p>\n\n<pre><code>public void mousePressed(MouseEvent e) {\n  saySomething(\"Mouse pressed; # of clicks: \"\n               + e.getClickCount(), e);\n}\n\npublic void mouseReleased(MouseEvent e) {\n  saySomething(\"Mouse released; # of clicks: \"\n               + e.getClickCount(), e);\n}\n... and on..\n</code></pre>\n    ","a":"\n<p>From <a href=\"http://cr.openjdk.java.net/~mr/se/8/java-se-8-pfd-spec/java-se-8-jls-pfd-diffs.pdf\">JLS 9.8</a></p>\n\n<blockquote>\n  <p>A functional interface is an interface that has just one abstract method, and thus\n  represents a single function contract.</p>\n</blockquote>\n\n<p>Lambdas require these functional interfaces so are restricted to their single method. Anonymous interfaces still need to be used for implementing multi-method interfaces. </p>\n\n<pre><code>addMouseListener(new MouseAdapter() {\n\n    @Override\n    public void mouseReleased(MouseEvent e) {\n       ...\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e) {\n      ...\n    }\n});\n</code></pre>\n    "},{"t":"Why is Scala hashmap slow?","l":"http://stackoverflow.com/questions/28744990/why-is-scala-hashmap-slow","q":"\n\n<p>And what can be done about it?</p>\n\n<p>I have run some tests and it seems that Scala Hashmap is much slower than a Java HashMap. Please prove me wrong!</p>\n\n<p>For me the whole point of Hashmap is to get quick access to a value from a given key. So I find myself resorting to using a Java HashMap when speed matters, which is a bit sad. I'm not experienced enough to say for sure but it seems that the more you mix Java and Scala the more problems you are likely to face.</p>\n\n<pre><code>test(\"that scala hashmap is slower than java\") {\n    val javaMap = new util.HashMap[Int,Int](){\n      for (i &lt;- 1 to 20)\n      put(i,i+1)\n    }\n\n    import collection.JavaConverters._\n    val scalaMap = javaMap.asScala.toMap\n\n    // check is a scala hashmap\n    assert(scalaMap.getClass.getSuperclass === classOf[scala.collection.immutable.HashMap[Int,Int]])\n\n    def slow = {\n      val start = System.nanoTime()\n      for (i &lt;- 1 to 1000) {\n        for (i &lt;- 1 to 20) {\n          scalaMap(i)\n        }\n      }\n      System.nanoTime() - start\n    }\n\n    def fast = {\n      val start = System.nanoTime()\n      for (i &lt;- 1 to 1000) {\n        for (i &lt;- 1 to 20) {\n          javaMap.get(i)\n        }\n      }\n      System.nanoTime() - start\n    }\n\n    val elapses: IndexedSeq[(Long, Long)] = {\n      (1 to 1000).map({_ =&gt; (slow,fast)})\n    }\n\n    var elapsedSlow = 0L\n    var elapsedFast = 0L\n    for ((eSlow,eFast) &lt;- elapses) {\n      elapsedSlow += eSlow\n      elapsedFast += eFast\n    }\n\n    assert(elapsedSlow &gt; elapsedFast)\n\n    val fraction : Double = elapsedFast.toDouble/elapsedSlow\n    println(s\"slower by factor of: $fraction\")\n}\n</code></pre>\n\n<p>Am I missing something?</p>\n\n<h2>Answer Summary</h2>\n\n<p>As of now, when comparing Java 8 to Scala 2.11, it appears that Java HashMap is notably speedier at lookups (for a low number of keys) than the Scala offerings - with the exception of LongMap (if your keys are Ints/Longs). </p>\n\n<p>The performance difference is not so great that it should matter in most use cases. Hopefully Scala will improve the speed of their Maps. In the mean time, if you need performance (with non-integer keys) use Java.</p>\n\n<p><strong>Int keys, n=20</strong><br>\n<em>Long(60), Java(93), Open(170), MutableSc(243), ImmutableSc(317)</em></p>\n\n<p><strong>case object keys, n=20</strong><br>\n<em>Java(195), AnyRef(230)</em></p>\n    ","a":"\n<p>First of all: doing JVM benchmarks using nanoTime is <strong>extremely</strong> error-prone. Use a microbenchmarking framework such as <a href=\"https://github.com/Ichoran/thyme\">Thyme</a>, <a href=\"https://code.google.com/p/caliper/\">Caliper</a> or <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\">JMH</a></p>\n\n<p>Second: you are comparing a <em>mutable</em> java hash map with an <em>immutable</em> scala hash map. Immutable collections can be remarkably fast, but there are some cases where they will never be as fast as mutable data structures.</p>\n\n<p>Here is a proper microbenchmark of mutable java hash map vs. immutable scala hash map: <a href=\"https://gist.github.com/rklaehn/26c277b2b5666ec4b372\">https://gist.github.com/rklaehn/26c277b2b5666ec4b372</a></p>\n\n<p>As you can see, the scala immutable map is a bit faster than the java mutable map. Note that this will not be the case once you go to larger maps, because an immutable data structure has to do some compromises to enable <a href=\"http://en.wikipedia.org/wiki/Persistent_data_structure\">structural sharing</a>. I would guess that in both cases, the dominant performance issue is boxing of the ints to Integer.</p>\n\n<p>Update: if you really want a mutable hash hap with ints as keys, the right choice from the scala collections library is <a href=\"http://www.scala-lang.org/api/2.11.5/index.html#scala.collection.mutable.LongMap\">scala.collection.mutable.LongMap</a>. This uses a long as key, and has much better performance than the generic Map because it does not have to box the value. See results from the gist.</p>\n\n<p>Update 2: If your key extends from AnyRef (like e.g. a String), your best bet for a high performance <em>mutable</em> map is <a href=\"http://www.scala-lang.org/api/2.11.5/index.html#scala.collection.mutable.AnyRefMap\">scala.collection.mutable.AnyRefMap</a></p>\n    "},{"t":"Get last element of Stream/List in a one-liner","l":"http://stackoverflow.com/questions/21426843/get-last-element-of-stream-list-in-a-one-liner","q":"\n\n<p>How can I get the last element of a stream or list in the following code?</p>\n\n<p>Where <code>data.careas</code> is a <code>List&lt;CArea&gt;</code>:</p>\n\n<pre><code>CArea first = data.careas.stream()\n.filter(c -&gt; c.bbox.orientationHorizontal).findFirst().get();\n\nCArea last = data.careas.stream()\n.filter(c -&gt; c.bbox.orientationHorizontal).collect(Collectors.toList()).; //how to?\n</code></pre>\n\n<p>As you can see getting the first element, with a certain <code>filter</code>, is not hard.</p>\n\n<p>However getting the last element in a one-liner is a real pain:</p>\n\n<ul>\n<li>It seems I cannot obtain it directly from a <code>Stream</code>. (It would only make sense for finite streams)</li>\n<li>It also seems that you cannot get things like <code>first()</code> and <code>last()</code> from the <code>List</code> interface, which is really a pain.</li>\n</ul>\n\n<p>I do not see any argument for not providing a <code>first()</code> and <code>last()</code> method in the <code>List</code> interface, as the elements in there are ordered, and moreover the size is known.</p>\n\n<p>But as per original answer: How to get the last element of a finite <code>Stream</code>?</p>\n\n<p>Personally, this is the closest I could get:</p>\n\n<pre><code>    int lastIndex = data.careas.stream()\n            .filter(c -&gt; c.bbox.orientationHorizontal)\n            .mapToInt(c -&gt; data.careas.indexOf(c)).max().getAsInt();\n    CArea last = data.careas.get(lastIndex);\n</code></pre>\n\n<p>However it does involve using an <code>indexOf</code> on every element, which is most likely not you generally want as it can impair performance.</p>\n    ","a":"\n<p>You can use the method <code>reduce</code> to get the last element:</p>\n\n<pre><code>CArea last = data.careas.stream()\n    .filter(c -&gt; c.bbox.orientationHorizontal)\n    .reduce((previous, current) -&gt; current).get();\n</code></pre>\n\n<p>Note that the <em>lambda expression</em> fulfils the contract of the <code>reduce</code> method. It is an <em>associative</em> function. It doesn't matter, that the function is not <em>commutative</em>, even if it is used for parallel evaluation.</p>\n    "},{"t":"Hibernate 4 with java.time.LocalDate and DATE() construct","l":"http://stackoverflow.com/questions/23890687/hibernate-4-with-java-time-localdate-and-date-construct","q":"\n\n<p>I'm trying to use LocalDate and LocalDateTime with Java 8 in my app. I'm using Hibernate 4.3.5 and Spring.\nI followed this interesting tutorial <a href=\"http://blog.progs.be/550/java-time-hibernate\">here</a> and all works but I've a problem when I use DATE() construct.</p>\n\n<p>When I try to do:</p>\n\n<pre><code>SELECT * FROM TABLE WHERE DATE(data)=DATE(:data)\n</code></pre>\n\n<p>I've always an empty list also if the query I made manually (copy and past query Hibernate print) works fine.\nI think that the problem is the conversion that Hibernate do internally; it try to convert LocalDate to java.util.Date.\nI tell this because if I change the query in this way:</p>\n\n<pre><code>SELECT * FROM TABLE WHERE DATE(data)=:data\n</code></pre>\n\n<p>I've this exception:</p>\n\n<pre><code>java.lang.IllegalArgumentException: Parameter value [2014-05-27T00:00] did not match expected type [java.util.Date (n/a)]\nat org.hibernate.jpa.spi.BaseQueryImpl.validateBinding(BaseQueryImpl.java:885)\nat org.hibernate.jpa.internal.QueryImpl.access$000(QueryImpl.java:80)\nat org.hibernate.jpa.internal.QueryImpl$ParameterRegistrationImpl.bindValue(QueryImpl.java:248)\nat org.hibernate.jpa.spi.BaseQueryImpl.setParameter(BaseQueryImpl.java:631)\nat org.hibernate.jpa.spi.AbstractQueryImpl.setParameter(AbstractQueryImpl.java:180)\nat org.hibernate.jpa.spi.AbstractQueryImpl.setParameter(AbstractQueryImpl.java:49)\nat it.AppuntamentoCustomRepositoryImpl.findAppuntamenti(AppuntamentoCustomRepositoryImpl.java:95)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:483)\nat org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)\nat org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)\nat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)\nat org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor.invoke(MethodSecurityInterceptor.java:64)\nat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\nat org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:98)\nat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:262)\nat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)\nat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\nat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)\nat com.sun.proxy.$Proxy91.findAppuntamenti(Unknown Source)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:483)\nat org.granite.messaging.service.ServiceInvocationContext.invoke(ServiceInvocationContext.java:72)\nat org.granite.messaging.service.security.AbstractSecurityService.endAuthorization(AbstractSecurityService.java:104)\nat org.granite.spring.security.SpringSecurity3Service.authorize(SpringSecurity3Service.java:289)\nat org.granite.messaging.service.ServiceInvoker.invoke(ServiceInvoker.java:220)\nat org.granite.messaging.amf.process.AMF3MessageProcessor.processRemotingMessage(AMF3MessageProcessor.java:141)\nat org.granite.messaging.amf.process.AMF3MessageProcessor.process(AMF3MessageProcessor.java:60)\nat org.granite.messaging.amf.process.AMF0MessageProcessor.process(AMF0MessageProcessor.java:79)\nat org.granite.messaging.webapp.AMFEndpoint.serviceJMFAMF(AMFEndpoint.java:151)\nat org.granite.messaging.webapp.AMFEndpoint.service(AMFEndpoint.java:64)\nat org.granite.spring.ServerFilter.handle(ServerFilter.java:322)\nat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:945)\nat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:876)\nat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:961)\nat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:863)\nat javax.servlet.http.HttpServlet.service(HttpServlet.java:755)\nat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:837)\nat javax.servlet.http.HttpServlet.service(HttpServlet.java:848)\nat org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:684)\nat org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:501)\nat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:137)\nat org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:557)\nat org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:231)\nat org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1086)\nat org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:428)\nat org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:193)\nat org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1020)\nat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:135)\nat org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:255)\nat org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:154)\nat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116)\nat org.eclipse.jetty.server.Server.handle(Server.java:370)\nat org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:494)\nat org.eclipse.jetty.server.AbstractHttpConnection.content(AbstractHttpConnection.java:982)\nat org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.content(AbstractHttpConnection.java:1043)\nat org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:865)\nat org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:240)\nat org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:82)\nat org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:667)\nat org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:52)\nat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608)\nat org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543)\nat java.lang.Thread.run(Thread.java:745)\n</code></pre>\n\n<p>I made also this test:</p>\n\n<pre><code>TypedQuery&lt;Date&gt; test = manager.createQuery(\"select DATE(:test) FROM Appuntamento\", Date.class);\n\n    test.setParameter(\"test\", LocalDate.now());\n    for (Date t : test.getResultList()) {\n        log.debug(\"T-----------&gt;\" + t);\n    }\n</code></pre>\n\n<p>And unfortunally DATE(:test) is always null!!</p>\n\n<p>Any suggestion is appreciated</p>\n\n<p>Thanks very much</p>\n    ","a":"\n<p>If you use JPA 2.1 this is simple to do.  Converters allow your JPA entities to use the new <code>java.time.LocalDate</code> and <code>java.time.LocalDateTime</code> classes.  Simply define the needed converter classes:</p>\n\n<p><strong>LocalDatePersistenceConverter.java</strong></p>\n\n<pre><code>import java.time.LocalDate;\nimport javax.persistence.AttributeConverter;\nimport javax.persistence.Converter;\n\n@Converter\npublic class LocalDatePersistenceConverter implements AttributeConverter&lt;LocalDate, java.sql.Date&gt; {\n\n  @Override\n  public java.sql.Date convertToDatabaseColumn(LocalDate entityValue) {\n    if (entityValue != null) {\n      return java.sql.Date.valueOf(entityValue);\n    }\n    return null;\n  }\n\n  @Override\n  public LocalDate convertToEntityAttribute(java.sql.Date databaseValue) {\n    if (databaseValue != null) {\n      return databaseValue.toLocalDate();\n    }\n    return null;\n  }\n}\n</code></pre>\n\n<p><strong>LocalDateTimePersistenceConverter.java</strong></p>\n\n<pre><code>import java.time.LocalDateTime;\nimport javax.persistence.AttributeConverter;\nimport javax.persistence.Converter;\n\n@Converter\npublic class LocalDateTimePersistenceConverter implements AttributeConverter&lt;LocalDateTime, java.sql.Timestamp&gt; {\n\n  @Override\n  public java.sql.Timestamp convertToDatabaseColumn(LocalDateTime entityValue) {\n    if (entityValue != null) {\n      return java.sql.Timestamp.valueOf(entityValue);\n    }\n    return null;\n  }\n\n  @Override\n  public LocalDateTime convertToEntityAttribute(java.sql.Timestamp databaseValue) {\n    if (databaseValue != null) {\n      return databaseValue.toLocalDateTime();\n    }\n    return null;\n  }\n}\n</code></pre>\n\n<p>And then annotate the appropriate entity property with the @Converter annotation:</p>\n\n<pre><code>@Convert(converter = LocalDatePersistenceConverter.class)\nprivate LocalDate completedDate;\n</code></pre>\n    "},{"t":"How to do function composition?","l":"http://stackoverflow.com/questions/19834611/how-to-do-function-composition","q":"\n\n<p>While rather impatiently waiting for Java 8 release and after reading brilliant <a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html\">'State of the Lambda' article from Brian Goetz</a> I noticed that <a href=\"http://en.wikipedia.org/wiki/Function_composition_%28computer_science%29\">function composition</a> was not covered at all.</p>\n\n<p>As per above article, in Java 8 the following should be possible:</p>\n\n<pre><code>// having classes Address and Person\npublic class Address {\n\n    private String country;\n\n    public String getCountry() {\n        return country;\n    }\n}\n\npublic class Person {\n\n    private Address address;\n\n    public Address getAddress() {\n        return address;\n    }\n}\n\n// we should be able to reference their methods like\nFunction&lt;Person, Address&gt; personToAddress = Person::getAddress;\nFunction&lt;Address, String&gt; addressToCountry = Address::getCountry;\n</code></pre>\n\n<p>Now if I would like to compose these two functions to have a function mapping <code>Person</code> to country, how can I achieve this in Java 8?</p>\n    ","a":"\n<p>There is a default interface function <code>Function::andThen</code> and <code>Function::compose</code>:</p>\n\n<pre><code>Function&lt;Person, String&gt; toCountry = personToAddress.andThen(addressToCountry);\n</code></pre>\n    "},{"t":"Using JDK 7 Or Higher With Android Studio And Eclipse On Mac OSX","l":"http://stackoverflow.com/questions/23265112/using-jdk-7-or-higher-with-android-studio-and-eclipse-on-mac-osx","q":"\n\n<p>Both Android Studio and Eclipse are asking me to install JDK 6 even though JDK 8 is already installed. Several workarounds online told me change the java_home to point the JDK 8 installation location, done that such that both /usr/libexec/java_home and java -version commands refer to the JDK 8 installation but Android Studio and Eclipse still asking me to install JDK 6. Anyone solved this issue.</p>\n    ","a":"\n<p>Android Studio is based on <strong>Intellij Idea 13</strong>. The solution <a href=\"https://intellij-support.jetbrains.com/entries/23455956-Selecting-the-JDK-version-the-IDE-will-run-under\">here</a> also applies. Just modifying Info.plist from <em>1.6*</em> to <em>1.7*</em> did it for me. </p>\n\n<p>Btw, I've observed that at least Android Studio 0.5.5 uses massive amounts of memory. With Java 8 it gets over 2GB for very simple projects. With Java 7 it is still bad, but takes around 1.5GB. </p>\n    "},{"t":"Java 8 stream - sum of objects","l":"http://stackoverflow.com/questions/30019287/java-8-stream-sum-of-objects","q":"\n\n<p>Let's say I have a list of objects implementing below interface:</p>\n\n<pre><code>public interface Summable&lt;T&gt; {\n    T add(T o1);\n}\n</code></pre>\n\n<p>Let's say I have also some class which is able to sum these objects:</p>\n\n<pre><code>public class Calculator&lt;T extends Summable&lt;T&gt;&gt; {\n    public T sum(final List&lt;T&gt; objects) {\n        if (null == objects) {\n            throw new IllegalArgumentException(\"Ups, list of objects cannot be null!\");\n        }\n        T resultObject = null;\n        for (T object : objects) {\n            resultObject = object.add(resultObject);\n        }\n        return resultObject;\n   }\n}\n</code></pre>\n\n<p>How can I achieve the same using Java 8 streams?</p>\n\n<p>I'm playing around a custom Collector, but couldn't figure out some neat solution.</p>\n    ","a":"\n<p>What you have is a <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Reduction\">reduction</a>:</p>\n\n<pre><code>return objects.stream().reduce(T::add).orElse(null);\n</code></pre>\n    "},{"t":"Why use reflection to access class members when MethodHandle is faster?","l":"http://stackoverflow.com/questions/30677670/why-use-reflection-to-access-class-members-when-methodhandle-is-faster","q":"\n\n<p>With the release of Java 7 came the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html\" rel=\"nofollow\"><code>MethodHandle</code></a>, which allows a user to invoke a method as if using its underlying bytecode.  In particular, the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandles.Lookup.html\" rel=\"nofollow\"><code>MethodHandles.Lookup</code></a> class provides factory methods to create method handles to access class members:</p>\n\n<blockquote>\n  <p>The factory methods on a Lookup object correspond to all major use cases for methods, constructors, and fields. Each method handle created by a factory method is the functional equivalent of a particular bytecode behavior.</p>\n</blockquote>\n\n<p>Functionally, this is more or less equivalent to using reflection to access these same class members, yet <a href=\"http://stackoverflow.com/a/22337726/1247781\"><strong>method handles are faster than reflection</strong></a>.</p>\n\n<p>So, is there any reason to still use reflection functionalities like <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html\" rel=\"nofollow\"><code>Field#get(..)</code></a>/<a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html\" rel=\"nofollow\"><code>Method.invoke(..)</code></a> or are these methods effectively obsolete with the introduction of the faster method handles?</p>\n\n<p><sub>Note that while method handles were introduced in Java 7, my question primarily pertains to Java 8, in which they were optimized to supposedly reach performance approximately equal to direct field/method calls, surpassing reflection's ability.</sub></p>\n    ","a":"\n<p>Reflection and method handles serve different purposes, and exist at different levels of abstraction.  You should use the one that is right for the problem you are solving.  </p>\n\n<p>Reflection is a general-purpose introspection mechanism, which includes many features that the method handle mechanism lacks, such as enumerating the members of a class (<code>Class.getMethods()</code>), inspecting the characteristics of a member such as its accessibility flags, inspecting generic signatures of members, etc.  </p>\n\n<p>Method handles are a low-level mechanism for finding, adapting, and invoking methods.  While invocation through method handles is faster than through reflection (though to date, direct bytecode invocation is still generally faster than method handle invocation), method handles are also significantly harder to use, as they do not automatically perform the adaptations Java users would expect (such as converting a String argument to Object), resulting in linkage errors.  </p>\n\n<p>The reflection library is aimed at mainstream Java users; the method handle layer is aimed more at compiler and language runtime writers.  Pick the tool designed for the job.</p>\n    "},{"t":"After upgrading to Java8, javac still shows 1.7","l":"http://stackoverflow.com/questions/23202516/after-upgrading-to-java8-javac-still-shows-1-7","q":"\n\n<p>I'm having issues upgrading from JDK 1.7 -&gt; 1.8 on OSX.  The upgrade has completed, but javac still returns 1.7 as the version.</p>\n\n<p>I've downloaded <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\">JDK 8_u5</a> from Oracle's homepage, and run the installer.</p>\n\n<p>I've also taken the following steps, post-install:</p>\n\n<pre><code>&gt; export JAVA_HOME=`/usr/libexec/java_home -v 1.8`  (Executed in my .bashrc file)\n\n&gt; echo $JAVA_HOME\n/Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home\n\n&gt; javac -version\njavac 1.7.0_21\n\n&gt; $JAVA_HOME/bin/javac -version\njavac 1.7.0_21\n\n&gt; $JAVA_HOME/bin/java -version    \njava version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n</code></pre>\n\n<p>I've gone through and removed Java 1.7 (and all other JDK versions), and then re-run the installer:</p>\n\n<pre><code>&gt; ls /Library/Java/JavaVirtualMachines\njdk1.8.0_05.jdk\n</code></pre>\n\n<p>Still no use, javac reports the version as 1.7.0_21</p>\n\n<pre><code>&gt; which javac\n/usr/bin/javac\n\n&gt; ls -ltra /usr/bin/javac \n[snipped] /usr/bin/javac -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/javac\n</code></pre>\n\n<p>Within that path, <code>Current</code> is a symlink to <code>A</code>. The contents of <code>A/Commands</code> are a series of files (not symlinks).  </p>\n\n<pre><code>&gt; cd A/Commands\n&gt; ./javac -version\njavac 1.7.0_21\n\n&gt; ./java -version\njava version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n</code></pre>\n\n<h2>Edit</h2>\n\n<p>Further to the original post, I've done some digging with <a href=\"https://github.com/gcuisinier/jenv\">jenv</a>, as suggested on <a href=\"http://stackoverflow.com/a/21148562/59015\">this answer</a>.</p>\n\n<pre><code>&gt; jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home                 \n&gt; jenv global oracle64-1.8.0.05\n&gt; jenv version\noracle64-1.8.0.05 (set by /Users/martypitt/.jenv/version)\n\n&gt; jenv info java \nJenv will exec : /Users/martypitt/.jenv/versions/oracle64-1.8.0.05/bin/java\n\n&gt; jenv info javac\nJenv will exec : /Users/martypitt/.jenv/versions/oracle64-1.8.0.05/bin/javac\n\n&gt; javac -version\njavac 1.7.0_21\n</code></pre>\n\n<p>This casts dispersions on my thoughts that this was a random javac lurking in my path, which was somehow getting invoked.</p>\n\n<p>To be sure, I've nuked my Java completely, and tried again:</p>\n\n<pre><code>&gt; cd /Library/Java/JavaVirtualMachines\n&gt; ls \njdk1.7.0_55.jdk \njdk1.8.0_05.jdk\n&gt; sudo rm -rf *  \n&gt; ls\n&lt;&lt;empty&gt;&gt;\n&gt; java -version\njava version \"1.6.0_65\"\n&gt; javac -version\njavac 1.6.0_65\n&gt; which javac\n/usr/bin/javac\n</code></pre>\n\n<p>I then re-downloaded a <a href=\"http://download.oracle.com/otn-pub/java/jdk/8u5-b13/jdk-8u5-macosx-x64.dmg\">fresh copy the installer</a> and ran it.</p>\n\n<pre><code>&gt; java -version\njava version \"1.8.0_05\"\n&gt; javac -version\njavac 1.7.0_21\n</code></pre>\n\n<h2>Update</h2>\n\n<p>I tried removing all JDK's, XCode and all developer tools, and re-installed fresh.\nSame results.</p>\n\n<p>However, I'm still at a loss -- where do I go from here?  How do I get javac 1.8 to get installed?</p>\n    ","a":"\n<p>If <code>/usr/libexec/java_home -v 1.8.0_05 --exec javac -version</code> returns the correct verrsion, then your problem is with: </p>\n\n<pre><code>/System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK\n</code></pre>\n\n<p>With a privileged user execute:</p>\n\n<pre><code>cd /System/Library/Frameworks/JavaVM.framework/Versions/\nrm CurrentJDK\nln -s /Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/ CurrentJDK\n</code></pre>\n\n<p><strong>Solution found in</strong> <a href=\"http://www.monkehworks.com/set-java-7-as-default-jvm-on-mac-osx-mountain-lion\">Mankeh Blog</a></p>\n\n<hr>\n\n<p>Also check <a href=\"http://superuser.com/a/568016\">this answer</a> on Super User for dynamically switching JDK versions.</p>\n\n<hr>\n\n<p><strong>Update:</strong> I guess I've found the culprit!</p>\n\n<p>Try this:</p>\n\n<pre><code>rm -rf ~/Library/Java/Extensions\nsudo rm -rf /Library/Java/Extensions\n</code></pre>\n\n<p><strong>Solution found in:</strong> <a href=\"http://stackoverflow.com/questions/22700845/java-1-7-on-osx-10-9-2-running-as-1-5\">Java 1.7 on OSX 10.9.2 running as 1.5?</a></p>\n    "},{"t":"Purpose of third argument to 'reduce' function in Java 8 functional programming","l":"http://stackoverflow.com/questions/22808485/purpose-of-third-argument-to-reduce-function-in-java-8-functional-programming","q":"\n\n<p>Under what circumstances is the third argument to 'reduce' called in Java 8 streams?</p>\n\n<p>The code below attempts to traverse a list of strings and add up the code point values of the first character of each. The value returned by the final lambda never seems to be used and, if you insert a println, it never seems to be invoked. The documentation describes it as a 'combiner' but I cant find more detail...</p>\n\n<pre><code>int result =\n  data.stream().reduce(0, (total,s) -&gt; total + s.codePointAt(0), (a,b) -&gt; 1000000); \n</code></pre>\n    ","a":"\n<p>Are you talking about <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-U-java.util.function.BiFunction-java.util.function.BinaryOperator-\">this function</a>?</p>\n\n<blockquote>\n<pre><code>reduce &lt;U&gt; U reduce(U identity,\n             BiFunction&lt;U,? super T,U&gt; accumulator,\n             BinaryOperator&lt;U&gt; combiner) \n</code></pre>\n  \n  <p>Performs a reduction on the elements of this stream, using the provided identity, accumulation and\n  combining functions. This is equivalent to:</p>\n\n<pre><code> U result = identity;\n for (T element : this stream)\n     result = accumulator.apply(result, element)\n return result;   \n</code></pre>\n  \n  <p>but is not constrained to execute sequentially. The identity value must be an identity for the combiner function. This\n  means that for all u, combiner(identity, u) is equal to u.\n  Additionally, the combiner function must be compatible with the\n  accumulator function; for all u and t, the following must hold:</p>\n\n<pre><code> combiner.apply(u, accumulator.apply(identity, t)) == \n     accumulator.apply(u, t)   \n</code></pre>\n  \n  <p>This is a terminal operation.</p>\n  \n  <p>API Note: Many reductions using this form can be represented more\n  simply by an explicit combination of map and reduce operations. The\n  accumulator function acts as a fused mapper and accumulator, which can\n  sometimes be more efficient than separate mapping and reduction, such\n  as when knowing the previously reduced value allows you to avoid some\n  computation. Type Parameters: U - The type of the result Parameters:\n  identity - the identity value for the combiner function accumulator -\n  an associative, non-interfering, stateless function for incorporating\n  an additional element into a result combiner - an associative,\n  non-interfering, stateless function for combining two values, which\n  must be compatible with the accumulator function Returns: the result\n  of the reduction See Also: reduce(BinaryOperator), reduce(Object,\n  BinaryOperator)</p>\n</blockquote>\n\n<p>I assume its purpose is to allow parallel computation, and so my guess is that it's only used if the reduction is performed in parallel.  If it's performed sequentially, there's no need to use <code>combiner</code>.  I do not know this for sure -- I'm just guessing based on the doc comment \"[...] is not constrained to execute sequentially\" and the many other mentions of \"parallel execution\" in the comments.</p>\n    "},{"t":"Java 8 method references : validation of methods at compile time","l":"http://stackoverflow.com/questions/20840800/java-8-method-references-validation-of-methods-at-compile-time","q":"\n\n<p>I'd like to use the new <em>method references</em> of Java 8 to provide more validation of some code at compile time.</p>\n\n<p>Let's say I have a <code>validateMethod</code> method which requires one parameter : a \"method\" to be validated. For example :</p>\n\n<pre><code>validateMethod(foo, \"methodA\");\n</code></pre>\n\n<p>Here, the method would validate that <code>foo#methodA()</code> exists, <em>at runtime</em>.</p>\n\n<p>Using method references, I'd like to be able to do :</p>\n\n<pre><code>validateMethod(foo::methodA);\n</code></pre>\n\n<p>So the existence of the method would be validated <em>at compile time</em>. </p>\n\n<p>The problem is that it seems method references <strong>have</strong> to be assigned to a functional interface. For example, this :</p>\n\n<pre><code>Object dummy = foo::methodA;\n</code></pre>\n\n<p>Generates the error : \"<em>The target type of this expression must be a functional interface</em>\".</p>\n\n<p>If I create a functional interface that has a compatible signature with the <code>methodA</code> method, it works :</p>\n\n<pre><code>@FunctionalInterface\npublic interface MyFunctionalInterface\n{\n    public String run();\n}\nMyFunctionalInterface dummy = foo::methodA;\n</code></pre>\n\n<p>Now the existence of <code>foo#methodA()</code> is validated at compile time, which is what I want! </p>\n\n<p>But...</p>\n\n<p>Let's say <code>validateMethod</code> doesn't know the signature of the method it has to validate. Is it still possible to implement it then?</p>\n\n<p>Let's pretend we don't care about ambiguity and overloaded methods. Is it possible in Java 8 to implement some kind of method which would trigger the validation of <em>any</em> method reference?</p>\n\n<p>For example : </p>\n\n<pre><code>public class Foo\n{\n    public String methodA()\n    {\n        return \"methodA\";\n    }\n\n    public String methodB(String str)\n    {\n        return \"methodB\";\n    }\n\n    public String methodC(String str, int nbr)\n    {\n        return \"methodC\";\n    }\n}\n\nFoo foo = new Foo();\nvalidateMethod(foo::methodA); // Compile\nvalidateMethod(foo::methodB); // Compile\nvalidateMethod(foo::methodC); // Compile\nvalidateMethod(foo::methodD); // Error!\n</code></pre>\n\n<p>Would it be possible to implement <code>validateMethod</code> in such a way that any method reference would be accepted, so the existence of the method would be validated at compile time? </p>\n\n<p>I tried :</p>\n\n<pre><code>public void validateMethod(Object obj){}\n</code></pre>\n\n<p>But it doesn't work : \"<em>The target type of this expression must be a functional interface</em>\"</p>\n\n<p>This would work :</p>\n\n<pre><code>@FunctionalInterface\npublic interface MyFunctionalInterface\n{\n    public String run();\n}\npublic void validateMethod(MyFunctionalInterface param){}\n</code></pre>\n\n<p>But only for <code>methodA</code> of the <code>Foo</code> class, because its signature (no parameter) is compatible with the functional interface's method signature!</p>\n\n<p>Would it be possible to implement the functional interface <code>MyFunctionalInterface</code> in such a way that <em>any</em> method reference would be a valid parameter and therefore would be validated at compile time?</p>\n\n<p>Any other ways you see to validate the existence of a method at compile time?</p>\n    ","a":"\n<p>You seem to be trying to use <strong>method references</strong>, which are really the <em>short-hands for lambda expressions</em>, as <strong>method literals</strong>, which are the <em>syntactic references to methods</em> (much like Foo.class is the syntactic reference to class instance of Foo). These two are not the same, and this is the reason for the impedance you encounter. Things you try are the abuse of language feature which javac compiler utterly resists.</p>\n\n<p>Unfortunately, there is no method literals in Java, so you will have to describe the method by other means, e.g. Reflection, MethodHandles.Lookup, etc. I think it is very easy to come up with the reflective checker for this kind of thing, or even build up the annotation processor to check the existence of given methods in compile time.</p>\n    "},{"t":"Annotating the functional interface of a Lambda Expression","l":"http://stackoverflow.com/questions/22375891/annotating-the-functional-interface-of-a-lambda-expression","q":"\n\n<p>Java 8 will introduce both <a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\">Lambda Expressions</a> and <a href=\"http://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html\">Type Annotations</a>.</p>\n\n<p>With type annotations, it is possible to define Java annotations like the following:</p>\n\n<pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE_USE)\npublic @interface MyTypeAnnotation {\n    public String value();\n}\n</code></pre>\n\n<p>One can then use this annotation on any type reference like e.g.:</p>\n\n<pre><code>Consumer&lt;String&gt; consumer = new @MyTypeAnnotation(\"Hello \") Consumer&lt;String&gt;() {\n    @Override\n    public void accept(String str) {\n        System.out.println(str);\n    }\n};\n</code></pre>\n\n<p>Here is a complete example, that uses this annotation to print \"Hello World\":</p>\n\n<pre><code>import java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedType;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Consumer;\n\npublic class Java8Example {\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.TYPE_USE)\n    public @interface MyTypeAnnotation {\n        public String value();\n    }\n\n    public static void main(String[] args) {\n        List&lt;String&gt; list = Arrays.asList(\"World!\", \"Type Annotations!\");\n        testTypeAnnotation(list, new @MyTypeAnnotation(\"Hello \") Consumer&lt;String&gt;() {\n            @Override\n            public void accept(String str) {\n                System.out.println(str);\n            }\n        });\n    }\n\n    public static void testTypeAnnotation(List&lt;String&gt; list, Consumer&lt;String&gt; consumer){\n        MyTypeAnnotation annotation = null;\n        for (AnnotatedType t : consumer.getClass().getAnnotatedInterfaces()) {\n            annotation = t.getAnnotation(MyTypeAnnotation.class);\n            if (annotation != null) {\n                break;\n            }\n        }\n        for (String str : list) {\n            if (annotation != null) {\n                System.out.print(annotation.value());\n            }\n            consumer.accept(str);\n        }\n    }\n}\n</code></pre>\n\n<p>The output will be:</p>\n\n<pre><code>Hello World! \nHello Type Annotations!\n</code></pre>\n\n<p>In Java 8 one can also replace the anonymous class in this example with a lambda expression:</p>\n\n<pre><code>public static void main(String[] args) {\n    List&lt;String&gt; list = Arrays.asList(\"World!\", \"Type Annotations!\");\n    testTypeAnnotation(list, p -&gt; System.out.println(p));\n}\n</code></pre>\n\n<p>But since the compiler infers the Consumer type argument for the lambda expression, one is no longer able to annotate the created Consumer instance:</p>\n\n<pre><code>testTypeAnnotation(list, @MyTypeAnnotation(\"Hello \") (p -&gt; System.out.println(p))); // Illegal!\n</code></pre>\n\n<p>One could cast the lambda expression into a Consumer and then annotate the type reference of the cast expression:</p>\n\n<pre><code>testTypeAnnotation(list,(@MyTypeAnnotation(\"Hello \") Consumer&lt;String&gt;) (p -&gt; System.out.println(p))); // Legal!\n</code></pre>\n\n<p>But this will not produce the desired result, because the created Consumer class will not be annotated with the annotation of the cast expression. Output:</p>\n\n<pre><code>World!\nType Annotations!\n</code></pre>\n\n<p>Two questions:</p>\n\n<ol>\n<li><p>Is there any way to annotate a lambda expression similar to annotating a corresponding anonymous class, so one gets the expected \"Hello World\" output in the example above?</p></li>\n<li><p>In the example, where I did cast the lambda expression and annotated the casted type: Is there any way to receive this annotation instance at runtime, or is such an annotation always implicitly restricted to RetentionPolicy.SOURCE?</p></li>\n</ol>\n\n<p>The examples have been tested with javac and the Eclipse compiler.</p>\n\n<p><strong>Update</strong></p>\n\n<p>I tried the suggestion from @assylias, to annotate the parameter instead, which produced an interesting result. Here is the updated test method:</p>\n\n<pre><code>public static void testTypeAnnotation(List&lt;String&gt; list, Consumer&lt;String&gt; consumer){\n    MyTypeAnnotation annotation = null;\n    for (AnnotatedType t :  consumer.getClass().getAnnotatedInterfaces()) {\n        annotation = t.getAnnotation(MyTypeAnnotation.class);\n        if (annotation != null) {\n            break;\n        }\n    }\n    if (annotation == null) {\n            // search for annotated parameter instead\n        loop: for (Method method : consumer.getClass().getMethods()) {\n            for (AnnotatedType t : method.getAnnotatedParameterTypes()) {\n                annotation = t.getAnnotation(MyTypeAnnotation.class);\n                if (annotation != null) {\n                    break loop;\n                }\n            }\n        }\n    }\n    for (String str : list) {\n        if (annotation != null) {\n            System.out.print(annotation.value());\n        }\n        consumer.accept(str);\n    }\n}\n</code></pre>\n\n<p>Now, one can also produce the \"Hello World\" result, when annotating the parameter of an anonymous class:</p>\n\n<pre><code>public static void main(String[] args) {\n    List&lt;String&gt; list = Arrays.asList(\"World!\", \"Type Annotations!\");\n    testTypeAnnotation(list, new Consumer&lt;String&gt;() {\n        @Override\n        public void accept(@MyTypeAnnotation(\"Hello \") String str) {\n            System.out.println(str);\n        }\n    });\n}\n</code></pre>\n\n<p>But annotating the parameter does <em>not</em> work for lambda expressions:</p>\n\n<pre><code>public static void main(String[] args) {\n    List&lt;String&gt; list = Arrays.asList(\"World!\", \"Type Annotations!\");\n    testTypeAnnotation(list, (@MyTypeAnnotation(\"Hello \") String str) -&gt;  System.out.println(str));\n}\n</code></pre>\n\n<p>Interestingly, it is also not possible to receive the name of the parameter (when compiling with javac -parameter), when using a lambda expression. I'm not sure though, if this behavior is intended, if parameter annotations of lambdas have not yet been implemented, or if this should be considered a bug of the compiler.</p>\n    ","a":"\n<p>After digging into the <a href=\"http://download.oracle.com/otndocs/jcp/java_se-8-fr-eval-spec/index.html\">Java SE 8 Final Specification</a> I'm able to answer my questions.</p>\n\n<p><strong>(1) In response to my first question</strong></p>\n\n<blockquote>\n  <p>Is there any way to annotate a lambda expression similar to annotating\n  a corresponding anonymous class, so one gets the expected \"Hello\n  World\" output in the example above?</p>\n</blockquote>\n\n<p>No.</p>\n\n<p>When annotating the <code>Class Instance Creation Expression (§15.9)</code> of an anonymous type, then the annotation will be stored in the class file either for the extending interface or the extending class of the anonymous type.</p>\n\n<p>For the following anonymous interface annotation</p>\n\n<pre><code>Consumer&lt;String&gt; c = new @MyTypeAnnotation(\"Hello \") Consumer&lt;String&gt;() {\n    @Override\n    public void accept(String str) {\n        System.out.println(str);\n    }\n};\n</code></pre>\n\n<p>the type annotation can then be accessed at <em>runtime</em> by calling <code>Class#getAnnotatedInterfaces()</code>:</p>\n\n<pre><code>MyTypeAnnotation a = c.getClass().getAnnotatedInterfaces()[0].getAnnotation(MyTypeAnnotation.class);\n</code></pre>\n\n<p>If creating an anonymous class with an empty body like this:</p>\n\n<pre><code>class MyClass implements Consumer&lt;String&gt;{\n    @Override\n    public void accept(String str) {\n        System.out.println(str);\n    }\n}\nConsumer&lt;String&gt; c = new @MyTypeAnnotation(\"Hello \") MyClass(){/*empty body!*/};\n</code></pre>\n\n<p>the type annotation can also be accessed at <em>runtime</em> by calling <code>Class#getAnnotatedSuperclass()</code>:</p>\n\n<pre><code>MyTypeAnnotation a = c.getClass().getAnnotatedSuperclass().getAnnotation(MyTypeAnnotation.class);\n</code></pre>\n\n<p>This kind of type annotation is <strong>not</strong> possible for lambda expressions.</p>\n\n<p>On a side note, this kind of annotation is also not possible for normal class instance creation expressions like this:</p>\n\n<pre><code>Consumer&lt;String&gt; c = new @MyTypeAnnotation(\"Hello \") MyClass();\n</code></pre>\n\n<p>In this case, the type annotation will be stored in the <a href=\"http://docs.oracle.com/javase/specs/jvms/se5.0/html/ClassFile.doc.html\">method_info structure</a> of the method, where the expression occurred and not as an annotation of the type itself (or any of its super types).</p>\n\n<p>This difference is important, because annotations stored in the method_info will <em>not</em> be accessible at runtime by the Java reflection API. When looking at the generated byte code with <a href=\"http://asm.ow2.org/\">ASM</a>, the difference looks like this:</p>\n\n<p>Type Annotation on an anonymous interface instance creation:</p>\n\n<pre><code>@Java8Example$MyTypeAnnotation(value=\"Hello \") : CLASS_EXTENDS 0, null\n// access flags 0x0\nINNERCLASS Java8Example$1\n</code></pre>\n\n<p>Type Annotation on a normal class instance creation:</p>\n\n<pre><code>NEW Java8Example$MyClass\n@Java8Example$MyTypeAnnotation(value=\"Hello \") : NEW, null\n</code></pre>\n\n<p>While in the first case, the annotation is associated with the <em>inner class</em>, in the second case, the annotation is associated with the <em>instance creation</em> expression inside the methods byte code.</p>\n\n<p><strong>(2) In response to the comment from @assylias</strong></p>\n\n<blockquote>\n  <p>You can also try (@MyTypeAnnotation(\"Hello \") String s) -&gt; \n  System.out.println(s) although I have not managed to access the\n  annotation value...</p>\n</blockquote>\n\n<p>Yes, this is actually possible according to the Java 8 specification. But it is not currently possible to receive the type annotations of the formal parameters of lambda expressions through the Java reflection API, which is most likely related to this JDK bug: <a href=\"https://bugs.openjdk.java.net/browse/JDK-8027181\">Type Annotations Cleanup</a>. Also the Eclipse Compiler does not yet store the relevant Runtime[In]VisibleTypeAnnotations attribute in the class file - the corresponding bug is found here: <a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=430571\">Lambda parameter names and annotations don't make it to class files.</a></p>\n\n<p><strong>(3) In response to my second question</strong></p>\n\n<blockquote>\n  <p>In the example, where I did cast the lambda expression and annotated\n  the casted type: Is there any way to receive this annotation instance\n  at runtime, or is such an annotation always implicitly restricted to\n  RetentionPolicy.SOURCE?</p>\n</blockquote>\n\n<p>When annotating the type of a cast expression, this information also gets stored in the method_info structure of the class file. The same is true for other possible locations of type annotations inside the code of a method like e.g. <code>if(c instanceof @MyTypeAnnotation Consumer)</code>. There is currently no public Java reflection API to access these code annotations. But since they are stored in the class file, it is at least potentially possible to access them at runtime - e.g. by reading the byte code of a class with an external library like <a href=\"http://asm.ow2.org/\">ASM</a>.</p>\n\n<p>Actually, I managed to get my \"Hello World\" example working with a cast expression like </p>\n\n<pre><code>testTypeAnnotation(list,(@MyTypeAnnotation(\"Hello \") Consumer&lt;String&gt;) (p -&gt; System.out.println(p)));\n</code></pre>\n\n<p>by parsing the calling methods byte code using ASM. But the code is very hacky and inefficient, and one should probably never do something like this in production code. Anyway, just for completeness, here is the complete working \"Hello World\" example:</p>\n\n<pre><code>import java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.AnnotatedType;\nimport java.lang.reflect.Method;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Consumer;\n\nimport org.objectweb.asm.AnnotationVisitor;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.Label;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.TypePath;\nimport org.objectweb.asm.TypeReference;\n\npublic class Java8Example {\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(ElementType.TYPE_USE)\n    public @interface MyTypeAnnotation {\n        public String value();\n    }\n\n    public static void main(String[] args) {\n        List&lt;String&gt; list = Arrays.asList(\"World!\", \"Type Annotations!\");\n        testTypeAnnotation(list, new @MyTypeAnnotation(\"Hello \") Consumer&lt;String&gt;() {\n            @Override\n            public void accept(String str) {\n                System.out.println(str);\n            }\n        });\n        list = Arrays.asList(\"Type-Cast Annotations!\");\n        testTypeAnnotation(list,(@MyTypeAnnotation(\"Hello \") Consumer&lt;String&gt;) (p -&gt; System.out.println(p)));\n    }\n\n    public static void testTypeAnnotation(List&lt;String&gt; list, Consumer&lt;String&gt; consumer){\n        MyTypeAnnotation annotation = null;\n        for (AnnotatedType t :  consumer.getClass().getAnnotatedInterfaces()) {\n            annotation = t.getAnnotation(MyTypeAnnotation.class);\n            if (annotation != null) {\n                break;\n            }\n        }\n        if (annotation == null) {\n            // search for annotated parameter instead\n            loop: for (Method method : consumer.getClass().getMethods()) {\n                for (AnnotatedType t : method.getAnnotatedParameterTypes()) {\n                    annotation = t.getAnnotation(MyTypeAnnotation.class);\n                    if (annotation != null) {\n                        break loop;\n                    }\n                }\n            }\n        }\n        if (annotation == null) {\n            annotation = findCastAnnotation();\n        }\n        for (String str : list) {\n            if (annotation != null) {\n                System.out.print(annotation.value());\n            }\n            consumer.accept(str);\n        }\n    }\n\n    private static MyTypeAnnotation findCastAnnotation() {\n        // foundException gets thrown, when the cast annotation is found or the search ends.\n        // The found annotation will then be stored at foundAnnotation[0]\n        final RuntimeException foundException = new RuntimeException();\n        MyTypeAnnotation[] foundAnnotation = new MyTypeAnnotation[1];\n        try {\n            // (1) find the calling method\n            StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();\n            StackTraceElement previous = null;\n            for (int i = 0; i &lt; stackTraceElements.length; i++) {\n                if (stackTraceElements[i].getMethodName().equals(\"testTypeAnnotation\")) {\n                    previous = stackTraceElements[i+1];\n                }\n            }\n            if (previous == null) {\n                // shouldn't happen\n                return null;\n            }\n            final String callingClassName = previous.getClassName();\n            final String callingMethodName = previous.getMethodName();\n            final int callingLineNumber = previous.getLineNumber();\n            // (2) read and visit the calling class\n            ClassReader cr = new ClassReader(callingClassName);\n            cr.accept(new ClassVisitor(Opcodes.ASM5) {\n                @Override\n                public MethodVisitor visitMethod(int access, String name,String desc, String signature, String[] exceptions) {\n                    if (name.equals(callingMethodName)) {\n                        // (3) visit the calling method\n                        return new MethodVisitor(Opcodes.ASM5) {\n                            int lineNumber;\n                            String type;\n                            public void visitLineNumber(int line, Label start) {\n                                this.lineNumber = line;\n                            };\n                            public void visitTypeInsn(int opcode, String type) {\n                                if (opcode == Opcodes.CHECKCAST) {\n                                    this.type = type;\n                                } else{\n                                    this.type = null;\n                                }\n                            };\n                            public AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String desc, boolean visible) {\n                                if (lineNumber == callingLineNumber) {\n                                    // (4) visit the annotation, if this is the calling line number AND the annotation is \n                                    // of type MyTypeAnnotation AND it was a cast expression to \"java.util.function.Consumer\"\n                                    if (desc.endsWith(\"Java8Example$MyTypeAnnotation;\") &amp;&amp; this.type != null &amp;&amp; this.type.equals(\"java/util/function/Consumer\")) {\n                                        TypeReference reference = new TypeReference(typeRef);\n                                        if (reference.getSort() == TypeReference.CAST) {\n                                            return new AnnotationVisitor(Opcodes.ASM5) {\n                                                public void visit(String name, final Object value) {\n                                                    if (name.equals(\"value\")) {\n                                                        // Heureka! - we found the Cast Annotation\n                                                        foundAnnotation[0] = new MyTypeAnnotation() {\n                                                            @Override\n                                                            public Class&lt;? extends Annotation&gt; annotationType() {\n                                                                return MyTypeAnnotation.class;\n                                                            }\n                                                            @Override\n                                                            public String value() {\n                                                                return value.toString();\n                                                            }\n                                                        };\n                                                        // stop search (Annotation found)\n                                                        throw foundException;\n                                                    }\n                                                };\n                                            };\n                                        }\n                                    }\n                                } else if (lineNumber &gt; callingLineNumber) {\n                                    // stop search (Annotation not found)\n                                    throw foundException;\n                                }\n                                return null;\n                            };\n\n                        };\n                    }\n                    return null;\n                }\n            }, 0);\n        } catch (Exception e) {\n            if (foundException == e) {\n                return foundAnnotation[0];\n            } else{\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n}\n</code></pre>\n    "},{"t":"Inference variable has incompatible bounds. Java 8 Compiler Regression?","l":"http://stackoverflow.com/questions/30622759/inference-variable-has-incompatible-bounds-java-8-compiler-regression","q":"\n\n<p>The following program compiles in Java 7 and in Eclipse Mars RC2 for Java 8:</p>\n\n<pre><code>import java.util.List;\n\npublic class Test {\n\n    static final void a(Class&lt;? extends List&lt;?&gt;&gt; type) {\n        b(newList(type));\n    }\n\n    static final &lt;T&gt; List&lt;T&gt; b(List&lt;T&gt; list) {\n        return list;\n    }\n\n    static final &lt;L extends List&lt;?&gt;&gt; L newList(Class&lt;L&gt; type) {\n        try {\n            return type.newInstance();\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n</code></pre>\n\n<p>Using the javac 1.8.0_45 compiler, the following compilation error is reported:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>Test.java:6: error: method b in class Test cannot be applied to given types;\n        b(newList(type));\n        ^\n  required: List&lt;T&gt;\n  found: CAP#1\n  reason: inference variable L has incompatible bounds\n    equality constraints: CAP#2\n    upper bounds: List&lt;CAP#3&gt;,List&lt;?&gt;\n  where T,L are type-variables:\n    T extends Object declared in method &lt;T&gt;b(List&lt;T&gt;)\n    L extends List&lt;?&gt; declared in method &lt;L&gt;newList(Class&lt;L&gt;)\n  where CAP#1,CAP#2,CAP#3 are fresh type-variables:\n    CAP#1 extends List&lt;?&gt; from capture of ? extends List&lt;?&gt;\n    CAP#2 extends List&lt;?&gt; from capture of ? extends List&lt;?&gt;\n    CAP#3 extends Object from capture of ?\n</code></pre>\n\n<p>A workaround is to locally assign a variable:</p>\n\n<pre><code>import java.util.List;\n\npublic class Test {\n\n    static final void a(Class&lt;? extends List&lt;?&gt;&gt; type) {\n\n        // Workaround here\n        List&lt;?&gt; variable = newList(type);\n        b(variable);\n    }\n\n    static final &lt;T&gt; List&lt;T&gt; b(List&lt;T&gt; list) {\n        return list;\n    }\n\n    static final &lt;L extends List&lt;?&gt;&gt; L newList(Class&lt;L&gt; type) {\n        try {\n            return type.newInstance();\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n</code></pre>\n\n<p>I know that type inference has changed a lot in Java 8 (<a href=\"http://openjdk.java.net/jeps/101\" rel=\"nofollow\">e.g. due to JEP 101 \"generalized target-type inference\"</a>). So, is this a bug or a new language \"feature\"?</p>\n\n<p><strong>EDIT</strong>: I have also reported this to Oracle as JI-9021550, but just in case this is a \"feature\" in Java 8, I've reported the issue also to Eclipse:</p>\n\n<ul>\n<li><a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=469297\" rel=\"nofollow\">https://bugs.eclipse.org/bugs/show_bug.cgi?id=469297</a></li>\n</ul>\n    ","a":"\n<p>Disclaimer - I don't know enough about the subject, and the following is an informal reasoning of mine to try to justify javac's behavior.</p>\n\n<hr>\n\n<p>We can reduce the problem to </p>\n\n<pre><code>&lt;X extends List&lt;?&gt;&gt; void a(Class&lt;X&gt; type) throws Exception\n{\n    X instance = type.newInstance();\n    b(instance);  // error\n}\n\n&lt;T&gt; List&lt;T&gt; b(List&lt;T&gt; list) { ... }\n</code></pre>\n\n<p>To infer <code>T</code>, we have constraints</p>\n\n<pre><code>      X &lt;: List&lt;?&gt;\n      X &lt;: List&lt;T&gt;\n</code></pre>\n\n<p>Essentially, this is unsolvable. For example, no <code>T</code> exists if <code>X=List&lt;?&gt;</code>.</p>\n\n<p>Not sure how Java7 infers this case. But javac8 (and IntelliJ) behaves \"reasonably\", I'd say.</p>\n\n<hr>\n\n<p>Now, how come this workaround works?</p>\n\n<pre><code>    List&lt;?&gt; instance = type.newInstance();\n    b(instance);  // ok!\n</code></pre>\n\n<p>It works due to wildcard capture, which introduces more type info, \"narrowing\" the type of <code>instance</code></p>\n\n<pre><code>    instance is List&lt;?&gt;  =&gt;  exist W, where instance is List&lt;W&gt;  =&gt;  T=W\n</code></pre>\n\n<p>Unfortunately, this is not done when <code>instance</code> is <code>X</code>, thus there is less type info to work with. </p>\n\n<p>Conceivably, the language could be \"improved\" to do wildcard capture for X too:</p>\n\n<pre><code>    instance is X, X is List&lt;?&gt;  =&gt;  exist W, where instance is List&lt;W&gt;\n</code></pre>\n    "},{"t":"Why does this compile under Java 7 but not under Java 8?","l":"http://stackoverflow.com/questions/30372211/why-does-this-compile-under-java-7-but-not-under-java-8","q":"\n\n<p>This seems to compile fine with Java 7, and any version of the Scala libraries:</p>\n\n<pre><code>public static void main(String[] args) {\n    scala.collection.immutable.Set&lt;String&gt; set = new scala.collection.immutable.HashSet&lt;String&gt;();\n    Iterator&lt;String&gt; iterator = set.iterator();\n}\n</code></pre>\n\n<p>It also compiles fine with Java 8 and Scala 2.11.5+. But with Java 8 and Scala 2.11.4, Eclipse complains:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>The method iterator() is ambiguous for the type Set&lt;String&gt;\n</code></pre>\n\n<p>I don't understand this. You might get ambiguity over which overloaded method to select in some contexts, but surely not if you're not passing any arguments?</p>\n\n<p>The really weird thing is that if I recast it like this:</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>public static void main(String[] args) {\n    Iterator&lt;String&gt; iterator = new scala.collection.immutable.HashSet&lt;String&gt;().iterator();\n}\n</code></pre>\n\n<p>then the complaint goes away. This seems to me to be exactly equivalent to the version above. So why would it now compile fine?</p>\n    ","a":"\n<p>If we compare the javap output of <code>scala.collection.immutable.Set</code>, we get for the 2.11.4:</p>\n\n<pre><code>public interface scala.collection.immutable.Set&lt;A&gt; \n    extends \n        scala.collection.immutable.Iterable&lt;A&gt;, \n        scala.collection.Set&lt;A&gt;, \n        scala.collection.generic.GenericSetTemplate&lt;A, \n        scala.collection.immutable.Set&gt;, \n        scala.collection.SetLike&lt;A, scala.collection.immutable.Set&lt;A&gt;&gt;, \n        scala.collection.Parallelizable&lt;A, \n        scala.collection.parallel.immutable.ParSet&lt;A&gt;&gt; {\n    public abstract scala.collection.generic.GenericCompanion&lt;scala.collection.immutable.Set&gt; companion();\n    public abstract &lt;B&gt; scala.collection.immutable.Set&lt;B&gt; toSet();\n    public abstract scala.collection.immutable.Set&lt;A&gt; seq();\n    public abstract scala.collection.parallel.Combiner&lt;A, scala.collection.parallel.immutable.ParSet&lt;A&gt;&gt; parCombiner();\n}\n</code></pre>\n\n<p>and for the 2.11.5:</p>\n\n<pre><code>public interface scala.collection.immutable.Set&lt;A&gt;\n    extends \n        scala.collection.immutable.Iterable&lt;A&gt;, \n        scala.collection.Set&lt;A&gt; {\n    public abstract scala.collection.generic.GenericCompanion&lt;scala.collection.immutable.Set&gt; companion();\n    public abstract &lt;B&gt; scala.collection.immutable.Set&lt;B&gt; toSet();\n    public abstract scala.collection.immutable.Set&lt;A&gt; seq();\n    public abstract scala.collection.parallel.Combiner&lt;A, scala.collection.parallel.immutable.ParSet&lt;A&gt;&gt; parCombiner();\n}\n</code></pre>\n\n<p>The version 2.11.4 is not correct, it is a violation of the Java Virtual Machine Specification, <a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9.1\">section 4.7.9.1</a>:</p>\n\n<blockquote>\n  <p>A class signature encodes type information about a (possibly generic) class declaration. It describes any type parameters of the class, and lists its (possibly parameterized) <strong>direct</strong> superclass and <strong>direct</strong> superinterfaces, if any. A type parameter is described by its name, followed by any class bound and interface bounds.</p>\n</blockquote>\n\n<hr>\n\n<p>This is clearly explained in <a href=\"https://issues.scala-lang.org/browse/SI-8931\">this scalac issue</a>, which have been fixed in the... 2.11.5</p>\n    "},{"t":"Encounter Order wrong when sorting a parallel stream","l":"http://stackoverflow.com/questions/30406281/encounter-order-wrong-when-sorting-a-parallel-stream","q":"\n\n<p>I have a <code>Record</code> class:</p>\n\n<pre><code>public class Record implements Comparable&lt;Record&gt;\n{\n   private String myCategory1;\n   private int    myCategory2;\n   private String myCategory3;\n   private String myCategory4;\n   private int    myValue1;\n   private double myValue2;\n\n   public Record(String category1, int category2, String category3, String category4,\n      int value1, double value2)\n   {\n      myCategory1 = category1;\n      myCategory2 = category2;\n      myCategory3 = category3;\n      myCategory4 = category4;\n      myValue1 = value1;\n      myValue2 = value2;\n   }\n\n   // Getters here\n}\n</code></pre>\n\n<p>I create a big list of a lot of records.  Only the second and fifth values, <code>i / 10000</code> and <code>i</code>, are used later, by the getters <code>getCategory2()</code> and <code>getValue1()</code> respectively.</p>\n\n<pre><code>List&lt;Record&gt; list = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; 115000; i++)\n{\n    list.add(new Record(\"A\", i / 10000, \"B\", \"C\", i, (double) i / 100 + 1));\n}\n</code></pre>\n\n<p>Note that first 10,000 records have a <code>category2</code> of <code>0</code>, then next 10,000 have <code>1</code>, etc., while the <code>value1</code> values are 0-114999 sequentially.</p>\n\n<p>I create a <code>Stream</code> that is both <code>parallel</code> and <code>sorted</code>.</p>\n\n<pre><code>Stream&lt;Record&gt; stream = list.stream()\n   .parallel()\n   .sorted(\n       //(r1, r2) -&gt; Integer.compare(r1.getCategory2(), r2.getCategory2())\n   )\n   //.parallel()\n;\n</code></pre>\n\n<p>I have a <code>ForkJoinPool</code> that maintains <code>8</code> threads, which is the number of cores I have on my PC.</p>\n\n<pre><code>ForkJoinPool pool = new ForkJoinPool(8);\n</code></pre>\n\n<p>I use the trick <a href=\"http://stackoverflow.com/questions/21163108/custom-thread-pool-in-java-8-parallel-stream\">described here to submit a stream processing task to my own <code>ForkJoinPool</code> instead of the common <code>ForkJoinPool</code></a>.</p>\n\n<pre><code>List&lt;Record&gt; output = pool.submit(() -&gt;\n    stream.collect(Collectors.toList()\n)).get();\n</code></pre>\n\n<p>I expected that the parallel <code>sorted</code> operation would respect the encounter order of the stream, and that it would be a <em>stable</em> sort, because the <code>Spliterator</code> returned by <code>ArrayList</code> is <code>ORDERED</code>.</p>\n\n<p>However, simple code that prints out the elements of the resultant <code>List</code> <code>output</code> in order shows that it's not quite the case.</p>\n\n<pre><code>for (Record record : output)\n{\n     System.out.println(record.getValue1());\n}\n</code></pre>\n\n<p>Output, condensed:</p>\n\n<pre><code>0\n1\n2\n3\n...\n69996\n69997\n69998\n69999\n71875  // discontinuity!\n71876\n71877\n71878\n...\n79058\n79059\n79060\n79061\n70000  // discontinuity!\n70001\n70002\n70003\n...\n71871\n71872\n71873\n71874\n79062  // discontinuity!\n79063\n79064\n79065\n79066\n...\n114996\n114997\n114998\n114999\n</code></pre>\n\n<p>The <code>size()</code> of <code>output</code> is <code>115000</code>, and all elements appear to be there, just in a slightly different order.</p>\n\n<p>So I wrote some checking code to see if the <code>sort</code> was stable.  If it's stable, then all of the <code>value1</code> values should remain in order.  This code verifies the order, printing any discrepancies.</p>\n\n<pre><code>int prev = -1;\nboolean verified = true;\nfor (Record record : output)\n{\n    int curr = record.getValue1();\n    if (prev != -1)\n    {\n        if (prev + 1 != curr)\n        {\n            System.out.println(\"Warning: \" + prev + \" followed by \" + curr + \"!\");\n            verified = false;\n        }\n    }\n    prev = curr;\n}\nSystem.out.println(\"Verified: \" + verified);\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>Warning: 69999 followed by 71875!\nWarning: 79061 followed by 70000!\nWarning: 71874 followed by 79062!\nWarning: 99999 followed by 100625!\nWarning: 107811 followed by 100000!\nWarning: 100624 followed by 107812!\nVerified: false\n</code></pre>\n\n<p>This condition persists if I do any of the following:</p>\n\n<ul>\n<li><p>Replace the <code>ForkJoinPool</code> with a <code>ThreadPoolExecutor</code>.</p>\n\n<pre><code>ThreadPoolExecutor pool = new ThreadPoolExecutor(8, 8, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10));\n</code></pre></li>\n<li><p>Use the common <code>ForkJoinPool</code> by processing the <code>Stream</code> directly.</p>\n\n<pre><code>List&lt;Record&gt; output = stream.collect(Collectors.toList());\n</code></pre></li>\n<li><p>Call <code>parallel()</code> <em>after</em> I call <code>sorted</code>.</p>\n\n<pre><code>Stream&lt;Record&gt; stream = list.stream().sorted().parallel();\n</code></pre></li>\n<li><p>Call <code>parallelStream()</code> instead of <code>stream().parallel()</code>.</p>\n\n<pre><code>Stream&lt;Record&gt; stream = list.parallelStream().sorted();\n</code></pre></li>\n<li><p>Sort using a <code>Comparator</code>.  Note that this sort criterion is different that the \"natural\" order I defined for the <code>Comparable</code> interface, although starting with the results already in order from the beginning, the result should still be the same.</p>\n\n<pre><code>Stream&lt;Record&gt; stream = list.stream().parallel().sorted(\n    (r1, r2) -&gt; Integer.compare(r1.getCategory2(), r2.getCategory2())\n);\n</code></pre></li>\n</ul>\n\n<p>I can only get this to preserve the encounter order if I don't do one of the following on the <code>Stream</code>:</p>\n\n<ul>\n<li>Don't call <code>parallel()</code>.</li>\n<li>Don't call any overload of <code>sorted</code>.</li>\n</ul>\n\n<p>Interestingly, the <code>parallel()</code> without a sort preserved the order.</p>\n\n<p>In both of the above cases, the output is:</p>\n\n<pre><code>Verified: true\n</code></pre>\n\n<p>My Java version is 1.8.0_05.  This anomaly also <a href=\"http://ideone.com/vli0tC\">occurs on Ideone</a>, which appears to be running Java 8u25.</p>\n\n<p><strong>Update</strong></p>\n\n<p>I've upgraded my JDK to the latest version as of this writing, 1.8.0_45, and the problem is unchanged.</p>\n\n<p><strong>Question</strong></p>\n\n<p>Is the record order in the resultant <code>List</code> (<code>output</code>) out of order because the sort is somehow not stable, because the encounter order is not preserved, or some other reason?</p>\n\n<p>How can I ensure that the encounter order is preserved when I create a parallel stream and sort it?</p>\n    ","a":"\n<p>It looks like <code>Arrays.parallelSort</code> isn't stable in some circumstances. Well spotted. The stream parallel sort is implemented in terms of <code>Arrays.parallelSort</code>, so it affects streams as well. Here's a simplified example:</p>\n\n<pre><code>public class StableSortBug {\n    static final int SIZE = 50_000;\n\n    static class Record implements Comparable&lt;Record&gt; {\n        final int sortVal;\n        final int seqNum;\n\n        Record(int i1, int i2) { sortVal = i1; seqNum = i2; }\n\n        @Override\n        public int compareTo(Record other) {\n            return Integer.compare(this.sortVal, other.sortVal);\n        }\n    }\n\n    static Record[] genArray() {\n        Record[] array = new Record[SIZE];\n        Arrays.setAll(array, i -&gt; new Record(i / 10_000, i));\n        return array;\n    }\n\n    static boolean verify(Record[] array) {\n        return IntStream.range(1, array.length)\n                        .allMatch(i -&gt; array[i-1].seqNum + 1 == array[i].seqNum);\n    }\n\n    public static void main(String[] args) {\n        Record[] array = genArray();\n        System.out.println(verify(array));\n        Arrays.sort(array);\n        System.out.println(verify(array));\n        Arrays.parallelSort(array);\n        System.out.println(verify(array));\n    }\n}\n</code></pre>\n\n<p>On my machine (2 core x 2 threads) this prints the following:</p>\n\n<pre><code>true\ntrue\nfalse\n</code></pre>\n\n<p>Of course, it's supposed to print <code>true</code> three times. This is on the current JDK 9 dev builds. I wouldn't be surprised if it occurs in all the JDK 8 releases thus far, given what you've tried. Curiously, reducing the size or the divisor will change the behavior. A size of 20,000 and a divisor of 10,000 is stable, and a size of 50,000 and a divisor of 1,000 is also stable. It seems like the problem has to do with a sufficiently large run of values comparing equal versus the parallel split size.</p>\n\n<p>The OpenJDK issue <a href=\"https://bugs.openjdk.java.net/browse/JDK-8076446\" rel=\"nofollow\">JDK-8076446</a> covers this bug.</p>\n    "},{"t":"Java 8 functional interface ambiguous reference (is this a bug?)","l":"http://stackoverflow.com/questions/25653204/java-8-functional-interface-ambiguous-reference-is-this-a-bug","q":"\n\n<p>I have two functions similar to these ones:</p>\n\n<pre><code>public static &lt;In extends Number, Out extends Number&gt; Out test(In in, Function&lt;In, Out&gt; f) {\n    Out x = f.apply(in);\n    return test(in, x);\n}\n\npublic static &lt;In extends Number, Out extends Number&gt; Out test(In in, Out out) {\n    return out;\n}\n</code></pre>\n\n<p>To me it is obvious that they cannot(!) clash and that calls cannot be ambiguous. However, with the most recent version of Java 8, the following call fails:</p>\n\n<pre><code>Test.test(2, Integer::new);\n</code></pre>\n\n<p>with <code>Error:(17, 16) java: reference to test is ambiguous\n  both method &lt;In,Out&gt;test(In,java.util.function.Function&lt;In,Out&gt;) in org.test and method &lt;In,Out&gt;test(In,Out) in org.test match</code></p>\n\n<p>while</p>\n\n<pre><code>Test.test(2, new Function&lt;Integer, Number&gt;() {\n    @Override\n    public Number apply(Integer integer) {\n       return 10;\n    }\n});\n</code></pre>\n\n<p>and</p>\n\n<pre><code>Test.test(2, (Function&lt;Integer, Number&gt;) integer -&gt; 10);\n</code></pre>\n\n<p>work.</p>\n\n<p>Is this a bug in the compiler (or should this fail?)</p>\n\n<p>More information about my setup below</p>\n\n<p>Java version:</p>\n\n<pre><code>Desktop $ java -version\njava version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n</code></pre>\n\n<p>Error:</p>\n\n<pre><code>Test.java:5: error: reference to test is ambiguous\n    Test.test(2, Integer::new);\n        ^\nboth method &lt;In#1,Out#1&gt;test(In#1,Function&lt;In#1,Out#1&gt;) in Test and method   &lt;In#2,Out#2&gt;test(In#2,Out#2) in Test match\nwhere In#1,Out#1,In#2,Out#2 are type-variables:\nIn#1 extends Number declared in method &lt;In#1,Out#1&gt;test(In#1,Function&lt;In#1,Out#1&gt;)\nOut#1 extends Number declared in method &lt;In#1,Out#1&gt;test(In#1,Function&lt;In#1,Out#1&gt;)\nIn#2 extends Number declared in method &lt;In#2,Out#2&gt;test(In#2,Out#2)\nOut#2 extends Number declared in method &lt;In#2,Out#2&gt;test(In#2,Out#2)\n</code></pre>\n\n<p>Test program:</p>\n\n<pre><code>import java.util.function.Function;\n\npublic class Test {\n  public static void main(String[] args) {\n    Test.test(2, Integer::new);\n  }\n\n  public static &lt;In extends Number, Out extends Number&gt; Out test(In in, Function&lt;In, Out&gt; f) {\n    Out x = f.apply(in);\n    return test(in, x);\n  }\n\n  public static &lt;In extends Number, Out extends Number&gt; Out test(In in, Out out) {\n    return out;\n  }\n}\n</code></pre>\n\n<hr>\n\n<p>Since the issue is confirmed by others, I've reported it as a bug to Oracle.</p>\n    ","a":"\n<p><code>Test.test(2, Integer::new);</code> should not fail. Indeed, it does <em>not</em> fail for me. Running:</p>\n\n<pre><code>C:\\Users\\David&gt;java -version\njava version \"1.8.0_20\"\nJava(TM) SE Runtime Environment (build 1.8.0_20-b26)\nJava HotSpot(TM) 64-Bit Server VM (build 25.20-b23, mixed mode)\nC:\\Users\\David&gt;javac -version\njavac 1.8.0_20\n</code></pre>\n\n<p>From what I can tell, this is the most recent. What platform are you working on?</p>\n\n<p>As it turns out, this is a bug on OSX (and not on Windows). If someone has a *NIX box, they should also test OP's code.</p>\n    "},{"t":"Lambdas and generics in Java 8","l":"http://stackoverflow.com/questions/13761405/lambdas-and-generics-in-java-8","q":"\n\n<p>I'm playing with future java 8 release aka JDK 1.8.</p>\n\n<p>And I found out that you can easily do</p>\n\n<pre><code>interface Foo { int method(); }\n</code></pre>\n\n<p>and use it like</p>\n\n<pre><code>Foo foo = () -&gt; 3;\nSystem.out.println(\"foo.method(); = \" + foo.method());\n</code></pre>\n\n<p>which simply prints 3.</p>\n\n<p>And I also found that there is a java.util.function.Function interface which does this in a more generic fashion. However this code won't compile</p>\n\n<pre><code>Function times3 = (Integer triple) -&gt; 3 * triple;\nInteger twelve = times3.map(4);\n</code></pre>\n\n<p>And it seems that I first have to do something like</p>\n\n<pre><code>interface IntIntFunction extends Function&lt;Integer, Integer&gt; {}\n\nIntIntFunction times3 = (Integer triple) -&gt; 3 * triple;\nInteger twelve = times3.map(4);\n</code></pre>\n\n<p>So I'm wondering if there is another way to avoid the IntIntFunction step?</p>\n    ","a":"\n<p>@joop and @edwin thanks.</p>\n\n<p>Based on latest release of JDK 8 this should do it.</p>\n\n<pre><code>IntFunction&lt;Integer&gt; times3 = (Integer triple) -&gt; 3 * triple;\n</code></pre>\n\n<p>And in case you do not like  you can make it a bit more smooth with something like</p>\n\n<pre><code>IntFunction times3 = triple -&gt; 3 * (Integer) triple;\n</code></pre>\n\n<p>So you do not need to specify a type or parentheses but you'll need to cast the parameter when you access it.</p>\n    "},{"t":"Java default methods is slower than the same code but in an abstract class","l":"http://stackoverflow.com/questions/30312096/java-default-methods-is-slower-than-the-same-code-but-in-an-abstract-class","q":"\n\n<p>I have an interface <code>PackedObject</code>:</p>\n\n<pre><code>public interface PackedObject {\n    int get();\n    int sum();\n    void setIndex(int index);\n    default int defaultSum() {\n        return get();\n    }\n}\n</code></pre>\n\n<p>An abstract class <code>AbstractPackedObject</code>:</p>\n\n<pre><code>public abstract class AbstractPackedObject implements PackedObject {\n    protected int index = 0;\n    protected int[] buffer;\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    public void setBuffer(int[] buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public int sum(){\n        return get();\n    }\n}\n</code></pre>\n\n<p>And a concrete implemention <code>WrappedPackedObject</code>:</p>\n\n<pre><code>public class WrappedPackedObject extends AbstractPackedObject implements PackedObject {\n\n    public WrappedPackedObject(int[] buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public int get() {\n        return buffer[index];\n    }\n}\n</code></pre>\n\n<p>I benchmarked <code>defaultSum</code> and <code>sum</code> methods (snippet of the JMH benchmark):</p>\n\n<pre><code>    for (int i = 0; i &lt; NB; i++) {\n        packedObject.setIndex(i);\n        value += packedObject.defaultSum();\n    }\n\n    for (int i = 0; i &lt; NB; i++) {\n        packedObject.setIndex(i);\n        value += packedObject.sum();\n    }\n</code></pre>\n\n<p><strong>I try to figure why the <code>sum</code> benchmarker is faster than the <code>defaultSum</code> benchmark by a factor of 1.7.</strong></p>\n\n<p>I have start to dig into the JIT arcane. Call site targets only one method, so I'm expecting inlining to be done. The output of print inlining is the following:</p>\n\n<pre><code>@ 25   com.github.nithril.PackedObject::defaultSum (7 bytes)   inline (hot)\n \\-&gt; TypeProfile (479222/479222 counts) = com/github/nithril/WrappedPackedObject\n  @ 1   com.github.nithril.WrappedPackedObject::get (14 bytes)   inline (hot)\n    @ 10   java.nio.DirectByteBuffer::getInt (15 bytes)   inline (hot)\n\n\n@ 25   com.github.nithril.AbstractPackedObject::sum (5 bytes)   inline (hot)\n  @ 1   com.github.nithril.WrappedPackedObject::get (14 bytes)   inline (hot)\n    @ 10   java.nio.DirectByteBuffer::getInt (15 bytes)   inline (hot)\n</code></pre>\n\n<p>I don't yet understand why this line appears <code>TypeProfile (479222/479222 counts) = com/github/nithril/WrappedPackedObject</code></p>\n\n<p>I create a <a href=\"https://github.com/nithril/packedobject-test\" rel=\"nofollow\">dedicated project</a> with the above code. The benchmark is done using JMH.</p>\n\n<p>Thanks for your help.</p>\n\n<p><strong>EDIT 2015/05/20:</strong></p>\n\n<p>I simplify the java code.</p>\n\n<p>The inner loop of the <code>benchSum</code> is quite straightforward:</p>\n\n<pre><code>0x00007f1bb11afb84: add    0x10(%r10,%r8,4),%eax  ;*iadd\n                                              ; - com.github.nithril.PackedObjectBench::benchSum@29 (line 50)\n0x00007f1bb11afb89: mov    %r8d,0xc(%r12,%r11,8)  ;*putfield index\n                                              ; - com.github.nithril.AbstractPackedObject::setIndex@2 (line 13)\n                                              ; - com.github.nithril.PackedObjectBench::benchSum@17 (line 49)\n0x00007f1bb11afb8e: inc    %r8d               ;*iinc\n                                              ; - com.github.nithril.PackedObjectBench::benchSum@31 (line 48)\n0x00007f1bb11afb91: cmp    $0x2710,%r8d\n0x00007f1bb11afb98: jl     0x00007f1bb11afb84\n</code></pre>\n\n<p>The inner loop of the <code>benchDefaultSum</code> is more complicated with read/write of the index and inside the inner loop a comparison of the array bound. I do not yet completely understand the purpose of this comparison...</p>\n\n<pre><code>0x00007fcfdcf82cb8: mov    %edx,0xc(%r12,%r11,8)  ;*putfield index\n                                              ; - com.github.nithril.AbstractPackedObject::setIndex@2 (line 13)\n                                              ; - com.github.nithril.PackedObjectBench::benchDefaultSum@17 (line 32)\n0x00007fcfdcf82cbd: mov    0xc(%r10),%r8d     ;*getfield index\n                                              ; - com.github.nithril.WrappedPackedObject::get@5 (line 17)\n                                              ; - com.github.nithril.PackedObject::defaultSum@1 (line 15)\n                                              ; - com.github.nithril.PackedObjectBench::benchDefaultSum@24 (line 33)\n0x00007fcfdcf82cc1: cmp    %r9d,%r8d\n0x00007fcfdcf82cc4: jae    0x00007fcfdcf82d1f  ;*iaload\n                                              ; - com.github.nithril.WrappedPackedObject::get@8 (line 17)\n                                              ; - com.github.nithril.PackedObject::defaultSum@1 (line 15)\n                                              ; - com.github.nithril.PackedObjectBench::benchDefaultSum@24 (line 33)\n0x00007fcfdcf82cc6: add    0x10(%rcx,%r8,4),%eax  ;*iadd\n                                              ; - com.github.nithril.PackedObjectBench::benchDefaultSum@29 (line 33)\n0x00007fcfdcf82ccb: inc    %edx               ;*iinc\n                                              ; - com.github.nithril.PackedObjectBench::benchDefaultSum@31 (line 31)\n0x00007fcfdcf82ccd: cmp    $0x2710,%edx\n0x00007fcfdcf82cd3: jl     0x00007fcfdcf82cb8  ;*aload_2\n[...]\n0x00007fcfdcf82ce6: mov    $0xffffffe4,%esi\n0x00007fcfdcf82ceb: mov    %r10,0x8(%rsp)\n0x00007fcfdcf82cf0: mov    %ebx,0x4(%rsp)\n0x00007fcfdcf82cf4: mov    %r8d,0x10(%rsp)\n0x00007fcfdcf82cf9: xchg   %ax,%ax\n0x00007fcfdcf82cfb: callq  0x00007fcfdcdea1a0  ; OopMap{rbp=NarrowOop [8]=Oop off=416}\n                                              ;*iaload\n                                              ; - com.github.nithril.WrappedPackedObject::get@8 (line 17)\n                                              ; - com.github.nithril.PackedObject::defaultSum@1 (line 15)\n                                              ; - com.github.nithril.PackedObjectBench::benchDefaultSum@24 (line 33)\n                                              ;   {runtime_call}\n0x00007fcfdcf82d00: callq  0x00007fcff1c94320  ;*iaload\n                                              ; - com.github.nithril.WrappedPackedObject::get@8 (line 17)\n                                              ; - com.github.nithril.PackedObject::defaultSum@1 (line 15)\n                                              ; - com.github.nithril.PackedObjectBench::benchDefaultSum@24 (line 33)\n                                              ;   {runtime_call}\n[...]\n0x00007fcfdcf82d1f: mov    %eax,(%rsp)\n0x00007fcfdcf82d22: mov    %edx,%ebx\n0x00007fcfdcf82d24: jmp    0x00007fcfdcf82ce6\n</code></pre>\n    ","a":"\n<p>Just regurgitating information that i've picked up by cursory reading of the <a href=\"http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2015-April/thread.html#17649\" rel=\"nofollow\">hotspot-compiler-dev</a> mailing list, but this may be the lack of <em>class hierarchy analysis</em> for default methods in interfaces, which prevents devirtualization of interface methods.</p>\n\n<p>See <a href=\"https://bugs.openjdk.java.net/browse/JDK-8065760\" rel=\"nofollow\">JDK Bug 8065760</a> and <a href=\"https://bugs.openjdk.java.net/browse/JDK-6986483\" rel=\"nofollow\">6986483</a></p>\n\n<hr>\n\n<p>My guess is that even though the method is inlined it still is by preceded by a type guard that gets eliminated by CHA in the abstract case but not for the interface method.</p>\n\n<p>Printing optimized assembly (i think JMH has some flag for that) could confirm that.</p>\n    "},{"t":"Convert java.time `LocalDate` into `java.util.Date` type","l":"http://stackoverflow.com/questions/22929237/convert-java-time-localdate-into-java-util-date-type","q":"\n\n<p>I want to convert <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html\"><code>java.time.LocalDate</code></a> into <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Date.html\"><code>java.util.Date</code></a> type. Because I want to set the date into <code>JDateChooser</code>. Or is there anydate choosers supports <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html\"><code>java.time</code></a> dates?</p>\n    ","a":"\n<pre><code>Date date = Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());\n</code></pre>\n\n<p>That assumes your date chooser uses the system default timezone to transform dates into strings.</p>\n    "},{"t":"java 8 stream reverse order","l":"http://stackoverflow.com/questions/24010109/java-8-stream-reverse-order","q":"\n\n<p>General question : Whats the proper way to reverse a stream? Assuming that we dont know what type of elements that stream consists of, what's the generic way to reverse any stream?</p>\n\n<p>Specific question : </p>\n\n<p>IntStream provides range method to generate Integers in specific range IntStream.range(-range, 0), now that I want to reverse it switching range from 0 to negative wont work, also I cant use Integer::compare</p>\n\n<pre><code>    List&lt;Integer&gt; list = Arrays.asList(1,2,3,4);\n    list.stream().sorted(Integer::compare).forEach(System.out::println);\n</code></pre>\n\n<p>with IntStream I'll get this compiler error</p>\n\n<pre><code>Error:(191, 0) ajc: The method sorted() in the type IntStream is not applicable for the arguments (Integer::compare)\n</code></pre>\n\n<p>what am I missing there?</p>\n    ","a":"\n<p>General Question:</p>\n\n<p>Stream does not store any elements.</p>\n\n<p>So iterating elements in the reverse order is not possible without storing the elements in some intermediate collection.</p>\n\n<pre><code>Stream.of(\"1\", \"2\", \"20\", \"3\")\n      .collect(Collectors.toCollection(LinkedList::new))\n      .descendingIterator()\n      .forEachRemaining(System.out::println);\n</code></pre>\n\n<p>Prints:</p>\n\n<pre><code>3\n\n20\n\n2\n\n1\n</code></pre>\n\n<p>By the way, using <code>sort</code> method is not correct as it sorts. NOT reverses (assuming stream may have unordered elements)</p>\n\n<p>Specific Question: </p>\n\n<p>I found this simple, easier and intuitive(Copied @Holger comment)</p>\n\n<pre><code>IntStream.iterate(to - 1, i -&gt; i - 1).limit(to - from)\n</code></pre>\n    "},{"t":"Why is a combiner needed for reduce method that converts type in java 8","l":"http://stackoverflow.com/questions/24308146/why-is-a-combiner-needed-for-reduce-method-that-converts-type-in-java-8","q":"\n\n<p>I'm having trouble fully understanding the role that the <code>combiner</code> fulfils in Streams <code>reduce</code> method. </p>\n\n<p>For example, the following code doesnt compile : </p>\n\n<pre><code>int length = asList(\"str1\", \"str2\").stream()\n            .reduce(0, (accumulatedInt, str) -&gt; accumulatedInt + str.length());\n</code></pre>\n\n<p>Compile error says : \n      <strong>(argument mismatch; int cannot be converted to java.lang.String)</strong></p>\n\n<p>but this code does compile :</p>\n\n<pre><code>int length = asList(\"str1\", \"str2\").stream()  \n    .reduce(0, (accumulatedInt, str ) -&gt; accumulatedInt + str.length(), \n                (accumulatedInt, accumulatedInt2) -&gt; accumulatedInt + accumulatedInt2);\n</code></pre>\n\n<p>I understand that the combiner method is used in parallel streams - so in my example it is adding together two intermediate accumulated ints. </p>\n\n<p>But I dont understand why the first example doesnt compile without the combiner or how the combiner is solving the conversion of string to int since it is just adding together two ints.</p>\n\n<p>Can anyone shed light on this? </p>\n    ","a":"\n<p>The two and three argument versions of <code>reduce</code> which you tried to use don't accept the same type for the <code>accumulator</code>.</p>\n\n<p>The two argument <code>reduce</code> is <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-\">defined as</a> :</p>\n\n<pre><code>T reduce(T identity,\n         BinaryOperator&lt;T&gt; accumulator)\n</code></pre>\n\n<p>In your case, T is String, so <code>BinaryOperator&lt;T&gt;</code> should accept two String arguments and return a String. But you pass to it an int and a String, which results in the compilation error you got - <code>argument mismatch; int cannot be converted to java.lang.String</code>. Actually, I think passing 0 as the identity value is also wrong here, since a String is expected (T).</p>\n\n<p>Also note that this version of reduce processes a stream of Ts and returns a T, so you can't use it to reduce a stream of String to an int.</p>\n\n<p>The three argument <code>reduce</code> is <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-U-java.util.function.BiFunction-java.util.function.BinaryOperator-\">defined as</a> :</p>\n\n<pre><code>&lt;U&gt; U reduce(U identity,\n             BiFunction&lt;U,? super T,U&gt; accumulator,\n             BinaryOperator&lt;U&gt; combiner)\n</code></pre>\n\n<p>In your case U is Integer and T is String, so this method will reduce a stream of String to an Integer.</p>\n\n<p>For the <code>BiFunction&lt;U,? super T,U&gt;</code> accumulator you can pass parameters of two different types (U and ? super T), which in your case are Integer and String. In addition, the identity value U accepts an Integer in your case, so passing it 0 is fine.</p>\n\n<p>Another way to achieve what you want :</p>\n\n<pre><code>int length = asList(\"str1\", \"str2\").stream().mapToInt (s -&gt; s.length())\n            .reduce(0, (accumulatedInt, len) -&gt; accumulatedInt + len);\n</code></pre>\n\n<p>Here the type of the stream matches the return type of <code>reduce</code>, so you can use the two parameter version of <code>reduce</code>.</p>\n\n<p>Of course you don't have to use <code>reduce</code> at all :</p>\n\n<pre><code>int length = asList(\"str1\", \"str2\").stream().mapToInt (s -&gt; s.length())\n            .sum();\n</code></pre>\n    "},{"t":"Lambda expressions don't work in Java 8?","l":"http://stackoverflow.com/questions/11176936/lambda-expressions-dont-work-in-java-8","q":"\n\n<p>I have a virtual machine running Windows XP SP3 32-bit. On this machine\nI installed the Java SE JDK 8 build b44 Developer Preview from <a href=\"http://jdk8.java.net/download.html\">here</a>.</p>\n\n<p>I also installed the JavaFX 2.1 SDK.</p>\n\n<p>It works fine:</p>\n\n<pre><code>java -version\n&gt; java version \"1.8.0-ea\"\n&gt; Java(TM) SE Runtime Environment (build 1.8.0-ea-b44)\n&gt; Java HotSpot(TM) Client VM (build 24.0-b14, mixed mode, sharing)\n</code></pre>\n\n<p>I tried running the following program (taken from <a href=\"http://www.javabeat.net/2012/05/using-lambda-expressions-of-java-8-in-java-fx-event-handlers/\">here</a>):</p>\n\n<pre><code>import javafx.application.Application;\nimport javafx.beans.property.SimpleStringProperty;\nimport javafx.beans.property.StringProperty;\nimport javafx.event.ActionEvent;\nimport javafx.event.EventHandler;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ButtonBase;\nimport javafx.scene.control.ToggleButton;\nimport javafx.scene.control.ToggleButtonBuilder;\nimport javafx.scene.layout.BorderPane;\nimport javafx.stage.Stage;\n\npublic class LambdasWithJavaFx extends Application\n{\n    public static void main(String[] args)\n    {\n        Application.launch(args);\n    }\n\n    @Override  public void start(Stage stage) throws Exception\n    {\n        BorderPane root = new BorderPane();\n        ToggleButton button = new ToggleButton(\"Click\");\n        final StringProperty btnText = button.textProperty();\n\n        button.setOnAction(new EventHandler&lt;ActionEvent&gt;()\n        {\n            @Override public void handle(ActionEvent actionEvent)\n            {\n                ToggleButton source = (ToggleButton) actionEvent.getSource();\n                if (source.isSelected())\n                {\n                    btnText.set(\"Clicked!\");\n                }\n                else\n                {\n                    btnText.set(\"Click!\");\n                }\n            }\n        });\n\n        root.setCenter(button);\n        Scene scene = new Scene(root);\n        stage.setScene(scene);\n        stage.setWidth(200);\n        stage.setHeight(200);\n        stage.show();\n    }\n}\n</code></pre>\n\n<p>The program compiled and ran as expected.</p>\n\n<p>I followed the instructions in that article and replaced the button event-handling code with this:</p>\n\n<pre><code>button.setOnAction((ActionEvent event)-&gt;\n{\n    ToggleButton source = (ToggleButton) event.getSource();\n    if (source.isSelected())\n    {\n        btnText.set(\"Clicked!\");\n    }\n    else\n    {\n        btnText.set(\"Click!\");\n    }\n});\n</code></pre>\n\n<p>When compiling, I get the following error (on the line <code>button.setOnAction((ActionEvent event)-&gt;</code>):</p>\n\n<pre><code>&gt; lambda expressions are not supported in -source 1.8\n&gt; (use -source 8 or higher to enable lambda expressions)\n</code></pre>\n\n<p>I added the argument <code>-source 8</code>, nothing changed.</p>\n\n<p>All I wanted was to check the lambda expressions functionality in Java 8. Why doesn't it work ?</p>\n    ","a":"\n<p>You need to download the binaries which contain the Lambda expressions feature. Try downloading from here <a href=\"http://jdk8.java.net/lambda/\">http://jdk8.java.net/lambda/</a>. \nI remember reading in the mailing list that the lambda expression branch is being merged in the main JDK8 build, but not sure if its been done. But I use the build from the Lambda project page. </p>\n    "},{"t":"Java 8 NullPointerException in Collectors.toMap","l":"http://stackoverflow.com/questions/24630963/java-8-nullpointerexception-in-collectors-tomap","q":"\n\n<p>The Java 8 <code>Collectors.toMap</code> throws a <code>NullPointerException</code> if one of the values is 'null'. I don't understand this behaviour, maps can contain null pointers as value without any problems. Is there a good reason why values cannot be null for <code>Collectors.toMap</code>?</p>\n\n<p>Also, is there a nice Java 8 way of fixing this, or should I revert to plain old for loop?</p>\n\n<p>An example of my problem:</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n\nclass Answer {\n    private int id;\n\n    private Boolean answer;\n\n    Answer() {\n    }\n\n    Answer(int id, Boolean answer) {\n        this.id = id;\n        this.answer = answer;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public Boolean getAnswer() {\n        return answer;\n    }\n\n    public void setAnswer(Boolean answer) {\n        this.answer = answer;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        List&lt;Answer&gt; answerList = new ArrayList&lt;&gt;();\n\n        answerList.add(new Answer(1, true));\n        answerList.add(new Answer(2, true));\n        answerList.add(new Answer(3, null));\n\n        Map&lt;Integer, Boolean&gt; answerMap =\n        answerList\n                .stream()\n                .collect(Collectors.toMap(Answer::getId, Answer::getAnswer));\n    }\n}\n</code></pre>\n\n<p>Stacktrace:</p>\n\n<pre><code>Exception in thread \"main\" java.lang.NullPointerException\n    at java.util.HashMap.merge(HashMap.java:1216)\n    at java.util.stream.Collectors.lambda$toMap$168(Collectors.java:1320)\n    at java.util.stream.Collectors$$Lambda$5/1528902577.accept(Unknown Source)\n    at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:169)\n    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1359)\n    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)\n    at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)\n    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)\n    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n    at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)\n    at Main.main(Main.java:48)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)\n</code></pre>\n    ","a":"\n<p>It is not possible with the static methods of <code>Collectors</code>. The javadoc of <a href=\"http://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Integer.html\"><code>toMap</code></a> explains that <code>toMap</code> is based on <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge-K-V-java.util.function.BiFunction-\"><code>Map.merge</code></a>:</p>\n\n<blockquote>\n  <p>@param mergeFunction a merge function, used to resolve collisions between values associated with the same key, as supplied to <code>Map#merge(Object, Object, BiFunction)}</code></p>\n</blockquote>\n\n<p>and the javadoc of <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge-K-V-java.util.function.BiFunction-\"><code>Map.merge</code></a> says: </p>\n\n<blockquote>\n  <p>@throws NullPointerException if the specified key is null and this map\n  does not support null keys or <strong>the value</strong> or remappingFunction <strong>is</strong>\n  <strong>null</strong></p>\n</blockquote>\n\n<p>You can avoid the for loop by using the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html#forEach-java.util.function.Consumer-\"><code>forEach</code></a> method of your list.</p>\n\n<pre><code>Map&lt;Integer,  Boolean&gt; answerMap = new HashMap&lt;&gt;();\nanswerList.forEach((answer) -&gt; answerMap.put(answer.getId(), answer.getAnswer()));\n</code></pre>\n\n<p>but it is not really simple than the old way:</p>\n\n<pre><code>Map&lt;Integer, Boolean&gt; answerMap = new HashMap&lt;&gt;();\nfor (Answer answer : answerList) {\n    answerMap.put(answer.getId(), answer.getAnswer());\n}\n</code></pre>\n    "},{"t":"Java 8 Streams: why does Collectors.toMap behave differently for generics with wildcards?","l":"http://stackoverflow.com/questions/27890241/java-8-streams-why-does-collectors-tomap-behave-differently-for-generics-with-w","q":"\n\n<p>Assume that you have a <code>List</code> of numbers. The values in the <code>List</code> can be of type <code>Integer</code>, <code>Double</code> etc. When you declare such a <code>List</code> it is possible to declare it using a wildcard (<code>?</code>) or without a wildcard. </p>\n\n<pre><code>final List&lt;Number&gt; numberList = Arrays.asList(1, 2, 3D);\nfinal List&lt;? extends Number&gt; wildcardList = Arrays.asList(1, 2, 3D);\n</code></pre>\n\n<p>So, now I want to <code>stream</code> over the <code>List</code> and <code>collect</code> it all to a <code>Map</code> using the <code>Collectors.toMap</code> (obviously the code below is just an example to illustrate the problem). Lets start off by streaming the <code>numberList</code>:</p>\n\n<pre><code>final List&lt;Number&gt; numberList = Arrays.asList(1, 2, 3D, 4D);\n\nnumberList.stream().collect(Collectors.toMap(\n        // Here I can invoke \"number.intValue()\" - the object (\"number\") is treated as a Number\n        number -&gt; Integer.valueOf(number.intValue()),\n        number -&gt; number));\n</code></pre>\n\n<p>But, I can not do the same operation on the <code>wildcardList</code>:</p>\n\n<pre><code>final List&lt;? extends Number&gt; wildCardList = Arrays.asList(1, 2, 3D);\nwildCardList.stream().collect(Collectors.toMap(\n        // Why is \"number\" treated as an Object and not a Number?\n        number -&gt; Integer.valueOf(number.intValue()),\n        number -&gt; number));\n</code></pre>\n\n<p>The compiler complains on the call to <code>number.intValue()</code> with the following message:</p>\n\n<blockquote>\n  <p>Test.java: cannot find symbol<br>\n  symbol:   method intValue()<br>\n  location: variable number of type java.lang.Object</p>\n</blockquote>\n\n<p>From the compiler error it is obvious that the <code>number</code> in the lambda is treated as an <code>Object</code> instead of as a <code>Number</code>. </p>\n\n<p>So, now to my question(s): </p>\n\n<ul>\n<li>When collecting the wildcard version of the <code>List</code>, why is it not working like the non-wildcard version of the <code>List</code>? </li>\n<li>Why is the <code>number</code> variable in the lambda considered to be an <code>Object</code> instead of a <code>Number</code>?</li>\n</ul>\n    ","a":"\n<p>It's the type inference that doesn't get it right. If you provide the type argument explicitly it works as expected:</p>\n\n<pre><code>List&lt;? extends Number&gt; wildCardList = Arrays.asList(1, 2, 3D);\nwildCardList.stream().collect(Collectors.&lt;Number, Integer, Number&gt;toMap(\n                                  number -&gt; Integer.valueOf(number.intValue()),\n                                  number -&gt; number));\n</code></pre>\n\n<p>This is a known javac bug: <a href=\"https://bugs.openjdk.java.net/browse/JDK-8039214\">Inference should not map capture variables to their upper bounds</a>. The status, according to Maurizio Cimadamore,</p>\n\n<blockquote>\n  <p><em>a fix was attempted then backed out as it was breaking cases in 8, so we went for a more conservative fix in 8 while doing the full thing in 9</em></p>\n</blockquote>\n\n<p>Apparently the fix has not yet been pushed. (Thanks to <a href=\"http://stackoverflow.com/users/38222/joel-borggr%C3%A9n-franck\">\nJoel Borggrén-Franck</a> for pointing me in the right direction.)</p>\n    "},{"t":"What do the constructs \\H, \\V and \\N mean?","l":"http://stackoverflow.com/questions/26972688/what-do-the-constructs-h-v-and-n-mean","q":"\n\n<p>The following constructs are not well documented, but they do work as of specific versions of PHP onwards; Which are these versions, what are these constructs and which other implementations support this?</p>\n\n<ul>\n<li><code>\\H</code></li>\n<li><code>\\V</code></li>\n<li><code>\\N</code></li>\n</ul>\n\n<hr>\n\n<p>This thread is part of <a href=\"http://stackoverflow.com/a/22944075/3622940\">The Stack Overflow Regex Reference</a>.</p>\n    ","a":"\n<p><code>\\H</code> matches anything which aren't horizontal whitespace. This includes tab character and all \"space separator\" Unicode characters. This is the same as:</p>\n\n\n\n<pre class=\"lang-regex prettyprint-override\"><code>[^\\h] <i>or</i>\n[^\\t\\p{Zs}]</code></pre>\n\n<p><code>\\V</code> is the negated class of <code>\\v</code> - It is named \"non vertical whitespace character\" and matches any characters which aren't a vertical whitespace character of those which are treated as line breaks in the Unicode standard and would be matched by <code>\\v</code>, and is the same as the following as introduced in Perl 5:</p>\n\n<pre class=\"lang-regex prettyprint-override\"><code>[^\\v] <i>or</i>\n[^\\n\\cK\\f\\r\\x85\\x{2028}\\x{2029}]</code></pre>\n\n<p><code>\\N</code> matches any characters which aren't the line feed character <code>\\n</code>. Simple!</p>\n\n<pre class=\"lang-regex prettyprint-override\"><code>[^\\n]\n</code></pre>\n\n<h3>What's the difference between <strong><code>\\V+</code></strong> and <strong><code>\\N+</code></strong> ?<sub>Thanks to <a href=\"http://stackoverflow.com/users/3297613/avinash-raj\">Avinash Raj</a> for asking.</sub></h3>\n\n<p>As Perl 5.10 specified in the documentation, <strong><code>\\V</code></strong> is the same as <strong><code>[^\\n\\cK\\f\\r\\x85\\x{2028}\\x{2029}]</code></strong> and shouldn't match any of <strong><code>\\n</code></strong>, <strong><code>\\r</code></strong> or <strong><code>\\f</code></strong>, as well as <em><code>Ctrl+(Control char)</code></em> (*nix), <a href=\"http://www.fileformat.info/info/unicode/char/85/index.htm\"><em><code>0x85</code></em></a>, <a href=\"http://www.fileformat.info/info/unicode/char/2028/index.htm\"><em><code>0x2028</code></em></a> and <a href=\"http://www.fileformat.info/info/unicode/char/2029/index.htm\"><em><code>0x2029</code></em></a>.</p>\n\n<p>These character classes are handy and incredibly effective for when you want to match everything within the horizontal text - <code>\\V+</code> - or simply consuming an entire paragraph - <code>\\N+</code> - among various other use cases.</p>\n\n<p><br></p>\n\n<p>The following implementations supports <code>\\H</code>, <code>\\V</code> and <code>\\N</code>:</p>\n\n<ul>\n<li>Perl 5.10</li>\n<li>PCRE 7.2</li>\n<li>PHP programmers may find a discrepancy over which versions supports these constructs. As they came from Perl 5, one has to set the PCRE version instead; You can check this using <a href=\"http://php.net/manual/en/function.phpinfo.php\"><code>phpinfo()</code></a>. By default, PHP 5.2.2 does.</li>\n<li><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html\">Java 8 <code>java.util.regex.Pattern</code></a> support for <code>\\H</code> and <code>\\V</code> constructs has been added as part of implementing <code>\\h</code>, <code>\\v</code>, which was <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html\">not true for Java 7</a>, however <code>\\N</code> is not yet supported. <a href=\"http://i.stack.imgur.com/pBtMk.png\">Tested with JDK8u25.</a></li>\n</ul>\n    "},{"t":"Turn a List of Lists into a List Using Lambdas","l":"http://stackoverflow.com/questions/25147094/turn-a-list-of-lists-into-a-list-using-lambdas","q":"\n\n<p>If I have a <code>List&lt;List&lt;Object&gt;&gt;</code> can I turn it into a <code>List&lt;Object&gt;</code> that contains all the objects using continuous (not breaking the invocation sequence) invocations of lambdas?</p>\n    ","a":"\n<p>You can use <code>flatMap</code> to flatten the internal lists (after converting them to Streams) into a single Stream, and then collect the result into a list :</p>\n\n<pre><code>List&lt;List&lt;Object&gt;&gt; list = ...\nList&lt;Object&gt; flat = \n    list.stream()\n        .flatMap(l -&gt; l.stream())\n        .collect(Collectors.toList());\n</code></pre>\n    "},{"t":"What is a 'SAM type' in Java?","l":"http://stackoverflow.com/questions/17913409/what-is-a-sam-type-in-java","q":"\n\n<p>Reading up on the Java-8 spec, I keep seeing references to 'SAM types'. I haven't been able to find a clear explanation of what this is.</p>\n\n<p>What is a SAM type and what is an example scenario of when one might be used?</p>\n    ","a":"\n<p>To summarize <a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-3.html\">the link Jon posted</a> in case it ever goes down, \"SAM\" stands for \"single abstract method\", and \"SAM-type\" refers to interfaces like <code>Runnable</code>, <code>Callable</code>, etc. Lambda expressions, a new feature in Java 8, are considered a SAM type and can be freely converted to them.</p>\n\n<p>For example, with an interface like this:</p>\n\n<pre><code>public interface Callable&lt;T&gt; {\n    public T call();\n}\n</code></pre>\n\n<p>You can declare a <code>Callable</code> using lambda expressions like this:</p>\n\n<pre><code>Callable&lt;String&gt; strCallable = #{ \"Hello world!\" };\nSystem.out.println(strCallable.call()); // prints \"Hello world!\"\n</code></pre>\n\n<p>Lambda expressions in this context are mostly just syntactic sugar. They look better in code than anonymous classes and are less restrictive on method naming. Take this example from the link:</p>\n\n<pre><code>class Person { \n    private final String name;\n    private final int age;\n\n    public static int compareByAge(Person a, Person b) { ... }\n\n    public static int compareByName(Person a, Person b) { ... }\n}\n\nPerson[] people = ...\nArrays.sort(people, #Person.compareByAge);\n</code></pre>\n\n<p>This creates a <code>Comparator</code> using a specific method that doesn't share the same name as <code>Comparator.compare</code>, that way you don't have to follow the interface naming of methods and you can have multiple comparison overrides in a class, then create the comparators on the fly via the lambda expressions.</p>\n\n<hr>\n\n<p>As a sidenote, the syntax on the link is out of date. Take a look at the <a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\">Lambda Expressions Java Trail</a> to see the current syntax.</p>\n    "},{"t":"Why is the combiner of the Collector interface not consistent with the overloaded collect method?","l":"http://stackoverflow.com/questions/30309127/why-is-the-combiner-of-the-collector-interface-not-consistent-with-the-overloade","q":"\n\n<p>There is an overload method, <code>collect()</code>, in interface <code>Stream&lt;T&gt;</code> with the following signature: </p>\n\n<pre><code>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,\n          BiConsumer&lt;R,? super T&gt; accumulator,\n          BiConsumer&lt;R,R&gt; combiner)\n</code></pre>\n\n<p>There is another version of <code>collect(Collector&lt;? super T,A,R&gt; collector)</code>, which receives an object with the previous three functions. The property of the interface <code>Collector</code> corresponding to the <code>combiner</code> has the signature <code>BinaryOperator&lt;A&gt; combiner()</code>.</p>\n\n<p>In the latter case, the Java API 8 states that: </p>\n\n<blockquote>\n  <p>The combiner function may fold state from one argument into the other and return that, or may return a new result container.</p>\n</blockquote>\n\n<p>Why does the former <code>collect</code> method not receive a <code>BinaryOperator&lt;R&gt;</code> too?</p>\n    ","a":"\n<p>The \"inline\" (3-arg) version of <code>collect</code> is designed for when you already have these functions \"lying around\".  For example:</p>\n\n<pre><code>ArrayList&lt;Foo&gt; list = stream.collect(ArrayList::new, \n                                     ArrayList::add,\n                                     ArrayList::addAll);\n</code></pre>\n\n<p>Or</p>\n\n<pre><code>BitSet bitset = stream.collect(BitSet::new, \n                               BitSet::set,\n                               BitSet::or);\n</code></pre>\n\n<p>While these are just motivating examples, our explorations with similar existing builder classes was that the signatures of the existing combiner candidates were more suited to conversion to BiConsumer than to BinaryOperator.  Offering the \"flexibility\" you ask for would make this overload far less useful in the very cases it was designed to support -- which is when you've already got the functions lying around, and you don't want to have to make (or learn about making) a Collector just to collect them.</p>\n\n<p>Collector, on the other hand, has a far wider range of uses, and so merits the additional flexibility.</p>\n    "},{"t":"Java 8: stop reduction operation from examining all Stream elements","l":"http://stackoverflow.com/questions/30740709/java-8-stop-reduction-operation-from-examining-all-stream-elements","q":"\n\n<p>I am trying to understand if there is a way to terminate reduction operation without examining the whole stream and I cannot figure out a way.</p>\n\n<p>The use-case is roughly as follows: let there be a long list of <code>Integer</code>s which needs to be folded into an <code>Accumulator</code>. Each element examination is potentially expensive, so within the <code>Accumulator</code>, I perform a check on the incoming <code>Accumulator</code> to see if we even need to perform expensive operation - if we don't, then I simply return the accumulator.</p>\n\n<p>This is obviously a fine solution for small(er) lists but huge lists incur unnecessary stream element visiting costs I'd like to avoid.</p>\n\n<p>Here's a code sketch - assume serial reductions only.</p>\n\n<pre><code>class Accumulator {\n    private final Set&lt;A&gt; setA = new HashSet&lt;&gt;;\n    private final Set&lt;B&gt; setB = new HashSet&lt;&gt;;\n}\n\nclass ResultSupplier implements Supplier&lt;Result&gt; {\n\n    private final List&lt;Integer&gt; ids;\n\n    @Override\n    public Result get() {\n        Accumulator acc = ids.stream().reduce(new Accumulator(), f(), (x, y) -&gt; null);\n\n        return (acc.setA.size &gt; 1) ? Result.invalid() : Result.valid(acc.setB);\n    }\n\n    private static BiFunction&lt;Accumulator, Integer, Accumulator&gt; f() {\n        return (acc, element) -&gt; {\n            if (acc.setA.size() &lt;= 1) {\n                // perform expensive ops and accumulate results\n            }\n            return acc;\n        };\n    }\n}\n</code></pre>\n\n<p>In addition to having to traverse the whole <code>Stream</code>, there is another fact I dislike - I have to check the same condition <em>twice</em> (namely, <code>setA</code> size check).</p>\n\n<p>I have considered <code>map()</code> and <code>collect()</code> operations but they just seemed like more of the same and didn't find they materially change the fact that I just can't finish the fold operation without examining the entire stream.</p>\n\n<p>Additionally, my thinking is that imaginary <code>takeWhile(p : (A) =&gt; boolean)</code> Stream API correspondent would also buy us nothing, as the terminating condition depends on the accumulator, not stream elements per se.</p>\n\n<p>Bear in mind I am a relative newcomer to FP so - is there a way to make this work as I expect it? Have I set up the whole problem improperly or is this limitation by design?</p>\n    ","a":"\n<p>Of course, there will be an interesting, purely FP answer that might help solve this problem in the way you intend.</p>\n\n<p>In the meantime, why use FP at all when the simple solution is pragmatically imperative and your original data source is a <code>List</code> anyway, which is already fully materialised, and you will use serial reduction, not parallel reduction. Write this instead:</p>\n\n<pre><code>@Override\npublic Result get() {\n    Accumulator acc = new Accumulator();\n\n    for (Integer id : ids) {\n        if (acc.setA.size() &lt;= 1) {\n            // perform expensive ops and accumulate results\n        }\n\n        // Easy:\n        if (enough)\n            break;\n    }\n\n    return (acc.setA.size &gt; 1) ? Result.invalid() : Result.valid(acc.setB);\n}\n</code></pre>\n    "},{"t":"Can a Java 8 `Stream` be parallel without you even asking for it?","l":"http://stackoverflow.com/questions/27934587/can-a-java-8-stream-be-parallel-without-you-even-asking-for-it","q":"\n\n<p>As I see it, the obvious code, when using Java 8 <code>Stream</code>s, whether they be \"object\" streams or primitive streams (that is, <code>IntStream</code> and friends) would be to just use:</p>\n\n<pre><code>someStreamableResource.stream().whatever()\n</code></pre>\n\n<p>But then, quite a few \"streamable resources\" also have <code>.parallelStream()</code>.</p>\n\n<p>What isn't clear when reading the javadoc is whether <code>.stream()</code> streams are always sequential, and whether <code>.parallelStream()</code> streams are always parallel...</p>\n\n<p>And then there is <code>Spliterator</code>, and in particular its <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#characteristics--\"><code>.characteristics()</code></a>, one of them being that it can be <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#CONCURRENT\"><code>CONCURRENT</code></a>, or even <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#IMMUTABLE\"><code>IMMUTABLE</code></a>.</p>\n\n<p>My gut feeling is that in fact, whether a <code>Stream</code> can be, or not, parallel by default, or parallel at all, is guided by its underlying <code>Spliterator</code>...</p>\n\n<p>Am I on the right track? I have read, and read again, the javadocs, and still cannot come up with a clear answer to this question...</p>\n    ","a":"\n<p>First, through the lens of <em>specification</em>.  Whether a stream is parallel or sequential is part of a stream's state.  Stream-creation methods should specify whether they create a sequential or parallel stream (and most in the JDK do), but they are not required to say so.  If your stream source doesn't say, don't assume.  If someone passes you a stream, don't assume.  </p>\n\n<p>Parallel streams are allowed to fall back to sequential at their discretion (since a sequential implementation <em>is</em> a parallel implementation, just a potentially imperfect one); the opposite is not true.  </p>\n\n<p>Now, through the lens of <em>implementation</em>.  In the stream-creation methods in Collections and other JDK classes, we stick to a discipline of \"create a sequential stream unless the user explicitly asks for parallelism\".  (Other libraries, however, make different choices.  If they're polite, they'll specify their behavior.)</p>\n\n<p>The relationship between stream parallelism and Spliterator only goes in one direction.  A Spliterator can refuse to split -- effectively denying any parallelism -- but it can't <em>demand</em> that a client split it.  So an uncooperative Spliterator can undermine parallelism, but not determine it.</p>\n    "},{"t":"Mocking time in Java 8's java.time API","l":"http://stackoverflow.com/questions/24491260/mocking-time-in-java-8s-java-time-api","q":"\n\n<p>Joda Time has a nice <a href=\"http://joda-time.sourceforge.net/apidocs/org/joda/time/DateTimeUtils.html#setCurrentMillisFixed%28long%29\">DateTimeUtils.setCurrentMillisFixed()</a> to mock time.  It's very practical in tests.  Is there an equivalent in <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html\">Java 8's java.time API</a>?</p>\n    ","a":"\n<p>The closest thing is the <code>Clock</code> object. You can create a Clock object using any time you want (or from the System current time).  All date.time objects have overloaded <code>now</code> methods that take a clock object instead for the current time.  So you can use dependency injection to inject a Clock with a specific time:</p>\n\n<pre><code>public class MyBean {\n    private Clock clock;  // dependency inject\n    ...\n    public void process(LocalDate eventDate) {\n      if (eventDate.isBefore(LocalDate.now(clock)) {\n        ...\n      }\n    }\n  }\n</code></pre>\n\n<p>See <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/Clock.html\">Clock JavaDoc</a> for more details</p>\n    "},{"t":"How to convert a string to a lambda expression?","l":"http://stackoverflow.com/questions/22207447/how-to-convert-a-string-to-a-lambda-expression","q":"\n\n<p>I was thinking a bit and came up with an interesting problem, suppose we have a configuration (input) file with:</p>\n\n<pre><code>x -&gt; x + 1\nx -&gt; x * 2\nx -&gt; x * x\nx -&gt; -x\n</code></pre>\n\n<p>And furthermore we have a list of <code>Integer</code>s:</p>\n\n<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.addAll(Arrays.toList(1, 2, 3, 4, 5));\n</code></pre>\n\n<p>Is there a way to convert the <code>String</code>s (<code>x -&gt; x + 1</code>, etc.) to <code>Object</code>s that represent a lambda expression? Which could then be used as:</p>\n\n<pre><code>Object lambda = getLambdaFromString(\"x -&gt; x + 1\");\nif (lambda.getClass().equals(IntFunction.class) {\n    list.stream().forEach()\n        .mapToInt(x -&gt; x)\n        .map(x -&gt; ((IntFunction)lambda).applyAsInt(x))\n        .forEach(System.out::println);\n}\n</code></pre>\n\n<p>How would I write such a method <code>getLambdaFromString</code>?</p>\n\n<ul>\n<li>Is there something I could reuse from the JDK/JRE?</li>\n<li>Would I need to write it all by myself?</li>\n<li>Is it possible to narrow down the <code>Object lambda</code> to something else that only captures lambdas?</li>\n</ul>\n    ","a":"\n<p>Marko's comment on the question is correct. You can't read a bare Java lambda expression out of a file, since such an expression isn't defined without a target type provided by the context. For example, consider the following method declarations:</p>\n\n<pre><code>void method1(BiFunction&lt;String,String,String&gt; f) { ... }\nvoid method2(BiFunction&lt;Integer,Integer,Integer&gt; f) { ... }\n</code></pre>\n\n<p>Then in the following code,</p>\n\n<pre><code>method1((x, y) -&gt; x + y);\nmethod2((x, y) -&gt; x + y);\n</code></pre>\n\n<p>the two lambda expressions <code>(x, y) -&gt; x + y</code> mean <strong>completely different</strong> things. For method1, the <code>+</code> operator is string concatenation, but for method2, it means integer addition.</p>\n\n<p>This is wandering a bit far afield from your question, but you can read and evaluate a lambda or function expression using a dynamic language. In Java 8 there is the Nashorn JavaScript engine. So instead of attempting to read an evaluate a Java lambda expression, you could read and evaluate a <strong>JavaScript</strong> function using Nashorn, called from Java.</p>\n\n<p>The following code takes a function in arg[0] and applies it to each subsequent, printing the results:</p>\n\n<pre><code>import java.util.function.Function;\nimport javax.script.*;\n\npublic class ScriptFunction {\n    public static void main(String[] args) throws Exception {\n        ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\");\n        @SuppressWarnings(\"unchecked\")\n        Function&lt;Object,Object&gt; f = (Function&lt;Object,Object&gt;)engine.eval(\n            String.format(\"new java.util.function.Function(%s)\", args[0]));\n        for (int i = 1; i &lt; args.length; i++) {\n            System.out.println(f.apply(args[i]));\n        }\n    }\n}\n</code></pre>\n\n<p>For example, running the command</p>\n\n<pre><code>java ScriptFunction 'function(x) 3 * x + 1' 17 23 47\n</code></pre>\n\n<p>gives the results</p>\n\n<pre><code>52.0\n70.0\n142.0\n</code></pre>\n\n<p>The wrapping of the function string inside of <code>new java.util.function.Function</code> is necessary in order to create an adapter between Nashorn's notion of a JavaScript function and Java's Function interface. (There might be a better way, but I'm not aware of one.) The cast of the return value of <code>eval</code> to <code>Function&lt;Object,Object&gt;</code> results in an unchecked cast warning, which is unavoidable, I think, since this is the boundary between JavaScript, a dynamically-typed language, and Java, which is statically-typed. Finally, no error checking is done. I'm sure this will blow up in a variety of nasty ways if certain assumptions are violated, such as the first argument not actually representing a JavaScript function.</p>\n\n<p>Still, you might find this technique useful if you have a need to evaluate expressions or functions read from a file.</p>\n    "},{"t":"How to rewrite code to optionals?","l":"http://stackoverflow.com/questions/31500254/how-to-rewrite-code-to-optionals","q":"\n\n<p>In my current job we are rewriting some code to Java 8.\nIf you have code like this:</p>\n\n<pre><code>if(getApi() != null &amp;&amp; getApi().getUser() != null \n     &amp;&amp; getApi().getUser().getCurrentTask() != null)  \n{\n   getApi().getUser().getCurrentTask().pause();\n}\n</code></pre>\n\n<p>you can simply rewrite it to</p>\n\n<pre><code>Optional.ofNullable(this.getApi())\n.map(Api::getUser)\n.map(User::getCurrentTask)\n.ifPresent(Task::pause);\n</code></pre>\n\n<p>without changing code behaviour.\n but what if something in the middle can throw NPE because it is not checked to null?</p>\n\n<p>for example:</p>\n\n<pre><code>if(getApi() != null &amp;&amp; getApi().getUser() != null \n     &amp;&amp; getApi().hasTasks())  \n{\n   getApi().getMasterUser(getApi().getUser()) //&lt;- npe can be here\n     .getCurrentTask().pause();\n}\n</code></pre>\n\n<p>what is the best way to rewrite code like this using optionals?(it should work exactly the same and throw npe when <code>getMasterUser(...)</code> returns null) </p>\n\n<p><strong>UPD</strong>\nsecond example:</p>\n\n<pre><code>if(getApi()!=null &amp;&amp; getApi.getUser() != null)\n{\n   if(getApi().getUser().getDepartment().getBoss() != null)// &lt;- nre if department is null\n     {\n        getApi().getUser().getDepartment().getBoss().somefunc();\n     }\n }\n</code></pre>\n\n<p>it has nullchecks for api, user, boss, but not department. how can it be made using optionals?</p>\n    ","a":"\n<pre><code>if(getApi() != null &amp;&amp; getApi().getUser() != null) {\n    if(getApi().getUser().getDepartment().getBoss() != null) {\n        getApi().getUser().getDepartment().getBoss().somefunc();\n    }\n}\n</code></pre>\n\n<p>One way of writing this with optionals is:</p>\n\n<pre><code>Optional.ofNullable(this.getApi())\n    .map(Api::getUser)\n    .map(user -&gt; Objects.requireNonNull(user.getDepartment()))\n    .map(Department::getBoss)\n    .ifPresent(Boss::somefunc);\n</code></pre>\n\n<p>But this is error-prone because it requires the client to keep track of what is and isn't optional. A better way would be to make the api itself return an optional instead of a nullable value. Then the client code is:</p>\n\n<pre><code>this.getApi()\n    .flatMap(Api::getUser)\n    .map(user -&gt; user.getDepartment().getBoss())\n    .ifPresent(Boss::somefunc));\n</code></pre>\n\n<p>This would make it clearer in the api which values should be optional and make it a compile-time error to not handle them.</p>\n\n<pre><code>if(getApi() != null &amp;&amp; getApi().getUser() != null &amp;&amp; getApi().hasTasks()) {\n    getApi().getMasterUser(getApi().getUser()).getCurrentTask().pause();\n}\n</code></pre>\n\n<p>Here, you need access to <code>api</code> and <code>user</code> at the same time so you probably need to nest the lambdas:</p>\n\n<pre><code>getApi().filter(Api::hasTasks).ifPresent(api -&gt; {\n    api.getUser().ifPresent(user -&gt; {\n        api.getMasterUser(user).getCurrentTask().ifPresent(Task::pause);\n    });\n});\n</code></pre>\n    "},{"t":"java8: dealing with default methods","l":"http://stackoverflow.com/questions/24850737/java8-dealing-with-default-methods","q":"\n\n<p>While writing a crypto utility class I ran into a problem with the following method:</p>\n\n<pre><code>public static void destroy(Key key) throws DestroyFailedException {\n    if(Destroyable.class.isInstance(key)) {\n        ((Destroyable)key).destroy();\n    }\n}\n\n@Test\npublic void destroySecretKeySpec() {\n    byte[] rawKey = new byte[32];\n    new SecureRandom().nextBytes(rawKey);\n    try {\n        destroy(new SecretKeySpec(rawKey , \"AES\"));\n    } catch(DestroyFailedException e) {\n        Assert.fail();\n    }\n}\n</code></pre>\n\n<p>In the particular case of <code>javax.crypto.spec.SecretKeySpec</code> the above method would work just fine in <code>java7</code> because <a href=\"http://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/SecretKeySpec.html\">SecretKeySpec (javadocs 7)</a> does not implement <a href=\"http://docs.oracle.com/javase/7/docs/api/javax/security/auth/Destroyable.html\">Destroyable (javadocs 7)</a></p>\n\n<p>Now with <code>java8</code> the class <a href=\"http://docs.oracle.com/javase/8/docs/api/javax/crypto/spec/SecretKeySpec.html\">SecretKeySpec (javadocs 8)</a> has been made <a href=\"http://docs.oracle.com/javase/8/docs/api/javax/security/auth/Destroyable.html\">Destroyable (javadocs 8)</a> and the method <a href=\"http://docs.oracle.com/javase/8/docs/api/javax/security/auth/Destroyable.html#destroy--\">Destroyable#destroy</a> is now <code>default</code> which is fine according this <a href=\"http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html\">statement</a> </p>\n\n<blockquote>\n  <p>Default methods enable you to add new functionality to the interfaces of your libraries and <strong>ensure binary compatibility</strong> with code written for older versions of those interfaces.</p>\n</blockquote>\n\n<p>then the code compiles without any problems despite the fact that the class <code>ScretKeySpec</code> itself has not been changed, alone the interface <a href=\"http://docs.oracle.com/javase/8/docs/api/javax/crypto/SecretKey.html\">SecretKey</a> has been.</p>\n\n<p>The problem is that in <code>oracle's jdk8</code> the <code>destroy</code> method has the following implementation:</p>\n\n<pre><code>public default void destroy() throws DestroyFailedException {\n    throw new DestroyFailedException();\n}\n</code></pre>\n\n<p>which leads to an exception at run time. </p>\n\n<p>So the binary compatibility might not have been broken, but existing code has been. The test above passes with <code>java7</code> but does not with <code>java8</code></p>\n\n<p>So my questions are:</p>\n\n<ul>\n<li><p>How to deal in general with default methods which might lead to exceptions - because not implemented or not supported - or unexpected behavior at run time? aside from doing </p>\n\n<pre><code>Method method = key.getClass().getMethod(\"destroy\");\nif(! method.isDefault()) {\n    ((Destroyable)key).destroy();\n}\n</code></pre>\n\n<p>which is only valid for java8 and which might not be correct in future releases, since the default method might get a meaningful implementation.</p></li>\n<li><p>Would it not be better to leave this default method empty instead of throwing an exception (which IMO is misleading since aside from the legit call to destroy nothing has been attempted to effectively destroy the key, an <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html\">UnsupportedOperationException</a> would have been a better fit and you would know instantly what is going on)</p></li>\n<li><p>Is my approach with (type check/cast/call)</p>\n\n<pre><code>if(Destroyable.class.isInstance(key))\n    ((Destroyable)key).destroy();\n</code></pre>\n\n<p>for determining whether to destroy or not wrong? What would be an alternative?</p></li>\n<li><p>Is this a misconception or did they just forget to add meaningful implementation in <code>ScretKeySpec</code>?</p></li>\n</ul>\n    ","a":"\n<blockquote>\n  <p>Is this a misconception or did they just forget to add meaningful implementation in SecretKeySpec?</p>\n</blockquote>\n\n<p>Well they didn't forget. <code>SecretKeySpec</code> does need an implementation, but it simply hasn't been done yet. See bug <a href=\"https://bugs.openjdk.java.net/browse/JDK-8008795\" rel=\"nofollow\">JDK-8008795</a>. Sorry, no ETA on when this will be fixed.</p>\n\n<p>Ideally, valid implementations of <code>destroy</code> would have been added at the time the default method was added and the interface was retrofitted onto existing classes, but it didn't happen, probably because of scheduling.</p>\n\n<p>The notion of \"binary compatibility\" in the tutorial you cited is a rather strict definition, which is the one used by the <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html\" rel=\"nofollow\">Java Language Specification, chapter 13</a>. Basically it's about valid transformations to library classes that do not cause class loading or linking errors at runtime, when combined with classes compiled against older versions of those library classes. This is in contrast to source incompatibility, which causes compile-time errors, and behavioral incompatibility, which causes usually unwanted changes in the runtime behavior of the system. Such as throwing exceptions that weren't thrown before.</p>\n\n<p>This is not to minimize the fact that your code got broken. It's still an incompatibility. (Sorry.)</p>\n\n<p>As a workaround, you might add <code>instanceof PrivateKey || instanceof SecretKey</code> (since these are apparently the classes that lack <code>destroy</code> implementations) and have the test assert that they do throw <code>DestroyFailedException</code>, else if <code>instanceof Destroyable</code> execute the remainder of the logic in your test. The test will fail again when these instances get reasonable <code>destroy</code> implementations in some future version of Java; this will be a signal to change the test back to calling <code>destroy</code> on all Destroyables. (An alternative might be to ignore these classes entirely, but then valid code paths might end up remaining uncovered for quite some time.)</p>\n    "},{"t":"Java 8 Consumer/Function Lambda Ambiguity","l":"http://stackoverflow.com/questions/30584887/java-8-consumer-function-lambda-ambiguity","q":"\n\n<p>I have an overloaded method that takes a Consumer and a Function object respectively and returns a generic type that matches the corresponding Consumer/Function. I thought this would be fine, but when I try to call either method with a lambda expression I get an error indicating the reference to the method is ambiguous.</p>\n\n<p>Based on my reading of <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.1\">JLS §15.12.2.1. Identify Potentially Applicable Methods:</a> it seems like the compiler should know that my lambda with a void block matches the Consumer method and my lambda with a return type matches the Function method.</p>\n\n<p>I put together the following sample code that fails to compile:</p>\n\n<pre><code>import java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class AmbiguityBug {\n  public static void main(String[] args) {\n    doStuff(getPattern(x -&gt; System.out.println(x)));\n    doStuff(getPattern(x -&gt; String.valueOf(x)));\n  }\n\n  static Pattern&lt;String, String&gt; getPattern(Function&lt;String, String&gt; function) {\n    return new Pattern&lt;&gt;(function);\n  }\n\n  static ConsumablePattern&lt;String&gt; getPattern(Consumer&lt;String&gt; consumer) {\n    return new ConsumablePattern&lt;&gt;(consumer);\n  }\n\n  static void doStuff(Pattern&lt;String, String&gt; pattern) {\n    String result = pattern.apply(\"Hello World\");\n    System.out.println(result);\n  }\n\n  static void doStuff(ConsumablePattern&lt;String&gt; consumablePattern) {\n    consumablePattern.consume(\"Hello World\");\n  }\n\n  public static class Pattern&lt;T, R&gt; {\n    private final Function&lt;T, R&gt; function;\n\n    public Pattern(Function&lt;T, R&gt; function) {\n      this.function = function;\n    }\n\n    public R apply(T value) {\n      return function.apply(value);\n    }\n  }\n\n  public static class ConsumablePattern&lt;T&gt; {\n    private final Consumer&lt;T&gt; consumer;\n\n    public ConsumablePattern(Consumer&lt;T&gt; consumer) {\n      this.consumer = consumer;\n    }\n\n    public void consume(T value) {\n      consumer.accept(value);\n    }\n  }\n}\n</code></pre>\n\n<p>I also found a <a href=\"http://stackoverflow.com/questions/23430854/lambda-expression-and-method-overloading-doubts\">similar</a> stackoverflow post that turned out to be a compiler bug. My case is very similar, though a bit more complicated. To me this still looks like a bug, but I wanted to make sure I am not misunderstanding the language spec for lambdas. I'm using Java 8u45 which should have all of the latest fixes.</p>\n\n<p>If I change my method calls to be wrapped in a block everything seems to compile, but this adds additional verbosity and many auto-formatters will reformat it into multiple lines.</p>\n\n<pre><code>doStuff(getPattern(x -&gt; { System.out.println(x); }));\ndoStuff(getPattern(x -&gt; { return String.valueOf(x); }));\n</code></pre>\n    ","a":"\n<p>This line is definitely ambiguous:</p>\n\n<pre><code>doStuff(getPattern(x -&gt; String.valueOf(x)));\n</code></pre>\n\n<p>Reread this from the linked JLS chapter:</p>\n\n<blockquote>\n  <p>A lambda expression (§15.27) is potentially compatible with a functional interface type (§9.8) if all of the following are true:</p>\n  \n  <ul>\n  <li><p>The arity of the target type's function type is the same as the arity of the lambda expression.</p></li>\n  <li><p>If the target type's function type has a void return, then the lambda body is either a statement expression (§14.8) or a void-compatible block (§15.27.2).</p></li>\n  <li>If the target type's function type has a (non-void) return type, then the lambda body is either an expression or a value-compatible block (§15.27.2).</li>\n  </ul>\n</blockquote>\n\n<p>In your case for <code>Consumer</code> you have a <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.8\">statement expression</a> as any method invocation can be used as statement expression even if the method is non-void. For example, you can simply write this:</p>\n\n<pre><code>public void test(Object x) {\n    String.valueOf(x);\n}\n</code></pre>\n\n<p>It makes no sense, but compiles perfectly. Your method may have a side-effect, compiler doesn't know about it. For example, were it <code>List.add</code> which always returns <code>true</code> and nobody cares about its return value.</p>\n\n<p>Of course this lambda also qualifies for <code>Function</code> as it's an expression. Thus it's ambigue. If you have something which is an expression, but not a <em>statement expression</em>, then the call will be mapped to <code>Function</code> without any problem:</p>\n\n<pre><code>doStuff(getPattern(x -&gt; x == null ? \"\" : String.valueOf(x)));\n</code></pre>\n\n<p>When you change it to <code>{ return String.valueOf(x); }</code>, you create a <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.2\">value-compatible block</a>, so it matches the <code>Function</code>, but it does not qualify as a <em>void-compatible block</em>. However you may have problems with blocks as well:</p>\n\n<pre><code>doStuff(getPattern(x -&gt; {throw new UnsupportedOperationException();}));\n</code></pre>\n\n<p>This block qualifies both as a value-compatible and a void-compatible, thus you have an ambiguity again. Another ambigue block example is an endless loop:</p>\n\n<pre><code>doStuff(getPattern(x -&gt; {while(true) System.out.println(x);}));\n</code></pre>\n\n<p>As for <code>System.out.println(x)</code> case it's a little bit tricky. It surely qualifies as <em>statement expression</em>, so can be matched to <code>Consumer</code>, but seems that it matches to expression as well as spec says that <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12\">method invocation</a> is an expression. However it's an expression of limited use <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.3\">like 15.12.3</a> says:</p>\n\n<blockquote>\n  <p>If the compile-time declaration is void, then the method invocation must be a top level expression (that is, the Expression in an expression statement or in the ForInit or ForUpdate part of a for statement), or a compile-time error occurs. Such a method invocation produces no value and so must be used only in a situation where a value is not needed. </p>\n</blockquote>\n\n<p>So compiler perfectly follows the specification. First it determines that your lambda body is qualified both as an expression (even though its return type is void: 15.12.2.1 makes no exception for this case) and a statement expression, so it's considered an ambiguity as well.</p>\n\n<p>Thus for me both statements compile according to the specification. ECJ compiler produces the same error messages on this code.</p>\n\n<p>In general I'd suggest you to avoid overloading your methods when your overloads has the same number of parameters and has the difference only in accepted functional interface. Even if these functional interfaces have different arity (for example, <code>Consumer</code> and <code>BiConsumer</code>): you will have no problems with lambda, but may have problems with method references. Just select different names for your methods in this case (for example, <code>processStuff</code> and <code>consumeStuff</code>).</p>\n    "},{"t":"Functional Interface Inheritance Quirk","l":"http://stackoverflow.com/questions/30634543/functional-interface-inheritance-quirk","q":"\n\n<p>I have a custom interface I've been using for some time that looks something like this:</p>\n\n<pre><code>public interface Function&lt;T, R&gt; {\n    R call(T input);\n}\n</code></pre>\n\n<p>I'd like to retrofit this interface with both Java's <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html\"><code>Function</code></a> as well as Guava's <a href=\"http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Function.html\"><code>Function</code></a>, while keeping it a <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html\"><code>FunctionalInterface</code></a>. I thought I had the perfect arrangement:</p>\n\n<pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt; extends\n        java.util.function.Function&lt;T, R&gt;,\n        com.google.common.base.Function&lt;T, R&gt; {\n\n    R call(T input);\n\n    @Override\n    default R apply(T input) {\n        return call(input);\n    }\n}\n</code></pre>\n\n<p>Both superinterfaces declare the same <code>apply()</code> method, which has been implemented in my interface, leaving only the abstract <code>call()</code> method. Strangely, it won't compile, telling me</p>\n\n<blockquote>\n  <p>Invalid '@FunctionalInterface' annotation; Function&lt;T,R&gt; is not a functional interface</p>\n</blockquote>\n\n<p>Stranger still, the following variations compile just fine:</p>\n\n<pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt; extends\n        java.util.function.Function&lt;T, R&gt; {\n\n    R call(T input);\n\n    @Override\n    default R apply(T input) {\n        return call(input);\n    }\n}\n</code></pre>\n\n<p></p>\n\n<pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt; extends\n        com.google.common.base.Function&lt;T, R&gt; {\n\n    R call(T input);\n\n    @Override\n    default R apply(T input) {\n        return call(input);\n    }\n}\n</code></pre>\n\n<p></p>\n\n<pre><code>public interface Function&lt;T, R&gt; extends\n        java.util.function.Function&lt;T, R&gt;,\n        com.google.common.base.Function&lt;T, R&gt; {\n\n    R call(T input);\n\n    @Override\n    default R apply(T input) {\n        return call(input);\n    }\n}\n</code></pre>\n\n<p></p>\n\n<pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt; extends\n        java.util.function.Function&lt;T, R&gt;,\n        com.google.common.base.Function&lt;T, R&gt; {\n\n    @Override\n    R apply(T input);\n}\n</code></pre>\n\n<p>Is there a reason the first version won't compile?</p>\n    ","a":"\n<p>As stated in the comments, it compiles fine with the oracle compiler. \nIt is an eclipse bug.</p>\n\n<p>Awaiting for a bug fix, personally i will remove the annotation <code>@FunctionalInterface</code> (your 3rd variation):</p>\n\n<pre><code>public interface Function&lt;T, R&gt;\n                                extends\n                                    java.util.function.Function&lt;T, R&gt;,\n                                    com.google.common.base.Function&lt;T, R&gt; {\n\n    R call(T input);\n\n    @Override\n    default R apply(T input) {\n        return call(input);\n    }\n}\n</code></pre>\n\n<p>The major inconvenient of this solution is that the eclipse compiler bug prevent  from using the <code>Function</code> as a <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing\" rel=\"nofollow\">lambda target type</a>.</p>\n\n<hr>\n\n<p>If you really want to keep <code>@FunctionalInterface</code> on your <code>Function</code>, a (ugly) workaround might be to introduce an intermediate interface:</p>\n\n<pre><code>public interface AdapterFunction&lt;T, R&gt;\n                                      extends\n                                          java.util.function.Function&lt;T, R&gt;,\n                                          com.google.common.base.Function&lt;T, R&gt; {\n    @Override\n    default R apply(T input) {\n        return null;\n    }\n}\n</code></pre>\n\n<p>and let your <code>Function</code> extends this <code>AdapterFunction</code>:</p>\n\n<pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt;\n                                extends\n                                    AdapterFunction&lt;T, R&gt; {\n\n    R call(T input);\n\n    @Override\n    default R apply(T input) {\n        return call(input);\n    }\n}\n</code></pre>\n\n<p>In this case, the <code>Function</code> is a valid target type for eclipse too:</p>\n\n<pre><code>Function&lt;String, Object&gt; function = st -&gt; st.toString();\n</code></pre>\n    "},{"t":"Should the following code compile under Java 1.8","l":"http://stackoverflow.com/questions/29700417/should-the-following-code-compile-under-java-1-8","q":"\n\n<p>given the following class:</p>\n\n<pre><code>public class FooTest {\n\n    public static class Base {\n    }\n\n    public static class Derived extends Base {\n    }\n\n    public interface Service&lt;T extends Base&gt; {\n        void service(T value);\n    }\n\n    public abstract class AbstractService&lt;T extends Derived&gt; implements  Service&lt;T&gt; {\n        public void service(T value) {\n        }\n    }\n\n    private AbstractService service;\n\n    public void bar(Base base) {\n        if(base instanceof Derived) {\n            service.service(base); // compile error at this line\n        }\n    }\n}\n</code></pre>\n\n<p>When building the class with the following <code>pom.xml</code>:</p>\n\n<pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;com.mgm-tp&lt;/groupId&gt;\n    &lt;artifactId&gt;java-compiler-test&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;build&gt;\n        &lt;pluginManagement&gt;\n            &lt;plugins&gt;\n                &lt;plugin&gt;\n                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                    &lt;version&gt;3.3&lt;/version&gt;\n                    &lt;configuration&gt;\n                        &lt;source&gt;1.8&lt;/source&gt;\n                        &lt;target&gt;1.8&lt;/target&gt;\n                        &lt;compilerId&gt;eclipse&lt;/compilerId&gt;\n                    &lt;/configuration&gt;\n                    &lt;dependencies&gt;\n                        &lt;dependency&gt;\n                            &lt;groupId&gt;org.codehaus.plexus&lt;/groupId&gt;\n                            &lt;artifactId&gt;plexus-compiler-eclipse&lt;/artifactId&gt;\n                            &lt;version&gt;2.5&lt;/version&gt;\n                        &lt;/dependency&gt;\n                    &lt;/dependencies&gt;\n                &lt;/plugin&gt;\n            &lt;/plugins&gt;\n        &lt;/pluginManagement&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>\n\n<p>in maven 3.4 it produces the following compile error:</p>\n\n<blockquote>\n  <p>[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.3:compile (default-compile) on project java-compiler-test: Compilation failure\n  [ERROR] C:\\Users\\abrieg\\workingcopy\\java-compiler-test\\src\\main\\java\\FooTest.java:[25] The method service(FooTest.Base) in the type FooTest.Service is not applicable for the arguments (FooTest.Base)</p>\n</blockquote>\n\n<p>When setting source and target level to 1.7 for the eclipse compiler or when using <code>javac</code> as the compiler there is no compile error reported.</p>\n\n<p>The question is wheter JLS 1.8 is more specific about type inference such that this code is really not allowed as supposed by eclipse compiler for java 1.8 or if this is a regression in the eclipse compiler.</p>\n\n<p>Based on the text of the compiler error I tend to say its a regression, but I am not sure.</p>\n\n<p>I have identified the following two bugs already reported to jdt, but I think they do not apply exactly:<br>\n<a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=432603\">https://bugs.eclipse.org/bugs/show_bug.cgi?id=432603</a>\n<a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=430987\">https://bugs.eclipse.org/bugs/show_bug.cgi?id=430987</a></p>\n\n<p>If this is a regression, has this already been reported to jdt?</p>\n    ","a":"\n<p>To my understanding, this code should compile, but of course not without an unchecked warning.</p>\n\n<p>You have declared a variable <code>service</code> of the <em>raw type</em> <code>AbstractService</code> which is a subtype of the <em>raw type</em> <code>Service</code> which has a method <code>void service(Base)</code> which is the erasure of <code>void&nbsp;service(T)</code>.</p>\n\n<p>So the invocation <code>service.service(base)</code> may invoke that method <code>void service(Base)</code> declared in <code>Service</code>, of course, with an <em>unchecked</em> warning as the method is generic and no verification of the type parameter <code>T</code> happened.</p>\n\n<p>This might be counter-intuitive as the type <code>AbstractService</code> overrides that method with a method whose erasure is <code>void service(Derived)</code> but this method can only override the other method in a <em>generic</em> context, not in a <em>raw type</em> inheritance relationship.</p>\n\n<p>Or, in other words, a type can’t override a method in a way that it is more restrictive regarding parameter types than the overridden supertype method.</p>\n\n<p>This also applies to the generic type inheritance but to a different outcome. If your variable had the type <code>AbstractService&lt;X&gt;</code>, then <code>X</code> must be assignable to <code>Derived</code> due to the constraint of the type parameter. This type <code>AbstractService&lt;X&gt;</code> is a subtype of <code>Service&lt;X&gt;</code> which has a method <code>void&nbsp;service(X)</code> (as <code>T</code> := <code>X</code>) which is overridden (implemented) by <code>AbstractService&lt;X&gt;</code> with a method <code>void&nbsp;service(X)</code> which accepts the same argument types.</p>\n\n<hr>\n\n<p>Since there seems to be some confusion on your site, I want to emphasize that this has nothing to do with your <code>if(… instanceof Derived)</code> statement. As explained above, this behavior is due to the <em>raw type</em> usage, which means you are using <code>AbstractService</code> without an actual type argument and basically switching off the Generics type checking. This would even work if you had written</p>\n\n<pre><code>public void bar(Base base) {\n    service.service(base); // UNCHECKED invocation\n}\n</code></pre>\n\n<p>If you changed the declaration of the variable to</p>\n\n<pre><code>private AbstractService&lt;Derived&gt; service;\n</code></pre>\n\n<p>it won’t be a <em>raw type</em> anymore and the type checking will happen and <code>service.service(base)</code> will generate a compiler error, regardless of whether you enclose it with <code>if(base instanceof Derived) { … }</code> or not.</p>\n\n<p><em>Raw types</em> exist for compatibility with pre-Generics code only and you should avoid using them and not ignore warnings provoked by <em>raw type</em> usage.</p>\n    "},{"t":"Filter Java Stream to 1 and only 1 element","l":"http://stackoverflow.com/questions/22694884/filter-java-stream-to-1-and-only-1-element","q":"\n\n<p>I am trying to use Java 8 <code>Stream</code>s to find elements in a <code>LinkedList</code>. I want to guarantee, however, that there is 1 and only 1 match to the filter criteria.</p>\n\n<p>Take this code:</p>\n\n<pre><code>public static void main(String[] args) {\n\n    LinkedList&lt;User&gt; users = new LinkedList&lt;&gt;();\n    users.add(new User(1, \"User1\"));\n    users.add(new User(2, \"User2\"));\n    users.add(new User(3, \"User3\"));\n\n    User match = users.stream().filter((user) -&gt; user.getId() == 1).findAny().get();\n    System.out.println(match.toString());\n}\n\nstatic class User {\n\n    @Override\n    public String toString() {\n        return id + \" - \" + username;\n    }\n\n    int id;\n    String username;\n\n    public User() {\n    }\n\n    public User(int id, String username) {\n        this.id = id;\n        this.username = username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public int getId() {\n        return id;\n    }\n}\n</code></pre>\n\n<p>This code finds a <code>User</code> based on their ID. But there are no guarantees how many <code>User</code>s matched the filter.</p>\n\n<p>Changing the filter line to:</p>\n\n<pre><code>User match = users.stream().filter((user) -&gt; user.getId() &lt; 0).findAny().get();\n</code></pre>\n\n<p>Will throw a <code>NoSuchElementException</code> (good!)</p>\n\n<p>I would like it to throw an error if there are multiple matches, though. Is there a way to do this?</p>\n    ","a":"\n<p>Technically there's an ugly 'workaround' that involves <code>peek()</code> and an <code>AtomicInteger</code>, but really you shouldn't be using that.</p>\n\n<p>What I do in these cases is just collecting it in a list, like this:</p>\n\n<pre><code>LinkedList&lt;User&gt; users = new LinkedList&lt;&gt;();\nusers.add(new User(1, \"User1\"));\nusers.add(new User(2, \"User2\"));\nusers.add(new User(3, \"User3\"));\nList&lt;User&gt; resultUserList = users.stream()\n        .filter(user -&gt; user.getId() == 1)\n        .collect(Collectors.toList());\nif (resultUserList.size() != 1) {\n    throw new IllegalStateException();\n}\nUser resultUser = resultUserList.get(0);\n</code></pre>\n\n<p>I am not aware of a way to do this in the API, meanwhile I will work on another example involving a custom element.</p>\n\n<p><strong>Update</strong>, You should create your own <code>Collector</code> for this:</p>\n\n<pre><code>public static &lt;T&gt; Collector&lt;T, List&lt;T&gt;, T&gt; singletonCollector() {\n    return Collector.of(\n            ArrayList::new,\n            List::add,\n            (left, right) -&gt; { left.addAll(right); return left; },\n            list -&gt; {\n                if (list.size() != 1) {\n                    throw new IllegalStateException();\n                }\n                return list.get(0);\n            }\n    );\n}\n</code></pre>\n\n<p>What it does is:</p>\n\n<ul>\n<li>It mimicks the <code>Collectors.toList()</code> collector.</li>\n<li>It applies an extra finisher at the end, that throws an exception, or if no exception, returns the first element of the list.</li>\n</ul>\n\n<p>Used as:</p>\n\n<pre><code>User resultUser = users.stream()\n        .filter(user -&gt; user.getId() &gt; 0)\n        .collect(singletonCollector());\n</code></pre>\n\n<p>You can then customize this <code>singletonCollector</code> as much as you want, for example give the exception as argument in the constructor, tweak it to allow two values, and more.</p>\n\n<p><strong>New update</strong>, I revised my old answer once more for <code>singletonCollector()</code>, it can actually be obtained like this:</p>\n\n<pre><code>public static &lt;T&gt; Collector&lt;T, ?, T&gt; singletonCollector() {\n    return Collectors.collectingAndThen(\n            Collectors.toList(),\n            list -&gt; {\n                if (list.size() != 1) {\n                    throw new IllegalStateException();\n                }\n                return list.get(0);\n            }\n    );\n}\n</code></pre>\n    "},{"t":"Java 8's streams: why parallel stream is slower?","l":"http://stackoverflow.com/questions/23170832/java-8s-streams-why-parallel-stream-is-slower","q":"\n\n<p>I am playing with Java 8's streams and cannot understand the performance results I am getting.</p>\n\n<p>I have 2 core CPU (Intel i73520M), Windows 8 x64, and 64-bit Java 8 update 5. I am doing simple map over stream/parallel stream of Strings and found that parallel version is somewhat slower.</p>\n\n<p>When I run this code:</p>\n\n<pre><code>String[] array = new String[1000000];\nArrays.fill(array, \"AbabagalamagA\");\n\nStream&lt;String&gt; stream = Arrays.stream(array);\n\nlong time1 = System.nanoTime();\n\nList&lt;String&gt; list = stream.map((x) -&gt; x.toLowerCase()).collect(Collectors.toList());\n\nlong time2 = System.nanoTime();\n\nSystem.out.println((time2 - time1) / 1000000f);\n</code></pre>\n\n<p>... I am getting result of somewhere around 600. This version, that uses parallel stream:</p>\n\n<pre><code>String[] array = new String[1000000];\nArrays.fill(array, \"AbabagalamagA\");\n\nStream&lt;String&gt; stream = Arrays.stream(array).parallel();\n\nlong time1 = System.nanoTime();\n\nList&lt;String&gt; list = stream.map((x) -&gt; x.toLowerCase()).collect(Collectors.toList());\n\nlong time2 = System.nanoTime();\n\n\nSystem.out.println((time2 - time1) / 1000000f);\n</code></pre>\n\n<p>... gives me something about 900.</p>\n\n<p>Shouldn't the parallel version be faster, considering the fact that I have 2 CPU cores?\nCould someone give me a hint why parallel version is slower?</p>\n    ","a":"\n<p>There are several issues going on here in parallel, as it were.</p>\n\n<p>The first is that solving a problem in parallel always involves performing more actual work than doing it sequentially. Overhead is involved in splitting the work among several threads and joining or merging the results. Problems like converting short strings to lower-case are small enough that they are in danger of being swamped by the parallel splitting overhead.</p>\n\n<p>The second issue is that benchmarking Java program is very subtle, and it is very easy to get confusing results. Two common issues are JIT compilation and dead code elimination. Short benchmarks often finish before or during JIT compilation, so they're not measuring peak throughput, and indeed they might be measuring the JIT itself. When compilation occurs is somewhat non-deterministic, so it may cause results to vary wildly as well.</p>\n\n<p>For small, synthetic benchmarks, the workload often computes results that are thrown away. JIT compilers are quite good at detecting this and eliminating code that doesn't produce results that are used anywhere. This probably isn't happening in this case, but if you tinker around with other synthetic workloads, it can certainly happen. Of course, if the JIT eliminates the benchmark workload, it renders the benchmark useless.</p>\n\n<p>I strongly recommend using a well-developed benchmarking framework such as <a href=\"http://openjdk.java.net/projects/code-tools/jmh/\" rel=\"nofollow\">JMH</a> instead of hand-rolling one of your own. JMH has facilities to help avoid common benchmarking pitfalls, including these, and it's pretty easy to set up and run. Here's your benchmark converted to use JMH:</p>\n\n<pre><code>package com.stackoverflow.questions;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.openjdk.jmh.annotations.*;\n\npublic class SO23170832 {\n    @State(Scope.Benchmark)\n    public static class BenchmarkState {\n        static String[] array;\n        static {\n            array = new String[1000000];\n            Arrays.fill(array, \"AbabagalamagA\");\n        }\n    }\n\n    @GenerateMicroBenchmark\n    @OutputTimeUnit(TimeUnit.SECONDS)\n    public List&lt;String&gt; sequential(BenchmarkState state) {\n        return\n            Arrays.stream(state.array)\n                  .map(x -&gt; x.toLowerCase())\n                  .collect(Collectors.toList());\n    }\n\n    @GenerateMicroBenchmark\n    @OutputTimeUnit(TimeUnit.SECONDS)\n    public List&lt;String&gt; parallel(BenchmarkState state) {\n        return\n            Arrays.stream(state.array)\n                  .parallel()\n                  .map(x -&gt; x.toLowerCase())\n                  .collect(Collectors.toList());\n    }\n}\n</code></pre>\n\n<p>I ran this using the command:</p>\n\n<pre><code>java -jar dist/microbenchmarks.jar \".*SO23170832.*\" -wi 5 -i 5 -f 1\n</code></pre>\n\n<p>(The options indicate five warmup iterations, five benchmark iterations, and one forked JVM.) During its run, JMH emits lots of verbose messages, which I've elided. The summary results are as follows.</p>\n\n<pre><code>Benchmark                       Mode   Samples         Mean   Mean error    Units\nc.s.q.SO23170832.parallel      thrpt         5        4.600        5.995    ops/s\nc.s.q.SO23170832.sequential    thrpt         5        1.500        1.727    ops/s\n</code></pre>\n\n<p>Note that results are in ops per second, so it looks like the parallel run was about three times faster than the sequential run. But my machine has only two cores. Hmmm. And the mean error per run is actually larger than the mean runtime! WAT? Something fishy is going on here.</p>\n\n<p>This brings us to a third issue. Looking more closely at the workload, we can see that it allocates a new String object for each input, and it also collects the results into a list, which involves lots of reallocation and copying. I'd guess that this will result in a fair amount of garbage collection. We can see this by rerunning the benchmark with GC messages enabled:</p>\n\n<pre><code>java -verbose:gc -jar dist/microbenchmarks.jar \".*SO23170832.*\" -wi 5 -i 5 -f 1\n</code></pre>\n\n<p>This gives results like:</p>\n\n<pre><code>[GC (Allocation Failure)  512K-&gt;432K(130560K), 0.0024130 secs]\n[GC (Allocation Failure)  944K-&gt;520K(131072K), 0.0015740 secs]\n[GC (Allocation Failure)  1544K-&gt;777K(131072K), 0.0032490 secs]\n[GC (Allocation Failure)  1801K-&gt;1027K(132096K), 0.0023940 secs]\n# Run progress: 0.00% complete, ETA 00:00:20\n# VM invoker: /Users/src/jdk/jdk8-b132.jdk/Contents/Home/jre/bin/java\n# VM options: -verbose:gc\n# Fork: 1 of 1\n[GC (Allocation Failure)  512K-&gt;424K(130560K), 0.0015460 secs]\n[GC (Allocation Failure)  933K-&gt;552K(131072K), 0.0014050 secs]\n[GC (Allocation Failure)  1576K-&gt;850K(131072K), 0.0023050 secs]\n[GC (Allocation Failure)  3075K-&gt;1561K(132096K), 0.0045140 secs]\n[GC (Allocation Failure)  1874K-&gt;1059K(132096K), 0.0062330 secs]\n# Warmup: 5 iterations, 1 s each\n# Measurement: 5 iterations, 1 s each\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: com.stackoverflow.questions.SO23170832.parallel\n# Warmup Iteration   1: [GC (Allocation Failure)  7014K-&gt;5445K(132096K), 0.0184680 secs]\n[GC (Allocation Failure)  7493K-&gt;6346K(135168K), 0.0068380 secs]\n[GC (Allocation Failure)  10442K-&gt;8663K(135168K), 0.0155600 secs]\n[GC (Allocation Failure)  12759K-&gt;11051K(139776K), 0.0148190 secs]\n[GC (Allocation Failure)  18219K-&gt;15067K(140800K), 0.0241780 secs]\n[GC (Allocation Failure)  22167K-&gt;19214K(145920K), 0.0208510 secs]\n[GC (Allocation Failure)  29454K-&gt;25065K(147456K), 0.0333080 secs]\n[GC (Allocation Failure)  35305K-&gt;30729K(153600K), 0.0376610 secs]\n[GC (Allocation Failure)  46089K-&gt;39406K(154624K), 0.0406060 secs]\n[GC (Allocation Failure)  54766K-&gt;48299K(164352K), 0.0550140 secs]\n[GC (Allocation Failure)  71851K-&gt;62725K(165376K), 0.0612780 secs]\n[GC (Allocation Failure)  86277K-&gt;74864K(184320K), 0.0649210 secs]\n[GC (Allocation Failure)  111216K-&gt;94203K(185856K), 0.0875710 secs]\n[GC (Allocation Failure)  130555K-&gt;114932K(199680K), 0.1030540 secs]\n[GC (Allocation Failure)  162548K-&gt;141952K(203264K), 0.1315720 secs]\n[Full GC (Ergonomics)  141952K-&gt;59696K(159232K), 0.5150890 secs]\n[GC (Allocation Failure)  105613K-&gt;85547K(184832K), 0.0738530 secs]\n1.183 ops/s\n</code></pre>\n\n<p>Note: the lines beginning with <code>#</code> are normal JMH output lines. All the rest are GC messages. This is just the first of the five warmup iterations, which precedes five benchmark iterations. The GC messages continued in the same vein during the rest of the iterations. I think it's safe to say that the measured performance is dominated by GC overhead and that the results reported should not be believed.</p>\n\n<p>At this point it's unclear what to do. This is purely a synthetic workload. It clearly involves very little CPU time doing actual work compared to allocation and copying. It's hard to say what you really are trying to measure here. One approach would be to come up with a different workload that is in some sense more \"real.\" Another approach would be to change the heap and GC parameters to avoid GC during the benchmark run.</p>\n    "},{"t":"Group by counting in Java8 stream API","l":"http://stackoverflow.com/questions/25441088/group-by-counting-in-java8-stream-api","q":"\n\n<p>I try to find a simple way in Java8 stream API to do the grouping, I come out with this complex way!</p>\n\n<pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\nlist.add(\"Hello\");\nlist.add(\"Hello\");\nlist.add(\"World\");\n\nMap&lt;String, List&lt;String&gt;&gt; collect = list.stream().collect(\n        Collectors.groupingBy(o -&gt; o));\nSystem.out.println(collect);\n\nList&lt;String[]&gt; collect2 = collect\n        .entrySet()\n        .stream()\n        .map(e -&gt; new String[] { e.getKey(),\n                String.valueOf(e.getValue().size()) })\n        .collect(Collectors.toList());\n\ncollect2.forEach(o -&gt; System.out.println(o[0] + \" &gt;&gt; \" + o[1]));\n</code></pre>\n\n<p>I appreciate your input.</p>\n    ","a":"\n<p>I think you're just looking for the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-\">overload</a> which takes another <code>Collector</code> to specify what to do with each group... and then <code>Collectors.counting()</code> to do the counting:</p>\n\n<pre><code>import java.util.*;\nimport java.util.stream.*;\n\nclass Test {\n    public static void main(String[] args) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(\"Hello\");\n        list.add(\"Hello\");\n        list.add(\"World\");\n\n        Map&lt;String, Long&gt; counted = list.stream()\n            .collect(Collectors.groupingBy(o -&gt; o, Collectors.counting()));\n\n        System.out.println(counted);\n    }\n}\n</code></pre>\n\n<p>Result:</p>\n\n<pre><code>{Hello=2, World=1}\n</code></pre>\n\n<p>(There's also the possibility of using <code>groupingByConcurrent</code> for more efficiency. Something to bear in mind for your real code, if it would be safe in your context.)</p>\n    "},{"t":"Nashorn bug when calling overloaded method with varargs parameter","l":"http://stackoverflow.com/questions/25603191/nashorn-bug-when-calling-overloaded-method-with-varargs-parameter","q":"\n\n<p>Assume the following API:</p>\n\n<pre><code>package nashorn.test;\n\npublic class API {\n\n    public static void test(String string) {\n        throw new RuntimeException(\"Don't call this\");\n    }\n\n    public static void test(Integer... args) {\n        System.out.println(\"OK\");\n    }\n}\n</code></pre>\n\n<p>The following Nashorn JavaScript snippet will fail:</p>\n\n<pre><code>var API = Java.type(\"nashorn.test.API\");\nAPI.test(1);\n</code></pre>\n\n<p>The first method will be called instead of the second. Is this a bug in the Nashorn engine?</p>\n\n<p><a href=\"https://groups.google.com/forum/#!topic/jooq-user/H0_AxwTHop8\">For the record, this issue was previously reported on the jOOQ User Group</a>, where method overloading and varargs are used heavily, and where this issue may cause a lot of trouble.</p>\n\n<h3>About boxing</h3>\n\n<p>There might be a suspicion that this could have to do with boxing. It doesn't. The problem also appears when I do</p>\n\n<pre><code>public class API {\n\n    public static void test(String string) {\n        throw new RuntimeException(\"Don't call this\");\n    }\n\n    public static void test(Integer... args) {\n        System.out.println(\"OK\");\n    }\n\n    public static void test(MyType... args) {\n        System.out.println(\"OK\");\n    }\n}\n</code></pre>\n\n<p>And:</p>\n\n<pre><code>public class MyType {\n}\n</code></pre>\n\n<p>And then:</p>\n\n<pre><code>var API = Java.type(\"nashorn.test.API\");\nvar MyType = Java.type(\"nashorn.test.MyType\");\n\nAPI.test(new MyType());\n</code></pre>\n    ","a":"\n<p>As the guy who wrote the overload resolution mechanism for Nashorn, I'm always fascinated with corner cases that people run into. For better or worse, here's how this ends up being invoked:</p>\n\n<p>Nashorn's overload method resolution mimics Java Language Specification (JLS) as much as possible, but allows for JavaScript-specific conversions too. JLS says that when selecting a method to invoke for an overloaded name, variable arity methods can be considered for invocation <em>only</em> when there is no applicable fixed arity method. Normally, when invoking from Java <code>test(String)</code> would not be an applicable to an invocation with an <code>int</code>, so the <code>test(Integer...)</code> method would get invoked. However, since JavaScript actually allows number-to-string implicit conversion, it is applicable, and considered before any variable arity methods. Hence the observed behavior. Arity trumps non-conversion. If you added a <code>test(int)</code> method, it'd be invoked before the String method, as it's fixed arity and more specific than the String one.</p>\n\n<p>You could argue that we should alter the algorithm for choosing the method. A lot of thought has been given to this since even before the Nashorn project (even back when I was developing Dynalink independently). Current code (as embodied in the Dynalink library, which Nashorn actually builds upon) follows JLS to the letter and in absence of language-specific type conversions will choose the same methods as Java would. However, as soon as you start relaxing your type system, things start to subtly change, and the more you relax it, the more they'll change (and JavaScript relaxes <em>a lot</em>), and any change to the choice algorithm will have some other weird behavior that someone else will run into… it just comes with the relaxed type system, I'm afraid. For example:</p>\n\n<ul>\n<li>If we allowed varargs to be considered together with fixargs, we'd need to invent a \"more specific than\" relation among differing arity methods, something that doesn't exist in JLS and thus isn't compatible with it, and would cause varargs to sometimes be invoked when otherwise JLS would prescribe fixargs invocation.</li>\n<li>If we disallowed JS-allowed conversions (thus forcing <code>test(String)</code> to not be considered applicable to an <code>int</code> parameter), some JS developers would feel encumbered by needing to contort their program into invoking the String method (e.g. doing <code>test(String(x))</code> to ensure <code>x</code> is a string, etc. </li>\n</ul>\n\n<p>As you can see, no matter what we do, something else would suffer; overloaded method selection is in a tight spot between Java and JS type systems and very sensitive to even small changes in the logic.</p>\n\n<p>Finally, when you manually select among overloads, you can also stick to unqualified type names, as long as there's no ambiguity in potential methods signatures for the package name in the argument position, that is</p>\n\n<pre><code>API[\"test(Integer[])\"](1);\n</code></pre>\n\n<p>should work too, no need for the <code>java.lang.</code> prefix. That might ease the syntactic noise a bit, unless you can rework the API.</p>\n\n<p>HTH,\n  Attila.</p>\n    "},{"t":"Can Java 7 and Java 8 co-exist on OSX","l":"http://stackoverflow.com/questions/20974607/can-java-7-and-java-8-co-exist-on-osx","q":"\n\n<p>I've installed Java 8 for development purposes but now I'd like to use Java 7 again.</p>\n\n<p>How do I do this?</p>\n\n<p>It seems to be insanely difficult.</p>\n\n<p>Many thanks in advance.\n(I've tried using guigarage and that doesn't work)</p>\n    ","a":"\n<p>From a terminal: <code>export JAVA_HOME=`/usr/libexec/java_home -v 1.x`</code>, where x is the Java version. </p>\n\n<p>I personally have a shell function that does that for me:</p>\n\n<pre><code>use-java () {\n    export JAVA_HOME=`/usr/libexec/java_home -v 1.$1`\n}\n</code></pre>\n\n<p>I just have to call <code>use-java 7</code> or <code>use-java 8</code> in order to change my current shell's Java version. </p>\n    "},{"t":"Any risk using a single dollar sign `$` as a java class name?","l":"http://stackoverflow.com/questions/19529603/any-risk-using-a-single-dollar-sign-as-a-java-class-name","q":"\n\n<p>Originally I was using the underscore <code>_</code> as a class name. The new Java8 compiler complains that it \"<em>might not be supported after Java SE 8</em>\". I changed that to <code>$</code>, and there is no warning any more. However I remember that <code>$</code> is used by Java to indicate an inner/embedded class in the byte code. I am wondering if there is any risk to use a dollar sign <code>$</code> as a class name</p>\n\n<p>Some background to this question. What I want to do is to overcome the fact that Java doesn't support pure function, and the _ or $ is to put an namespace to encapsulate some very generic concept (classes/static methods). and neither do I have a good name for this, nor do I want the lib user type too many things to reference that namespace. Here is the code showing what I am doing under the way: <a href=\"https://github.com/greenlaw110/java-tool/blob/master/src/main/java/org/osgl/_.java\">https://github.com/greenlaw110/java-tool/blob/master/src/main/java/org/osgl/_.java</a></p>\n    ","a":"\n<p>It is bad style, and potentially risky to use <code>$</code> in any identifier in Java.  The reason it is risky is that the <code>$</code> character is reserved for the use of the Java toolchain and third-party language tools.  </p>\n\n<ul>\n<li>It is used by Java compilers in \"internal\" class names for inner and nested classes.</li>\n<li>It is used by Java compilers in the names of synthetic attributes.</li>\n<li>It could be used by third-party code generators (e.g. annotation processors) for various purposes.</li>\n<li>It could be used by other languages that target the JVM platform, and that might need to co-exist with your code.</li>\n</ul>\n\n<p>You probably won't have technical issues with a plain <code>$</code> classname at the moment (at least with respect to the standard Java toolchain).  But there's always the possibility that this will change in the future:  </p>\n\n<ul>\n<li>They have <em>reserved the right</em> to change this.</li>\n<li>There is a precedent for doing this in the <code>_</code> example.</li>\n</ul>\n\n<hr>\n\n<p>If you really, really need a one-character classname, it would be better to play it safe and use <code>F</code> or <code>Z</code> or something else that isn't reserved.</p>\n\n<p>But to be honest, I think you'd be better off trying to implement (or just use) a real functional language than trying to shoe-horn a functional programming \"system\" into Java.  Or maybe, just switch to Java 8 ahead of its official release.  'Cos I for one would <em>refuse</em> to read / maintain a Java codebase that looked like jquery.</p>\n\n<hr>\n\n<blockquote>\n  <p>I don't mean to create a functional lib for Java, just want to create a lib to maintain some common utilities I used. Again, I am a advocate of minimalism and feel suck with things like apache commons. The functional stuff is added to help me easier to manipulate collection(s).</p>\n</blockquote>\n\n<p>If it is your code, you can do what you like.  Make your own decisions.  Act on your opinions.  Be a \"risk taker\" ... :-).  (Our advice on <code>$</code>, etcetera ... is moot.)</p>\n\n<p>But if you are writing this code for a client or employer, or with the intention of creating a (viable) open source product, then you need to take account of other people's opinion.  For example, your boss needs to have an informed opinion on how maintainable your code will be if you find a better paying job somewhere else.  In general, will the next guy be able to figure it out, keep your code, fresh, etc ... or will it be consigned to the dustbin?</p>\n    "},{"t":"Lambda expression to convert array/List of String to array/List of Integers","l":"http://stackoverflow.com/questions/23057549/lambda-expression-to-convert-array-list-of-string-to-array-list-of-integers","q":"\n\n<p>Since Java 8 comes with powerful lambda expressions,</p>\n\n<p>I would like to write a function to convert a List/array of Strings to array/List of Integers, Floats, Doubles etc..</p>\n\n<p>In normal Java, it would be as simple as </p>\n\n<pre><code>for(String str : strList){\n   intList.add(Integer.valueOf(str));\n}\n</code></pre>\n\n<p>But how do I achieve the same with a lambda, given an array of Strings to be converted to an array of Integers.</p>\n    ","a":"\n<p>You could create helper methods that would convert a list (array) of type <code>T</code> to a list (array) of type <code>U</code> using the <a href=\"http://download.java.net/lambda/b78/docs/api/java/util/stream/Stream.html#map%28java.util.function.Function%29\"><code>map</code></a> operation on <a href=\"http://download.java.net/lambda/b78/docs/api/java/util/stream/Stream.html\"><code>stream</code></a>.</p>\n\n<pre><code>//for lists\npublic static &lt;T, U&gt; List&lt;U&gt; convertList(List&lt;T&gt; from, Function&lt;T, U&gt; func){\n    return from.stream().map(func).collect(Collectors.toList());\n}\n\n//for arrays\npublic static &lt;T, U&gt; U[] convertArray(T[] from, Function&lt;T, U&gt; func, \n                                       IntFunction&lt;U[]&gt; generator){\n    return Arrays.stream(from).map(func).toArray(generator);\n}\n</code></pre>\n\n<p>And use it like this:</p>\n\n<pre><code>//for lists\nList&lt;String&gt; stringList = Arrays.asList(\"1\",\"2\",\"3\");\nList&lt;Integer&gt; integerList = convertList(stringList, s -&gt; Integer.parseInt(s));\n\n//for arrays\nString[] stringArr = {\"1\",\"2\",\"3\"};\nDouble[] doubleArr = convertArray(sArr, Double::parseDouble, Double[]::new);\n</code></pre>\n\n<p></p><hr>\nNote that  <code>s -&gt; Integer.parseInt(s)</code> could be replace with <code>Integer::parseInt</code> (see <a href=\"http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html\">Method references</a>)<p></p>\n    "},{"t":"Is there a class in java.time comparable to the Joda-Time Interval?","l":"http://stackoverflow.com/questions/22150722/is-there-a-class-in-java-time-comparable-to-the-joda-time-interval","q":"\n\n<p>I'm evaluating to migrate my project from the usage of <a href=\"http://www.joda.org/joda-time/\">Joda-Time</a> to the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html\">java.time package</a> in <a href=\"https://en.wikipedia.org/wiki/Java_version_history#Java_SE_8_.28March_18.2C_2014.29\">Java 8</a>. In Joda-Time, I heavily used the <a href=\"http://www.joda.org/joda-time/apidocs/org/joda/time/Interval.html\"><code>Interval</code></a> class. I could not find anything like this in java.time. </p>\n\n<p>Is there a comparable class?</p>\n    ","a":"\n<p>Sorry for you, there is no equivalent in JSR-310 to JodaTime-Interval-class. I have doubts if this will ever come, but project lead Stephen Colebourne considers at least to support it in the scope of his external library Threeten-Extra, see this <a href=\"https://github.com/ThreeTen/threeten-extra/issues/2\" rel=\"nofollow\">issue</a>.</p>\n\n<p>If you are happy with JodaTime you should keep it. Not everything in JodaTime is ported to Java 8 (Interval is not the only issue).</p>\n\n<p><strong>Update from 2014-12-13:</strong></p>\n\n<p>The situation in Java-8 has not changed, but you might also consider other external libraries beyond Joda-Time. Either Threeten-Extra which now includes a very simple interval class since v0.9 (see the other answer of S. Colebourne here) or my library Time4J which offers <a href=\"https://github.com/MenoData/Time4J/tree/master/range/src/main/java/net/time4j/range\" rel=\"nofollow\">the range package</a> since v2.0.</p>\n    "},{"t":"Can't parse String to LocalDate (Java 8)","l":"http://stackoverflow.com/questions/31605411/cant-parse-string-to-localdate-java-8","q":"\n\n<p>My input is a String representation of a date in the format \"01-07-2015\" for July 1, 2015. I'm trying to parse this into a <code>java.time.LocalDate</code> variable:</p>\n\n<pre><code>final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd-MM-YYYY\");\nfinal String input = \"01-07-2015\";\nfinal LocalDate localDate = LocalDate.parse(input, DATE_FORMAT);\n</code></pre>\n\n<p>Based on the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\" rel=\"nofollow\"><code>DateTimeFormatter</code> JavaDoc</a>, I would expect this to work. However, I'm greeted with a very friendly and helpful message:</p>\n\n<blockquote>\n  <p>Caused by: java.time.DateTimeException: Unable to obtain LocalDate from TemporalAccessor: {DayOfMonth=1, MonthOfYear=7, WeekBasedYear[WeekFields[MONDAY,4]]=2015},ISO of type java.time.format.Parsed</p>\n</blockquote>\n\n<p>I don't really understand what this exception is telling me. Can anyone explain me what's going wrong?</p>\n    ","a":"\n<p>For year you have to use the lowercase y:</p>\n\n<pre><code>final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd-MM-yyyy\");\n</code></pre>\n\n<p>Uppercase Y is used for weekyear. See the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\">javadoc of DateTimeFormatter</a> for more details.</p>\n    "},{"t":"Java 8 and Generalized Target-Type Inference","l":"http://stackoverflow.com/questions/19934204/java-8-and-generalized-target-type-inference","q":"\n\n<p>I have installed the last JDK 8 ea b114 to test the new language features.\nHowever the inference in chained calls seems not to work yet.</p>\n\n<p>If I write:</p>\n\n<pre><code>Iterator&lt;String&gt; it = new ArrayList&lt;&gt;().iterator();\n</code></pre>\n\n<p>the compiler give me an error.</p>\n\n<p>However inference in argument position works well.</p>\n\n<p>Maybe inference in chained calls will not be inserted?</p>\n    ","a":"\n<p>The latest specification (Public Review) is available at <a href=\"http://jcp.org/en/jsr/detail?id=335\">jcp.org</a>. There is a paragraph in part D which discusses this point.</p>\n\n<blockquote>\n  <p>The receiver in a method invocation, field access, etc. (exp.foo()) is not a poly expression because the target type is unknown—it would be impossible to enumerate every type that has a particular member (foo, in this case). There has been some interest in allowing inference to \"chain\": in a().b(), passing type information from the invocation of b to the invocation of a. This adds another dimension to the complexity of the inference algorithm, as partial information has to pass in both directions; it only works when the erasure of the return type of a() is fixed for all instantiations (e.g. List). This feature would not fit very well into the poly expression model, since the target type cannot be easily derived. </p>\n</blockquote>\n    "},{"t":"How to tell if JRE or JDK is installed","l":"http://stackoverflow.com/questions/22539779/how-to-tell-if-jre-or-jdk-is-installed","q":"\n\n<p>I have one computer that I intentionally installed JDK on. I have another computer with JRE, for, among other things, testing. However, when I got a java application working on this computer, and then tried it on another, it complained that JDK was required. How can I check if JDK was somehow installed on my system? Note: the computer in question is a Mac.</p>\n    ","a":"\n<p>You can open up terminal and simply type </p>\n\n<pre><code>java -version // this will check your jre version\njavac -version // this will check your java compiler version if you installed \n</code></pre>\n\n<p>this should show you the version of java installed on the system (assuming that you have set the path of the java in system environment). </p>\n\n<p>And if you haven't, add it via </p>\n\n<pre><code>export JAVA_HOME=/path/to/java/jdk1.x\n</code></pre>\n\n<p>and if you unsure if you have java at all on your system just use <code>find</code> in terminal</p>\n\n<p>i.e.   <code>find / -name \"java\"</code></p>\n    "},{"t":"Is there an aggregateBy method in the stream Java 8 api?","l":"http://stackoverflow.com/questions/23848129/is-there-an-aggregateby-method-in-the-stream-java-8-api","q":"\n\n<p>Run across this very interesting but one year old <a href=\"http://youtu.be/X2MtmIa7YSs?t=35m39s\" rel=\"nofollow\">presentation</a> by Brian Goetz - in the slide linked he presents an <code>aggregateBy()</code> method supposedly in the Stream API, which is supposed to aggregate the elements of a list (?) to a map (given a default initial value and a method manipulating the value (for duplicate keys also) - see next slide in the presentation).</p>\n\n<p>Apparently there is no such method in the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\" rel=\"nofollow\">Stream API</a>. Is there another method that does something analogous in Java 8 ?</p>\n    ","a":"\n<p>The aggregate operation can be done using the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html\" rel=\"nofollow\"><code>Collectors</code></a> class. So in the video, the example would be equivalent to :</p>\n\n<pre><code>Map&lt;String, Integer&gt; map = documents.stream()\n                                    .collect(Collectors.groupingBy(Document::getAuthor,\n                                                                   Collectors.summingInt(Document::getPageCount)));\n</code></pre>\n\n<p>The <code>groupingBy</code> method will give you a <code>Map&lt;String, List&lt;Document&gt;&gt;</code>. Now you have to use a downstream collector to sum all the page count for each document in the <code>List</code> associated with each key. </p>\n\n<p>This is done by providing a downstream collector to <code>groupingBy</code>, which is <code>summingInt</code>, resulting in a <code>Map&lt;String, Integer&gt;</code>.</p>\n\n<p></p><hr>\nThey give basically the same example in the documentation where they compute the sum of the employees' salary by department.<p></p>\n\n<p>I think that they removed this operation and created the <code>Collectors</code> class instead to have a useful class that contains a lot of reductions that you will use commonly.</p>\n    "},{"t":"Split java.util.stream.Stream","l":"http://stackoverflow.com/questions/30212801/split-java-util-stream-stream","q":"\n\n<p>I have a text file that contains URLs and emails. I need to extract all of them from the file. Each URL and email can be found more then once, but result shouldn't contain duplicates.\nI can extract all URLs using the following code:</p>\n\n<pre><code>Files.lines(filePath).\n    .map(urlPattern::matcher)\n    .filter(Matcher::find)\n    .map(Matcher::group)\n    .distinct();\n</code></pre>\n\n<p>I can extract all emails using the following code:</p>\n\n<pre><code>Files.lines(filePath).\n    .map(emailPattern::matcher)\n    .filter(Matcher::find)\n    .map(Matcher::group)\n    .distinct();\n</code></pre>\n\n<p>Can I extract all URLs and emails reading the stream returned by <code>Files.lines(filePath)</code> only one time?\nSomething like splitting stream of lines to stream of URLs and stream of emails.</p>\n    ","a":"\n<p>You can use <code>partitioningBy</code> collector, though it's still not very elegant solution.</p>\n\n<pre><code>Map&lt;Boolean, List&lt;String&gt;&gt; map = Files.lines(filePath)\n        .filter(str -&gt; urlPattern.matcher(str).matches() ||\n                       emailPattern.matcher(str).matches())\n        .distinct()\n        .collect(Collectors.partitioningBy(str -&gt; urlPattern.matcher(str).matches()));\nList&lt;String&gt; urls = map.get(true);\nList&lt;String&gt; emails = map.get(false);\n</code></pre>\n\n<p>If you don't want to apply regexp twice, you can make it using the intermediate pair object (for example, <code>SimpleEntry</code>):</p>\n\n<pre><code>public static String classify(String str) {\n    return urlPattern.matcher(str).matches() ? \"url\" : \n        emailPattern.matcher(str).matches() ? \"email\" : null;\n}\n\nMap&lt;String, Set&lt;String&gt;&gt; map = Files.lines(filePath)\n        .map(str -&gt; new AbstractMap.SimpleEntry&lt;&gt;(classify(str), str))\n        .filter(e -&gt; e.getKey() != null)\n        .collect(Collectors.groupingBy(e -&gt; e.getKey(),\n            Collectors.mapping(e -&gt; e.getValue(), Collectors.toSet())));\n</code></pre>\n\n<p>Using my free <a href=\"https://github.com/amaembo/streamex\">StreamEx</a> library the last step would be shorter:</p>\n\n<pre><code>Map&lt;String, Set&lt;String&gt;&gt; map = StreamEx.of(Files.lines(filePath))\n        .mapToEntry(str -&gt; classify(str), Function.identity())\n        .nonNullKeys()\n        .grouping(Collectors.toSet());\n</code></pre>\n    "},{"t":"Parallelism in Java 8","l":"http://stackoverflow.com/questions/12234214/parallelism-in-java-8","q":"\n\n<p>I tried to use new parallel feature JDK8, but unfortunately, I couldn't get it to work.\nNetBeans 7.1 says that method \"parallel\" does not exist.</p>\n\n<p>Does this method require special import? \nDoes anyone have sample code demonstrating Java 8 parallelism?</p>\n    ","a":"\n<p>I have been playing with JDK8 Lambda Developer Preview for a few weeks now. The following is what I do to simplify compilation and testing of my code:</p>\n\n<h2>Configure JEdit to Compile JDK 8 Code</h2>\n\n<p>The following guide describes how to configure Apache Ant and JEdit to easily compile source code with JDK 8 Lambda Expressions and the new API features in the JDK 8 Lambda Developer Preview. </p>\n\n<p>This is what I do, as of today, basically because no IDE supports these JDK 8 features yet.</p>\n\n<p>Download the following:</p>\n\n<ul>\n<li><a href=\"http://jdk8.java.net/lambda/\" rel=\"nofollow\">JDK 8</a></li>\n<li><a href=\"http://www.jedit.org/\" rel=\"nofollow\">JEdit</a></li>\n<li><a href=\"http://ant.apache.org/\" rel=\"nofollow\">Apache Ant</a></li>\n</ul>\n\n<p>Then create the following directory structure:</p>\n\n<pre><code>Sanbox\n|-----jdk8\n|-----ant\n|-----projects\n</code></pre>\n\n<ul>\n<li>Place the uncompressed JDK build in the jdk8 directory.</li>\n<li>Place the uncompressed Apache Ant in the ant directory.</li>\n<li>The projects directory will be for JEdit projects.</li>\n</ul>\n\n<p>Then install the following JEdit Plugins:</p>\n\n<ul>\n<li>Ant Farm</li>\n<li>Java Fold</li>\n<li>Project Builder</li>\n<li>Project Viewer</li>\n<li>Project Wizard</li>\n<li>SVN Plugin (I use this to synchronize my projects with my repo, you may not need it, though)</li>\n</ul>\n\n<p>Now, configure your Apache Ant:</p>\n\n<ul>\n<li>Create a file in your home folder named antrc_pre.bat (i.e. %USERPROFILE%\\antrc_pre.bat).</li>\n<li>(Note: if you are using Linux you can configure this in ~/.ant/ant.conf).</li>\n<li>This file will be run by Apache Ant before running any tasks, therefore, this is a place to configure or override which JDK you want to use by defining the JAVA_HOME variable.</li>\n<li>At the top of this file define the JAVA_HOME variable and make it point to the directory where the JDK8 is installed. Somewhat like this: <code>SET JAVA_HOME=C:\\Sanbox\\jdk8</code></li>\n<li>Make sure to comment it out once you're done with your JDK 8 session so that Ant continues to use the default configuration.</li>\n</ul>\n\n<p>Time to configure JEdit Ant Plugin</p>\n\n<ul>\n<li>In JEdit go to Plugins -&gt; Plugin Options -&gt; Ant Farm -&gt; Build Options</li>\n<li>In the dialog select the option: \"Run Ant targets using an external script/build file\"</li>\n<li>Choose the ant.bat script (i.e. C:\\Sandbox\\ant\\bin\\ant.bat).</li>\n<li>Note: If you are using Ant 1.8.x it is probable that you'll need to add a property in the properties section of the plugin: build.compiler=javac1.7, otherwise you would get an error at compiling with JDK 8. I did not have this problem with Ant 1.7, though.</li>\n</ul>\n\n<p>Then create a new Java Project:</p>\n\n<ul>\n<li>In JEdit go to Plugins -&gt; Project Builder -&gt; Create New Project</li>\n<li>Choose Java Application and click Next</li>\n<li>Choose your projects directory as the place to locate files (i.e. C:\\Sanbox\\projects).</li>\n</ul>\n\n<p>Voila! At this point, JEdit will present four buttons in the tool bar: Build Application, Compile, Clean and Run Application. These are based on the build.xml file and are executed according to the corresponding Ant tasks. You're good to go, you may start writing lambda expressions and use the new APIs:-)</p>\n\n<h2>Parallelism Example</h2>\n\n<p>In the last developer preview (b50), there is little paralleism implemented yet. I can see they are doing more work in a seperate branch (if you want to download and build the OpenJDK8 source, though). </p>\n\n<p>You can, however, use a method <code>Arrays.parallell</code> which creates a <code>ParallelIterable</code> wrapper over an array. This you can use to test some of the parallelism features.</p>\n\n<p>I did an example to find primes in a large array. I could verify that all my four cores are used when I run this in parallel.</p>\n\n<pre><code>Integer[] source = new Integer[30000000];\nfor(int i=0; i&lt;source.length; i++)\n    source[i] = i;\n\nParallelIterable&lt;Integer&gt; allIntegers = Arrays.parallel(source).filter(isPrime);\nIterable&lt;Integer&gt; primes = allIntegers.into(new LinkedList&lt;Integer&gt;());\n</code></pre>\n\n<p>This compiles and runs fine in my JEdit Project with Apache Ant 8.4.x and JDk8-b50.</p>\n\n<p>I hope this helps.</p>\n\n<p>PD:</p>\n\n<p>I did not define the predicate <code>isPrime</code> in the code above in order not to obscure the simplicity of the example. I am pretty sure eveyone can easily define a primality predicate to try this code.</p>\n    "},{"t":"Java 8 Optional orElse optional","l":"http://stackoverflow.com/questions/28818506/java-8-optional-orelse-optional","q":"\n\n<p>I've been working with the new Optional type in Java 8, and I've come across what seems like a common operation that isn't supported functionally: an \"orElseOptional\"</p>\n\n<p>Consider the following pattern:</p>\n\n<pre><code>Optional&lt;Result&gt; resultFromServiceA = serviceA(args);\nif (resultFromServiceA.isPresent) return result;\nelse {\n    Optional&lt;Result&gt; resultFromServiceB = serviceB(args);\n    if (resultFromServiceB.isPresent) return resultFromServiceB;\n    else return serviceC(args);\n}\n</code></pre>\n\n<p>There are many forms of this pattern, but it boils down to wanting an \"orElse\" on an optional that takes a function producing a new optional, called only if the current one does not exist.</p>\n\n<p>It's implementation would look like this:</p>\n\n<pre><code>public Optional&lt;T&gt; orElse(Supplier&lt;Optional&lt;? extends T&gt;&gt; otherSupplier) {\n    return value != null ? this : other.get();\n}\n</code></pre>\n\n<p>I'm curious if there's a reason such a method doesn't exist, if I'm just using Optional in an unintended way, and what other ways people have come up with to deal with this case.</p>\n\n<p>I should say that I think that solutions involving custom utility classes/methods aren't elegant because people working with my code won't necessarily know they exist.</p>\n\n<p>Also, if anyone knows, will such a method be included in JDK 9, and where might I propose such a method? This seems like a pretty glaring omission to the API to me.</p>\n    ","a":"\n<p>Perhaps this is what you're after: <a href=\"http://stackoverflow.com/questions/24599996/get-value-from-one-optional-or-another\">Get value from one Optional or another</a></p>\n\n<p>Otherwise, you may want to have a look at <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElseGet-java.util.function.Supplier-\"><code>Optional.orElseGet</code></a>. Here's an example of what I <em>think</em> that you're after:</p>\n\n<pre><code>result = Optional.ofNullable(serviceA().orElseGet(\n                                 () -&gt; serviceB().orElseGet(\n                                     () -&gt; serviceC().orElse(null))));\n</code></pre>\n    "},{"t":"Is the accumulator of reduce in Java 8 allowed to modify its arguments?","l":"http://stackoverflow.com/questions/23869930/is-the-accumulator-of-reduce-in-java-8-allowed-to-modify-its-arguments","q":"\n\n<p>In Java 8, Stream has a method reduce:</p>\n\n<pre><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);\n</code></pre>\n\n<p>Is the accumulator operator allowed to modify either of its arguments?  I presume not since the JavaDoc says the accumulator should be NonInterfering, though all examples talk of modifying the collection, rather than modifying the elements of the collection.</p>\n\n<p>So, for a concrete example, if we have</p>\n\n<pre><code> integers.reduce(0, Integer::sum);\n</code></pre>\n\n<p>and suppose for a moment that <code>Integer</code> was mutable, would <code>sum</code> be allowed to modify its first parameter by adding to it (in place) the value of its second parameter?</p>\n\n<p>I presume not, but I would also like an example of where this Interfering causes a problem.</p>\n    ","a":"\n<p>No.  The accumulator should not modify its arguments; it takes two values and produces a new value.  If you want to use mutation in the course of accumulation (e.g., accumulating strings into a StringBuffer instead of concatenating), use <code>Stream.collect()</code>, which is designed for this.</p>\n\n<p>Here's an example of code that produces the wrong answer if you try this.  Let's say you want to do addition with a hypothetical MutableInteger class: </p>\n\n<pre><code>// Don't do this\nMutableInteger result = stream.reduce(new MutableInteger(0), (a,b) -&gt; a.add(b.get()));\n</code></pre>\n\n<p>One reason this gets the wrong answer is that if we break the computation up in parallel, now two computations are sharing the same mutable starting value.  Note that:</p>\n\n<pre><code>a + b + c + d\n= 0 + a + b + 0 + c + d  // 0 denotes identity\n= (0 + a + b) + (0 + c + d) // associativity\n</code></pre>\n\n<p>so we are free to split the stream, compute the partial sums <code>0 + a + b</code> and <code>0 + c + d</code>, and then add the results.  But if they are sharing the same identity value, and that value is mutated as a result of one of the computations, the other may start with the wrong value.  </p>\n\n<p>(Note further that the implementation would be allowed to do this even for sequential computations, if it thought that was worthwhile.)</p>\n    "},{"t":"Java 8 lambdas that access instance fields and methods can't be deserialized","l":"http://stackoverflow.com/questions/23837215/java-8-lambdas-that-access-instance-fields-and-methods-cant-be-deserialized","q":"\n\n<p>It seems to me it's a bug in the compiler or in the JVM, but maybe someone has a better explanation.</p>\n\n<p>The following code runs fine as is, but if I uncomment the second <code>runnable</code> initialization, that uses 'this' directly, it can't deserialize the object (<code>in.readObject()</code> throws an exception).</p>\n\n<pre><code>public class TestClass implements Serializable {\n    String               msg = \"HEY!\";\n    SerializableRunnable runnable;\n    public TestClass() {\n        TestClass self = this;\n        runnable = () -&gt; self.say();  // uses a local copy of 'this'\n       // runnable = () -&gt; this.say(); // uses 'this' directly\n    }\n    public void say() {\n        System.out.println(msg);\n    }\n    public static void main(String[] args) throws Exception {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        try (ObjectOutputStream out = new ObjectOutputStream(buffer)) {\n            out.writeObject(new TestClass());\n        }\n        try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()))) {\n            TestClass s = (TestClass) in.readObject();\n            s.say();\n        }\n    }\n}\ninterface SerializableRunnable extends Runnable, Serializable {\n}\n</code></pre>\n\n<p>This is the stacktrace for the root cause:</p>\n\n<pre><code>java.lang.IllegalArgumentException: Invalid lambda deserialization\n    at j8test.TestClass.$deserializeLambda$(TestClass.java:1)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:230)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1104)\n    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1810)\n    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)\n    at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:1993)\n    at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1918)\n    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801)\n    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)\n    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:371)\n    at j8test.TestClass.main(TestClass.java:30)\n</code></pre>\n\n<p>Is it the expected behavior?</p>\n    ","a":"\n<p>I tried everything but the most obvious.</p>\n\n<p>The problem happens in Eclipse (wherein the java 8 support is still in beta), but not in javac. Thus, a JDT bug.</p>\n\n<p><strong>[EDIT]</strong></p>\n\n<p>I'm running:</p>\n\n<pre><code>Eclipse IDE for Java and Report Developers\nVersion: Luna RC1 Release (4.4.0RC1)\nBuild id: 20140522-1310\n\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)\n\nOS X 10.9.3\n</code></pre>\n\n<p>Maybe it's already corrected in a more recent build.</p>\n    "},{"t":"Fundamental impediments for non-static access from inner classes to outer interfaces","l":"http://stackoverflow.com/questions/21418802/fundamental-impediments-for-non-static-access-from-inner-classes-to-outer-interf","q":"\n\n<p>Example:</p>\n\n<pre><code>interface Outer {\n    default String get() {\n        return \"hi\";\n    }\n    class Inner {\n        String got() {\n            return get();\n        }\n    }\n}\n</code></pre>\n\n<p>This yields the error </p>\n\n<blockquote>\n  <p>java: non-static method get() cannot be referenced from a static context. </p>\n</blockquote>\n\n<p>The inner interface/class is always static; unlike with an outer class where it's non-static unless declared static.</p>\n\n<p>This is how things are today and in the upcoming java 8. Is there a fundamental reason for this difference between outer classes and outer interfaces?</p>\n\n<p><strong>Update</strong>:\nAfter reading @Radiodef´s comment I changed the inner interface to be an inner class. An outer class can't contain a non-static inner interface so the example was confusing. An inner class is really what I would like anyway.</p>\n\n<p><strong>Update</strong>: For reference. This is perfectly legal:</p>\n\n<pre><code>class Outer {\n    String get() {\n        return \"hei\";\n    }\n    class Inner {\n        String got() {\n            return get();\n        }\n    }\n}\n</code></pre>\n    ","a":"\n<p>Maybe I misunderstood your question, but your code snippet is exactly equivalent to</p>\n\n<pre><code>interface Outer {\n    public default String get() {\n        return \"hi\";\n    }\n    public static class Inner {\n        String got() {\n            return get();\n        }\n    }\n}\n</code></pre>\n\n<p>As <a href=\"http://cr.openjdk.java.net/~mr/se/8/java-se-8-pfd-spec/java-se-8-jls-pfd-diffs.pdf\" rel=\"nofollow\">the JLS Chapter 9.5 (Java 8)</a> states </p>\n\n<blockquote>\n  <p>A member type declaration in an interface is implicitly <code>public</code> and\n  <code>static</code>. It is permitted to redundantly specify either or both of these\n  modifiers.</p>\n</blockquote>\n\n<p>So if you did</p>\n\n<pre><code>Inner innerInstance = new Outer.Inner();\ninnerInstance.got();\n</code></pre>\n\n<p>what would <code>get()</code> be invoked on? There is no object of type <code>Outer</code> involved here.</p>\n\n<blockquote>\n  <p>Is there a fundamental reason for this difference between outer\n  classes and outer interfaces?</p>\n</blockquote>\n\n<p>This isn't the issue. <strong>Your class code is an example of <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3\" rel=\"nofollow\">inner classes</a></strong>, ie. non <code>static</code> nested class. <strong>The interface code is an example of a <code>static</code> nested class</strong>. You are comparing two different things.</p>\n\n<p>The equivalent example with a <code>static</code> nested class within an enclosing class would be</p>\n\n<pre><code>class Outer {\n    String get() {\n        return \"hei\";\n    }\n\n    public static class Inner {\n        String got() {\n            return get(); // won't compile\n        }\n    }\n}\n</code></pre>\n\n<p>where again it doesn't make sense for <code>get()</code> to work since there is no corresponding (enclosing) instance to invoke it on.</p>\n\n<hr>\n\n<p>If the question, as <a href=\"http://stackoverflow.com/questions/21418802/fundamental-impediments-for-non-static-access-from-inner-classes-to-outer-interf/21420600?noredirect=1#comment32316497_21420600\">@Radiodef</a> put it, is </p>\n\n<blockquote>\n  <p>why must the class be implicitly static beyond that this is the\n  existing spec?</p>\n</blockquote>\n\n<p>then my answer is the following:</p>\n\n<p>An interface, by definition, is</p>\n\n<blockquote>\n  <p>A point at which independent systems or diverse groups interact</p>\n</blockquote>\n\n<p>An interface does not have state and it does not have behavior. It simply describes behavior. Interface members are implicitly <code>static</code> because an interface does not have state. On the other hand, it makes sense for the interface type to have state, ie. <code>static</code> members. The important thing is that it is a reference type, not that it is an interface.</p>\n    "},{"t":"JDK8: Getting back the JDK7 look for javadoc","l":"http://stackoverflow.com/questions/24554762/jdk8-getting-back-the-jdk7-look-for-javadoc","q":"\n\n<p>I find it difficult to read the new look-and-feel in JDK8 javadoc compared to JDK7.\nHere's a side-by-side example.</p>\n\n<p>JDK7:\n<img src=\"http://i.stack.imgur.com/60gep.png\" alt=\"JDK7 javadoc look\"></p>\n\n<p>JDK8:\n<img src=\"http://i.stack.imgur.com/RpSJN.png\" alt=\"JDK8 javadoc look\"></p>\n\n<p>JDK8 takes up considerable more space. It now uses the DejaVu font where Arial was previously used. There may be good reasons for that. Dunno.</p>\n\n<p>My biggest problem is in the \"Parameters\" and \"Throws\" sections where there's no longer any visual difference between the argument and its description. They are both in a mono spaced font. Writing descriptive text in mono spaced font is just ugly, I think. Mono spaced font is for names of identifiers, source code listings and the like. (feel free to disagree).</p>\n\n<p>Can I get the JDK7 style back while still using the JDK8 javadoc tool? </p>\n\n<p>I was hoping for something like <code>javadoc -stylesheet jdk7.css</code> where <code>jdk7.css</code> was something included with the JDK8. Also if I decide to customize the css on my own (not my thing, but there may be no other solution) I would hate to have to ensure availability of the new stylesheet on every build server in our enterprise. Perhaps there's a Maven solution for that ? </p>\n\n<h2>POSSIBLE SOLUTION ?</h2>\n\n<p>It has been suggested (below) to use the <a href=\"http://docs.oracle.com/javase/7/docs/api/stylesheet.css\">JDK7 javadoc css</a> with the JDK8 javadoc tool to see if that would bring back some eligible Javadoc.</p>\n\n<p>I've done my test by checking out the source code from the Apache Commons Lang project. I use <em>only</em> the source code, not their POM. This is to ensure that I know I'm working off the right base.</p>\n\n<p>Okay, first - for reference - here's the Javadoc which has been produced by an all JDK7 toolchain (JDK7 javadoc tool, JDK7 css). Here's the POM snippet:</p>\n\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;\n            &lt;version&gt;2.9.1&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;stylesheetfile&gt;${basedir}/src/main/css/jdk7javadoc.css&lt;/stylesheetfile&gt;  \n                &lt;javadocExecutable&gt;C:/Program Files/Java/jdk1.7.0_55/bin&lt;/javadocExecutable&gt;   \n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;  \n</code></pre>\n\n<p>and the resulting Javadoc:\n<img src=\"http://i.stack.imgur.com/FqiVc.png\" alt=\"JDK7 javadoc, JDK7 css\"></p>\n\n<p>Next, the attempt to use the JDK7 css with the JDK8 javadoc tool. Here's the POM snippet:</p>\n\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;\n            &lt;version&gt;2.9.1&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;stylesheetfile&gt;${basedir}/src/main/css/jdk7javadoc.css&lt;/stylesheetfile&gt;  \n                &lt;javadocExecutable&gt;C:/Program Files/Java/jdk1.8.0_05/bin&lt;/javadocExecutable&gt;   \n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;  \n</code></pre>\n\n<p>and the resulting Javadoc:\n<img src=\"http://i.stack.imgur.com/DX7Er.png\" alt=\"JDK8 javadoc, JDK7 css\"></p>\n\n<p>So, as you can see, this strategy did not work out for me.</p>\n\n<h2>UPDATE</h2>\n\n<p>I've just realized that a consequence of this change is that it has become pointless to use <code>{@code }</code> (or <code>&lt;code&gt;</code>) markup on parameter descriptions. It doesn't show anyway. In other words if you liked to do like this in past:</p>\n\n<pre><code>/**\n* ...\n* @param eName the name for the entity or &lt;code&gt;null&lt;/code&gt; to use the default\n* ...\n*/\n</code></pre>\n\n<p>there's simply no point to that anymore. Your <code>null</code> text will not stand out anyway.</p>\n    ","a":"\n<p>The css used in Java 7's Javadoc can be found here:</p>\n\n<p><a href=\"http://docs.oracle.com/javase/7/docs/api/stylesheet.css\" rel=\"nofollow\">http://docs.oracle.com/javase/7/docs/api/stylesheet.css</a></p>\n\n<p>You can then use the <code>stylesheetfile</code> attribute from the javadoc commandline, or ant or maven</p>\n\n<p>from commandline:</p>\n\n<pre><code>%javadoc -stylesheetfile &lt;path&gt; ...\n</code></pre>\n\n<p>in ant:</p>\n\n<pre><code>&lt;javadoc \n        ....\n        stylesheetfile=\"/path/to/stylesheet.css\"\n        /&gt;      \n</code></pre>\n\n<p>in Maven (see <a href=\"http://maven.apache.org/plugins/maven-javadoc-plugin/examples/stylesheet-configuration.html\" rel=\"nofollow\">Maven's stylesheet configuration page for more details</a> ): </p>\n\n<pre><code>&lt;reporting&gt; (or &lt;build&gt;)\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;\n        ...\n        &lt;configuration&gt;\n          &lt;stylesheetfile&gt;${basedir}/path/to/your/stylesheetfile.css&lt;/stylesheetfile&gt;\n          ...\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n    ...\n  &lt;/reporting&gt; (or &lt;/build&gt;) \n</code></pre>\n\n<p><strong>UPDATE</strong></p>\n\n<p>Stephen Colebourne has an article about other breaking changes to Javadoc in Java 8 <a href=\"http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html\" rel=\"nofollow\">here</a> . Apparently, the doclint now enforces HTML <strong>4</strong> compliance and will not link if the link is broken or not 100% correct HTML 4. You can turn it off with <code>-Xdoclint:none</code> as an additional parameter.</p>\n\n<pre><code>&lt;plugins&gt;\n    &lt;plugin&gt;\n      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;\n      &lt;configuration&gt;\n        &lt;additionalparam&gt;-Xdoclint:none&lt;/additionalparam&gt;\n      &lt;/configuration&gt;\n    &lt;/plugin&gt;\n &lt;/plugins&gt;\n</code></pre>\n\n<p>Regarding the <code>&lt;code&gt;</code> tags in parameter descriptions, I did see that too.  It looks like the parameter descriptions in javadoc are now always monospace so you don't need code tags anymore?</p>\n    "},{"t":"Eclipselink ignores entity classes with lambda expressions","l":"http://stackoverflow.com/questions/22298061/eclipselink-ignores-entity-classes-with-lambda-expressions","q":"\n\n<p>I am building a java SE 8 (oracle 1.8.0-b129) application with EclipseLink (2.5.1, also tried 2.5.2-M1), and have an Entity class that is simply being ignored by EclipeLink, despite being correctly annotated and referenced in the persistence.xml file. The logs show no mention of the class, no schema gets generated for it, etc. Using the entity gives the 'The abstract schema type is unknown' error. </p>\n\n<p>I think I have finally tracked down the cause, and thought I would share. Apparently, EclipseLink does not like classes with lambda expressions. Here is a simple class that reproduces the problem:</p>\n\n<pre><code>@Entity\npublic class LambdaEntity {\n\n    @Id\n    private Integer id;\n\n    public void theLambda() {\n        Arrays.asList(1, 2, 3).stream().filter(m -&gt; m == 2);\n    }\n}\n</code></pre>\n\n<p>The lambda expression does not even have to use a persistent property, its simple existence in the class is enough. Does anyone know what could cause this? I'm guessing that EclipeLink chokes on the generated bytecode, but I find it strange that it silently ignores the class.</p>\n\n<p>If you try to use this Entity in an association with other, EclipseLink will give an error saying that the entity is not defined at the <code>persistence.xml</code> file. Part of the stacktrace:</p>\n\n<pre><code>Local Exception Stack: \nException [EclipseLink-30005] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.PersistenceUnitLoadingException\nException Description: An exception was thrown while searching for persistence archives with ClassLoader: sun.misc.Launcher$AppClassLoader@3b9a45b3\nInternal Exception: javax.persistence.PersistenceException: Exception [EclipseLink-28018] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.EntityManagerSetupException\nException Description: Predeployment of PersistenceUnit [hcm-test] failed.\nInternal Exception: Exception [EclipseLink-7250] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.ValidationException\nException Description: [class com.senior.hcm.domain.organization.Workstation] uses a non-entity [class com.senior.hcm.domain.auth.UserRole] as target entity in the relationship attribute [field roles].\n    at org.eclipse.persistence.exceptions.PersistenceUnitLoadingException.exceptionSearchingForPersistenceResources(PersistenceUnitLoadingException.java:127)\n    at org.eclipse.persistence.jpa.PersistenceProvider.createEntityManagerFactoryImpl(PersistenceProvider.java:107)\n    at org.eclipse.persistence.jpa.PersistenceProvider.createEntityManagerFactory(PersistenceProvider.java:177)\n    at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:79)\n    at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:54)\nCaused by: javax.persistence.PersistenceException: Exception [EclipseLink-28018] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.EntityManagerSetupException\nException Description: Predeployment of PersistenceUnit [hcm-test] failed.\nInternal Exception: Exception [EclipseLink-7250] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.ValidationException\nException Description: [class com.senior.hcm.domain.organization.Workstation] uses a non-entity [class com.senior.hcm.domain.auth.UserRole] as target entity in the relationship attribute [field roles].\n    at org.eclipse.persistence.internal.jpa.EntityManagerSetupImpl.createPredeployFailedPersistenceException(EntityManagerSetupImpl.java:1954)\n    at org.eclipse.persistence.internal.jpa.EntityManagerSetupImpl.predeploy(EntityManagerSetupImpl.java:1945)\n    at org.eclipse.persistence.internal.jpa.deployment.JPAInitializer.callPredeploy(JPAInitializer.java:98)\n    at org.eclipse.persistence.jpa.PersistenceProvider.createEntityManagerFactoryImpl(PersistenceProvider.java:96)\n    ... 28 more\nCaused by: Exception [EclipseLink-28018] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.EntityManagerSetupException\nException Description: Predeployment of PersistenceUnit [hcm-test] failed.\nInternal Exception: Exception [EclipseLink-7250] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.ValidationException\nException Description: [class com.senior.hcm.domain.organization.Workstation] uses a non-entity [class com.senior.hcm.domain.auth.UserRole] as target entity in the relationship attribute [field roles].\n    at org.eclipse.persistence.exceptions.EntityManagerSetupException.predeployFailed(EntityManagerSetupException.java:230)\n    ... 32 more\nCaused by: Exception [EclipseLink-7250] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.ValidationException\nException Description: [class com.senior.hcm.domain.organization.Workstation] uses a non-entity [class com.senior.hcm.domain.auth.UserRole] as target entity in the relationship attribute [field roles].\n    at org.eclipse.persistence.exceptions.ValidationException.nonEntityTargetInRelationship(ValidationException.java:1378)\n    at org.eclipse.persistence.internal.jpa.metadata.accessors.mappings.RelationshipAccessor.getReferenceDescriptor(RelationshipAccessor.java:553)\n    at org.eclipse.persistence.internal.jpa.metadata.accessors.mappings.RelationshipAccessor.getOwningMapping(RelationshipAccessor.java:469)\n    at org.eclipse.persistence.internal.jpa.metadata.accessors.mappings.ManyToManyAccessor.process(ManyToManyAccessor.java:149)\n    at org.eclipse.persistence.internal.jpa.metadata.MetadataProject.processNonOwningRelationshipAccessors(MetadataProject.java:1566)\n    at org.eclipse.persistence.internal.jpa.metadata.MetadataProject.processStage3(MetadataProject.java:1855)\n    at org.eclipse.persistence.internal.jpa.metadata.MetadataProcessor.processORMMetadata(MetadataProcessor.java:580)\n    at org.eclipse.persistence.internal.jpa.deployment.PersistenceUnitProcessor.processORMetadata(PersistenceUnitProcessor.java:585)\n    at org.eclipse.persistence.internal.jpa.EntityManagerSetupImpl.predeploy(EntityManagerSetupImpl.java:1869)\n    ... 30 more\n</code></pre>\n    ","a":"\n<p>As suggested by Michael Jess (thank you :)), here is a link to the <a href=\"https://bugs.eclipse.org/bugs/show_bug.cgi?id=429992\">bug report</a> for this problem. Unfortunately I have not found the time to test the work that has been done there yet, but it looks promising. This problem should not be around much longer, it appears.</p>\n    "},{"t":"When does Java require explicit type parameters?","l":"http://stackoverflow.com/questions/31370113/when-does-java-require-explicit-type-parameters","q":"\n\n<p>Given:</p>\n\n<pre><code>import com.google.common.collect.ImmutableMap;\nimport java.util.function.Function;\nimport java.util.stream.Collector;\nimport java.util.stream.Stream;\n\npublic class Testcase\n{\n    public static &lt;T, K, V&gt; MapCollectorBuilder&lt;T, K, V&gt;\n        toImmutableMap(Function&lt;? super T, ? extends K&gt; keyMapper,\n            Function&lt;? super T, ? extends V&gt; valueMapper)\n    {\n        return null;\n    }\n\n    public static final class MapCollectorBuilder&lt;T, K, V&gt;\n    {\n        public Collector&lt;T, ?, ImmutableMap&lt;K, V&gt;&gt; build()\n        {\n            return null;\n        }\n    }\n\n    public static &lt;T, K, V&gt; Collector&lt;T, ?, ImmutableMap&lt;K, V&gt;&gt; toImmutableMap2(\n        Function&lt;? super T, ? extends K&gt; keyMapper,\n        Function&lt;? super T, ? extends V&gt; valueMapper)\n    {\n        return null;\n    }\n\n    public void main(String[] args)\n    {\n        Function&lt;String, String&gt; keyMapper = i -&gt; i;\n        Function&lt;String, Integer&gt; valueMapper = Integer::valueOf;\n\n        ImmutableMap&lt;String, Integer&gt; map1 = Stream.of(\"1\", \"2\", \"3\")\n            .collect(Testcase.toImmutableMap(keyMapper, valueMapper).build());\n\n        ImmutableMap&lt;String, Integer&gt; map2 = Stream.of(\"1\", \"2\", \"3\")\n            .collect(Testcase.toImmutableMap(i -&gt; i, Integer::valueOf).build());\n\n        ImmutableMap&lt;String, Integer&gt; map3 = Stream.of(\"1\", \"2\", \"3\")\n            .collect(Testcase.toImmutableMap2(i -&gt; i, Integer::valueOf));\n    }\n}\n</code></pre>\n\n<p>The statements involving <code>map1</code> and <code>map3</code> compile fine, but <code>map2</code> fails with:</p>\n\n<pre><code>Testcase.java:[41,57] incompatible types: cannot infer type-variable(s) T,K,V\n    (argument mismatch; invalid method reference\n      no suitable method found for valueOf(java.lang.Object)\n          method java.lang.Integer.valueOf(java.lang.String) is not applicable\n            (argument mismatch; java.lang.Object cannot be converted to java.lang.String)\n          method java.lang.Integer.valueOf(int) is not applicable\n            (argument mismatch; java.lang.Object cannot be converted to int))\n</code></pre>\n\n<p>The compiler error can be solved by providing explicit type parameters <code>&lt;String, String, Integer&gt;</code>.</p>\n\n<ol>\n<li>When does Java 8 require explicit type parameters? Meaning, is there a known pattern that breaks type inference?</li>\n<li>Can <code>toImmutableMap()</code> and <code>MapCollectorBuilder</code> be changed to avoid explicit type parameters without losing the use of a Builder for configuring the Collector?</li>\n</ol>\n\n<p><strong>UPDATE</strong>:</p>\n\n<ol start=\"3\">\n<li>Why does the statement involving <code>map3</code> work? How does it differ from the statement involving <code>map2</code>?</li>\n</ol>\n    ","a":"\n<p>To answer your question “Meaning, is there a known pattern that breaks type inference?” shortly: of course, there is a pattern, moreover there is a <a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/index.html\" rel=\"nofollow\">huge specification</a> for the entire behavior of the Java programming language.</p>\n\n<p>But the chapters regarding type inference and method invocation types are really exhaustive and hard to understand. This is best illustrated by the fact that in the case of unexpected behavior, often large discussions about the expected behavior according to the specification occur.</p>\n\n<p>But there are some points explainable and rememberable for a programmer.</p>\n\n<p>There are two ways how to infer the type parameters, by the arguments passed to a method or parts from which an expression is composed or by the <em>target type</em> of an expression, that is, the expected type for a parameter of an invocation, the variable which is assigned or the return type of a method in case of a return statement.</p>\n\n<p>The target type can get propagated through nested method invocations like in</p>\n\n<pre><code>TargetType x=foo(bar(/*target type can be used*/));\n</code></pre>\n\n<p>or in a conditional like</p>\n\n<pre><code>TargetType x=condition? foo(/*target type can be used*/): foo(/*target type can be used*/);\n</code></pre>\n\n<p>but <em>not</em> in case of a chained invocation as in</p>\n\n<pre><code>TargetType x=foo(/*target type can NOT be used*/).foo();\n</code></pre>\n\n<hr>\n\n<p>Now to your examples:</p>\n\n<pre><code>ImmutableMap&lt;String, Integer&gt; map1 = Stream.of(\"1\", \"2\", \"3\").collect( expression );\n</code></pre>\n\n<p>Here, the <code>Stream.of(…)</code> and <code>.collect(…)</code> are <em>chained</em>, therefore the target type cannot be used to determine the stream type of the <code>of</code> invocation but the arguments provided to that method are sufficient to infer the type <code>Stream&lt;String&gt;</code>. The <code>collect</code> method provides the result that gets assigned to <code>map1</code>, so both, the stream type <code>Stream&lt;String&gt;</code><em>and</em> the target type <code>ImmutableMap&lt;String, Integer&gt;</code> are known and can be used for the type inference for the <em>expression</em>. Onto the expressions:</p>\n\n<ul>\n<li><p><code>Testcase.toImmutableMap(keyMapper, valueMapper).build()</code> this is a chained invocation, so the target type is known for <code>build()</code> but not for <code>toImmutableMap</code>. However, the arguments to <code>toImmutableMap</code> are local variables which have a known exact type, therefore the type inference can use them to infer the result type of <code>toImmutableMap</code> and check whether it matches the expectations for <code>.build()</code></p></li>\n<li><p><code>Testcase.toImmutableMap(i -&gt; i, Integer::valueOf).build()</code> this is again a chained invocation but now the argument <code>i - &gt; i</code> has an incomplete type and suffers from the absence of the target type. The attempt to guess a type for <code>i -&gt; i</code> without knowledge about the target type fails.</p></li>\n<li><p><code>Testcase.toImmutableMap2(i -&gt; i, Integer::valueOf)</code> this is <em>not</em> a chained invocation, therefore the target type is available for the <code>toImmutableMap2</code> call (in respect to the <code>collect</code> call, it’s a nested invocation). Therefore, the target type of <code>toImmutableMap2</code> allows to infer target types for the parameters, hence for the <code>i -&gt; i</code> lambda expression. With a proper target type, the correct functional signature can be inferred.</p></li>\n</ul>\n    "},{"t":"Concatenating parallel streams","l":"http://stackoverflow.com/questions/30464397/concatenating-parallel-streams","q":"\n\n<p>Suppose that I have two <code>int[]</code> arrays <code>input1</code> and <code>input2</code>. I want to take only positive numbers from the first one, take distinct numbers from the second one, merge them together, sort and store into the resulting array. This can be performed using streams:</p>\n\n<pre><code>int[] result = IntStream.concat(Arrays.stream(input1).filter(x -&gt; x &gt; 0), \n                   Arrays.stream(input2).distinct()).sorted().toArray();\n</code></pre>\n\n<p>I want to speed up the task, so I consider to make the stream parallel. Usually this just means that I can insert <code>.parallel()</code> anywhere between the stream construction and terminal operation and the result will be the same. The JavaDoc for <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#concat-java.util.stream.IntStream-java.util.stream.IntStream-\">IntStream.concat</a> says that the resulting stream will be parallel if any of the input streams is parallel. So I thought that making <code>parallel()</code> either <code>input1</code> stream or <code>input2</code> stream or the concatenated stream will produce the same result.</p>\n\n<p>Actually I was wrong: if I add <code>.parallel()</code> to the resulting stream, it seems that the input streams remain sequential. Moreover, I can mark the input streams (either of them or both) as <code>.parallel()</code>, then turn the resulting stream to <code>.sequential()</code>, but the input remains parallel. So actually there are 8 possibilities: either of input1, input2 and concatenated stream can be parallel or not:</p>\n\n<pre><code>int[] sss = IntStream.concat(Arrays.stream(input1).filter(x -&gt; x &gt; 0),\n                Arrays.stream(input2).distinct()).sorted().toArray();\nint[] ssp = IntStream.concat(Arrays.stream(input1).filter(x -&gt; x &gt; 0),\n                Arrays.stream(input2).distinct()).parallel().sorted().toArray();\nint[] sps = IntStream.concat(Arrays.stream(input1).filter(x -&gt; x &gt; 0), \n                Arrays.stream(input2).parallel().distinct()).sequential().sorted().toArray();\nint[] spp = IntStream.concat(Arrays.stream(input1).filter(x -&gt; x &gt; 0), \n                Arrays.stream(input2).parallel().distinct()).sorted().toArray();\nint[] pss = IntStream.concat(Arrays.stream(input1).parallel().filter(x -&gt; x &gt; 0),\n                Arrays.stream(input2).distinct()).sequential().sorted().toArray();\nint[] psp = IntStream.concat(Arrays.stream(input1).parallel().filter(x -&gt; x &gt; 0),\n                Arrays.stream(input2).distinct()).sorted().toArray();\nint[] pps = IntStream.concat(Arrays.stream(input1).parallel().filter(x -&gt; x &gt; 0),\n                Arrays.stream(input2).parallel().distinct()).sequential().sorted().toArray();\nint[] ppp = IntStream.concat(Arrays.stream(input1).parallel().filter(x -&gt; x &gt; 0),\n                Arrays.stream(input2).parallel().distinct()).sorted().toArray();\n</code></pre>\n\n<p>I <a href=\"https://gist.github.com/amaembo/51c809337b097151e736\">benchmarked</a> all the versions for different input sizes (using JDK 8u45 64bit on Core i5 4xCPU, Win7) and got different results for every case:</p>\n\n<pre><code>Benchmark           (n)  Mode  Cnt       Score       Error  Units\nConcatTest.SSS      100  avgt   20       7.094 ±     0.069  us/op\nConcatTest.SSS    10000  avgt   20    1542.820 ±    22.194  us/op\nConcatTest.SSS  1000000  avgt   20  350173.723 ±  7140.406  us/op\nConcatTest.SSP      100  avgt   20       6.176 ±     0.043  us/op\nConcatTest.SSP    10000  avgt   20     907.855 ±     8.448  us/op\nConcatTest.SSP  1000000  avgt   20  264193.679 ±  6744.169  us/op\nConcatTest.SPS      100  avgt   20      16.548 ±     0.175  us/op\nConcatTest.SPS    10000  avgt   20    1831.569 ±    13.582  us/op\nConcatTest.SPS  1000000  avgt   20  500736.204 ± 37932.197  us/op\nConcatTest.SPP      100  avgt   20      23.871 ±     0.285  us/op\nConcatTest.SPP    10000  avgt   20    1141.273 ±     9.310  us/op\nConcatTest.SPP  1000000  avgt   20  400582.847 ± 27330.492  us/op\nConcatTest.PSS      100  avgt   20       7.162 ±     0.241  us/op\nConcatTest.PSS    10000  avgt   20    1593.332 ±     7.961  us/op\nConcatTest.PSS  1000000  avgt   20  383920.286 ±  6650.890  us/op\nConcatTest.PSP      100  avgt   20       9.877 ±     0.382  us/op\nConcatTest.PSP    10000  avgt   20     883.639 ±    13.596  us/op\nConcatTest.PSP  1000000  avgt   20  257921.422 ±  7649.434  us/op\nConcatTest.PPS      100  avgt   20      16.412 ±     0.129  us/op\nConcatTest.PPS    10000  avgt   20    1816.782 ±    10.875  us/op\nConcatTest.PPS  1000000  avgt   20  476311.713 ± 19154.558  us/op\nConcatTest.PPP      100  avgt   20      23.078 ±     0.622  us/op\nConcatTest.PPP    10000  avgt   20    1128.889 ±     7.964  us/op\nConcatTest.PPP  1000000  avgt   20  393699.222 ± 56397.445  us/op\n</code></pre>\n\n<p>From these results I can only conclude that parallelization of <code>distinct()</code> step reduces the overall performance (at least in my tests).</p>\n\n<p>So I have the following questions:</p>\n\n<ol>\n<li>Are there any official guidelines on how to better use the parallelization with concatenated streams? It's not always feasible to test all possible combinations (especially when concatenating more than two streams), so having some \"rules of thumb\" would be nice.</li>\n<li>Seems that if I concatenate the streams created directly from collection/array (without intermediate operations performed before concatenation), then results do not depend so much on the location of <code>parallel()</code> . Is this true?</li>\n<li>Are there any other cases besides concatenation where the result depends on at which point the stream pipeline is parallelized?</li>\n</ol>\n    ","a":"\n<p>The specification precisely describes what you get—when you consider that, unlike other operations, we are not talking about a single pipeline but three distinct <code>Stream</code>s which retain their properties independent of the others.</p>\n\n<p>The specification says: “<em>The resulting stream is […] parallel if either of the input streams is parallel</em>.” and that’s what you get; if either <em>input</em> stream is parallel, the <em>resulting</em> stream is parallel (but you can turn it to sequential afterwards). But changing the <em>resulting</em> stream to parallel or sequential does not change the nature of the <em>input</em> streams nor does feeding a parallel and a sequential stream into <code>concat</code>.</p>\n\n<p>Regarding the performance consequences, consult the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps\">documentation, paragraph “Stream operations and pipelines”</a>:</p>\n\n<blockquote>\n  <p>Intermediate operations are further divided into <em>stateless</em> and <em>stateful</em> operations. Stateless operations, such as <code>filter</code> and <code>map</code>, retain no state from previously seen element when processing a new element -- each element can be processed independently of operations on other elements. Stateful operations, such as <code>distinct</code> and <code>sorted</code>, may incorporate state from previously seen elements when processing new elements.</p>\n  \n  <p>Stateful operations may need to process the entire input before producing a result. For example, one cannot produce any results from sorting a stream until one has seen all elements of the stream. As a result, under parallel computation, some pipelines containing stateful intermediate operations may require multiple passes on the data or may need to buffer significant data. Pipelines containing exclusively stateless intermediate operations can be processed in a single pass, whether sequential or parallel, with minimal data buffering.</p>\n</blockquote>\n\n<p>You have chosen the very two named <em>stateful</em> operations and combined them. So the <code>.sorted()</code> operation of the resulting stream requires a buffering of the entire content before it can start the sorting which implies a completion of the <code>distinct</code> operation. The distinct operation is obviously hard to parallelize as the threads have to synchronize about the already seen values.</p>\n\n<p>So to answer you first question, it’s not about <code>concat</code> but simply that <code>distinct</code> doesn’t benefit from parallel execution.</p>\n\n<p>This also renders your second question obsolete as your are performing entirely different operations in the two concatenated streams so you can’t do the same with a pre-concatenated collection/array. Concatenating the arrays and running <code>distinct</code> on the resulting array is unlikely to yield better results.</p>\n\n<p>Regarding your third question, <code>flatMap</code>’s behavior regarding <code>parallel</code> streams may be a source of surprises…</p>\n    "},{"t":"How to display common era (“CE”) in Java-8?","l":"http://stackoverflow.com/questions/29494210/how-to-display-common-era-ce-in-java-8","q":"\n\n<p>Following code does not print \"CE\" or \"Current Era\":</p>\n\n<pre><code>System.out.println(IsoEra.CE.getDisplayName(TextStyle.SHORT, Locale.UK)); // output: AD\nSystem.out.println(IsoEra.CE.getDisplayName(TextStyle.FULL, Locale.UK)); // output: Anno Domini\n</code></pre>\n\n<p>Of course, <code>IsoEra.CE.name()</code> helps but not if the full display name like \"common era\" or \"current era\" is required. I consider this a little bit strange because the javadoc of <code>IsoEra</code> explicitly mentions the term \"Current era\" in its class description. It does not even work for root locale. The use-case here is to serve clients with a non-religious background.</p>\n\n<p>This does not help, too:</p>\n\n<pre><code>LocalDate date = LocalDate.now();\nString year = date.format(DateTimeFormatter.ofPattern(\"G yyyy\", Locale.UK)); // AD 2015\nSystem.out.println(year);\n</code></pre>\n\n<p>The only way I found was:</p>\n\n<pre><code>TextStyle style = ...;\nMap&lt;Long,String&gt; eras = new HashMap&lt;&gt;();\nlong bce = (long) IsoEra.BCE.getValue(); // 0L\nlong ce = (long) IsoEra.CE.getValue(); // 1L\nif (style == TextStyle.FULL) {\n  eras.put(bce, \"Before current era\");\n  eras.put(ce, \"Current era\");\n} else {\n  eras.put(bce, \"BCE\");\n  eras.put(ce, \"CE\");\n}\nDateTimeFormatter dtf = \n  new DateTimeFormatterBuilder()\n  .appendText(ChronoField.ERA, eras)\n  .appendPattern(\" yyyy\").toFormatter();\nSystem.out.println(LocalDate.now().format(dtf)); // CE 2015\n</code></pre>\n\n<p>Is there any better or shorter way?</p>\n    ","a":"\n<p>No, there is no better way to do it!</p>\n\n<p>Explanation: \"Current era\" (and accoridngly \"before current era\") is the \"name of a field\"(abstract/meta) of the ISO standard. Of course there is also <strong>no</strong> (standardized) country specific translation for these fields and no pattern which prints this output.(By the standard they are referenced in english only, and by jdk respectively only as <code>CE, BCE</code>). So what the original output shows: </p>\n\n<pre><code>  AD\n  Anno Domini\n</code></pre>\n\n<p>is correct, and the ISO-conform (english) translation of the era (of a date which is \"in  the current era\"). </p>\n\n<p>To solve this, I absolutely agree with your approach (of custom date formatting), and going deeper into details: I wouldn't dare to change a single line of it!</p>\n\n<p>The only savings potential I see is in \"initialization\"(maybe use a EnumMap for the TextStyles...and ... how many languages do you want to support?) ..and \"by refactoring\".</p>\n\n<p>Thank you for the interesting \"problem\", and providing a solution to it!</p>\n    "},{"t":"Virtual Extension Methods in upcoming Java 8 release","l":"http://stackoverflow.com/questions/9025230/virtual-extension-methods-in-upcoming-java-8-release","q":"\n\n<p>When I see code snippets like</p>\n\n<pre><code>  interface A {\n      void a();\n      void b() default { System.out.println(\"b\"); };\n      void c() final { System.out.println(\"c\"); };\n  }\n</code></pre>\n\n<p>I have one question. <s>Haven't we already got enough sh*t in Java?</s> Why one might need this? </p>\n    ","a":"\n<p>I suggest you to look at this conference : <a href=\"http://medianetwork.oracle.com/media/show/16999\">http://medianetwork.oracle.com/media/show/16999</a></p>\n\n<p>This explain everything. The most interesting thing to do is to allow an interface to evolve without rewritting your whole codebase. This is key to allow a big codebase to evolve and not become more and more crippled.</p>\n    "},{"t":"Using a semaphore inside a nested Java 8 parallel stream action may DEADLOCK. Is this a bug?","l":"http://stackoverflow.com/questions/23442183/using-a-semaphore-inside-a-nested-java-8-parallel-stream-action-may-deadlock-is","q":"\n\n<p>Consider the following situation: We are using a Java 8 parallel stream to perform a parallel forEach loop, e.g., </p>\n\n<pre><code>IntStream.range(0,20).parallel().forEach(i -&gt; { /* work done here */})\n</code></pre>\n\n<p>The number of parallel threads is controlled by the system property \"java.util.concurrent.ForkJoinPool.common.parallelism\" and usually equal to the number of processors.</p>\n\n<p>Now assume that we like to limit the number of parallel executions for a specific piece of work - e.g. because that part is memory intensive and memory constrain imply a limit of parallel executions.</p>\n\n<p>An obvious and elegant way to limit parallel executions is to use a Semaphore (suggested <a href=\"http://stackoverflow.com/questions/23442183\">here</a>), e.g., the following pice of code limits the number of parallel executions to 5:</p>\n\n<pre><code>        final Semaphore concurrentExecutions = new Semaphore(5);\n        IntStream.range(0,20).parallel().forEach(i -&gt; {\n\n            concurrentExecutions.acquireUninterruptibly();\n\n            try {\n                /* WORK DONE HERE */\n            }\n            finally {\n                concurrentExecutions.release();\n            }\n        });\n</code></pre>\n\n<p>This works just fine!</p>\n\n<p>However: Using any other parallel stream inside the worker (at <code>/* WORK DONE HERE */</code>) may result in a <strong>deadlock</strong>.</p>\n\n<p>For me this is an unexpected behavior.</p>\n\n<p>Explanation: Since Java streams use a ForkJoin pool, the inner forEach is forking, and the join appears to be waiting for ever. However, this behavior is still unexpected. Note that parallel streams even work if you set <code>\"java.util.concurrent.ForkJoinPool.common.parallelism\"</code> to 1.</p>\n\n<p>Note also that it may not be transparent if there is an inner parallel forEach.</p>\n\n<p><strong>Question:</strong> <em>Is this behavior in accordance with the Java 8 specification (in that case it would imply that the use of Semaphores inside parallel streams workers is forbidden) or is this a bug?</em> </p>\n\n<p>For convenience: Below is a complete test case. Any combinations of the two booleans work, except \"true, true\", which results in the deadlock.</p>\n\n<p><strong>Clarification:</strong> To make the point clear, let me stress one aspect: The deadlock does not occur at the <code>acquire</code> of the semaphore. Note that the code consists of</p>\n\n<ol>\n<li>acquire semaphore</li>\n<li>run some code</li>\n<li>release semaphore</li>\n</ol>\n\n<p>and the deadlock occurs at 2. if that piece of code is using ANOTHER parallel stream. Then the deadlock occurs inside that OTHER stream. As a consequence it appears that it is not allowed to use nested parallel streams and blocking operations (like a semaphore) together!</p>\n\n<p>Note that it is documented that parallel streams use a ForkJoinPool and that ForkJoinPool and Semaphore belong to the same package - <code>java.util.concurrent</code> (so one would expect that they interoperate nicely).</p>\n\n<pre><code>/*\n * (c) Copyright Christian P. Fries, Germany. All rights reserved. Contact: email@christian-fries.de.\n *\n * Created on 03.05.2014\n */\npackage net.finmath.experiments.concurrency;\n\nimport java.util.concurrent.Semaphore;\nimport java.util.stream.IntStream;\n\n/**\n * This is a test of Java 8 parallel streams.\n * \n * The idea behind this code is that the Semaphore concurrentExecutions\n * should limit the parallel executions of the outer forEach (which is an\n * &lt;code&gt;IntStream.range(0,numberOfTasks).parallel().forEach&lt;/code&gt; (for example:\n * the parallel executions of the outer forEach should be limited due to a\n * memory constrain).\n * \n * Inside the execution block of the outer forEach we use another parallel stream\n * to create an inner forEach. The number of concurrent\n * executions of the inner forEach is not limited by us (it is however limited by a\n * system property \"java.util.concurrent.ForkJoinPool.common.parallelism\").\n * \n * Problem: If the semaphore is used AND the inner forEach is active, then\n * the execution will be DEADLOCKED.\n * \n * Note: A practical application is the implementation of the parallel\n * LevenbergMarquardt optimizer in\n * {@link http://finmath.net/java/finmath-lib/apidocs/net/finmath/optimizer/LevenbergMarquardt.html}\n * In one application the number of tasks in the outer and inner loop is very large (&gt;1000)\n * and due to memory limitation the outer loop should be limited to a small (5) number\n * of concurrent executions.\n * \n * @author Christian Fries\n */\npublic class ForkJoinPoolTest {\n\n    public static void main(String[] args) {\n\n        // Any combination of the booleans works, except (true,true)\n        final boolean isUseSemaphore    = true;\n        final boolean isUseInnerStream  = true;\n\n        final int       numberOfTasksInOuterLoop = 20;              // In real applications this can be a large number (e.g. &gt; 1000).\n        final int       numberOfTasksInInnerLoop = 100;             // In real applications this can be a large number (e.g. &gt; 1000).\n        final int       concurrentExecusionsLimitInOuterLoop = 5;\n        final int       concurrentExecutionsLimitForStreams = 10;\n\n        final Semaphore concurrentExecutions = new Semaphore(concurrentExecusionsLimitInOuterLoop);\n\n        System.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\",Integer.toString(concurrentExecutionsLimitForStreams));\n        System.out.println(\"java.util.concurrent.ForkJoinPool.common.parallelism = \" + System.getProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\"));\n\n        IntStream.range(0,numberOfTasksInOuterLoop).parallel().forEach(i -&gt; {\n\n            if(isUseSemaphore) {\n                concurrentExecutions.acquireUninterruptibly();\n            }\n\n            try {\n                System.out.println(i + \"\\t\" + concurrentExecutions.availablePermits() + \"\\t\" + Thread.currentThread());\n\n                if(isUseInnerStream) {\n                    runCodeWhichUsesParallelStream(numberOfTasksInInnerLoop);\n                }\n                else {\n                    try {\n                        Thread.sleep(10*numberOfTasksInInnerLoop);\n                    } catch (Exception e) {\n                    }\n                }\n            }\n            finally {\n                if(isUseSemaphore) {\n                    concurrentExecutions.release();\n                }\n            }\n        });\n\n        System.out.println(\"D O N E\");\n    }\n\n    /**\n     * Runs code in a parallel forEach using streams.\n     * \n     * @param numberOfTasksInInnerLoop Number of tasks to execute.\n     */\n    private static void runCodeWhichUsesParallelStream(int numberOfTasksInInnerLoop) {\n        IntStream.range(0,numberOfTasksInInnerLoop).parallel().forEach(j -&gt; {\n            try {\n                Thread.sleep(10);\n            } catch (Exception e) {\n            }\n        });\n    }\n}\n</code></pre>\n    ","a":"\n<p>Any time you are decomposing a problem into tasks, where those tasks could be blocked on other tasks, and try and execute them in a finite thread pool, you are at risk for <em>pool-induced deadlock</em>.  See <em>Java Concurrency in Practice</em> 8.1.  </p>\n\n<p>This is unquestionably a bug -- in your code.  You're filling up the FJ pool with tasks that are going to block waiting for the results of other tasks in the same pool.  Sometimes you get lucky and things manage to not deadlock (just like not all lock-ordering errors result in deadlock all the time), but fundamentally you're skating on some very thin ice here.  </p>\n    "},{"t":"Java8: HashMap<X, Y> to HashMap<X, Z> using Stream / Map-Reduce / Collector","l":"http://stackoverflow.com/questions/25903137/java8-hashmapx-y-to-hashmapx-z-using-stream-map-reduce-collector","q":"\n\n<p>I know how to \"transform\" a simple Java <code>List</code> from <code>Y</code> -&gt; <code>Z</code>, i.e.:</p>\n\n<pre><code>List&lt;String&gt; x;\nList&lt;Integer&gt; y = x.stream()\n        .map(s -&gt; Integer.parseInt(s))\n        .collect(Collectors.toList());\n</code></pre>\n\n<p>Now I'd like to do basically the same with a Map, i.e.:</p>\n\n<pre><code>INPUT:\n{\n  \"key1\" -&gt; \"41\",    // \"41\" and \"42\"\n  \"key2\" -&gt; \"42      // are Strings\n}\n\nOUTPUT:\n{\n  \"key1\" -&gt; 41,      // 41 and 42\n  \"key2\" -&gt; 42       // are Integers\n}\n</code></pre>\n\n<p>The solution should not be limited to <code>String</code> -&gt; <code>Integer</code>. Just like in the <code>List</code> example above, I'd like to call any method (or constructor).</p>\n    ","a":"\n<pre><code>Map&lt;String, String&gt; x;\nMap&lt;String, Integer&gt; y = x.entrySet().stream()\n                          .collect(Collectors.toMap(\n                              e -&gt; e.getKey(),\n                              e -&gt; Integer.parseInt(e.getValue())\n                          ));\n</code></pre>\n\n<p>It's not quite as nice as the list code. You can't construct new <code>Map.Entry</code>s in a <code>map()</code> call so the work is mixed into the <code>collect()</code> call.</p>\n    "},{"t":"Is mapToDouble() really necessary for summing a List<Double> with Java 8 streams?","l":"http://stackoverflow.com/questions/24421140/is-maptodouble-really-necessary-for-summing-a-listdouble-with-java-8-streams","q":"\n\n<p>As far as I can tell, the way to sum a <code>List&lt;Double&gt;</code> using Java 8 streams is this:</p>\n\n<pre><code>List&lt;Double&gt; vals = . . . ;\ndouble sum = vals.stream().mapToDouble(Double::doubleValue).sum();\n</code></pre>\n\n<p>To me, the <code>mapToDouble(Double::doubleValue)</code> seems kind of crufty - just the sort of boilerplate \"ceremony\" that lambdas and streams were supposed to dispense with.</p>\n\n<p>Best practices tell us to prefer <code>List</code> instances over arrays, and yet for this sort of summing, arrays seem cleaner:</p>\n\n<pre><code>double[] vals = . . . ;\ndouble sum = Arrays.stream(vals).sum();\n</code></pre>\n\n<p>Granted, one could do this:</p>\n\n<pre><code>List&lt;Double&gt; vals = . . . ;\ndouble sum = vals.stream().reduce(0.0, (i,j) -&gt; i+j);\n</code></pre>\n\n<p>But that <code>reduce(....)</code> is so much longer than <code>sum()</code>.</p>\n\n<p>I get that this has to do with the way streams need to be retrofitted around the Java's non-object primitives, but still, am I missing something here?  Is there some way to squeeze autoboxing in to make this shorter?  Or is this just the current state of the art?</p>\n\n<hr>\n\n<h2>Update - Answers Digest</h2>\n\n<p>Here is a digest of answers below. While I have a summary here, I urge the reader to peruse the answers themselves in full.</p>\n\n<p>@dasblinkenlight explains that some kind of unboxing will always be necessary, due to decisions made further back in the history of Java, specifically in the way generics were implemented and their relationship to the non-object primitives. He notes that it is theoretically possible for the compiler to intuit the unboxing and allow for briefer code, but this has not yet been implemented.</p>\n\n<p>@Holger shows a solution that is very close to the expressiveness I was asking about:</p>\n\n<pre><code>double sum = vals.stream().reduce(0.0, Double::sum);\n</code></pre>\n\n<p>I was unaware of the new static <code>Double.sum()</code> method.  Added with 1.8, it seems intended for the very purpose I was describing.  I also found <code>Double.min()</code> and <code>Double.max()</code>.  Going forward, I will definitely use this idiom for such operations on <code>List&lt;Double&gt;</code> and similar.</p>\n    ","a":"\n<blockquote>\n  <p>To me, the <code>mapToDouble(Double::doubleValue)</code> seems [what] lambdas and streams were supposed to dispense with.</p>\n</blockquote>\n\n<p>The need to use <code>mapToDouble</code> is a consequence of a decision to implement generics via type erasure, essentially closing the door on any possibility of using primitives inside generics. It is that same decision that made it necessary to create the <code>DoubleStream</code>, <code>IntStream</code>, and <code>LongStream</code> family of classes - to provide a stream-based unboxing.</p>\n\n<blockquote>\n  <p>Is there some way to squeeze autoboxing in to make this shorter? Or is this just the current state of the art?</p>\n</blockquote>\n\n<p>Unfortunately, not at this time: although it is theoretically possible for the compiler to figure out that <code>Stream&lt;Double&gt;</code> can be converted to <code>DoubleStream</code> implicitly, in the same way that the primitives are unboxed, this has not been done.</p>\n\n<p>As far as your array-based solution goes, it is the most efficient of the three. However, it is not as flexible as the other two: the one with <code>mapToDouble</code> lets you sum any attribute of a custom class, while the last one lets you perform other types of aggregation.</p>\n\n<blockquote>\n  <p><code>reduce(....)</code> is so much longer than <code>sum()</code></p>\n</blockquote>\n\n<p>I agree, this approach is worse than <code>mapToDouble</code> in terms of readability.</p>\n    "},{"t":"How to get milliseconds from LocalDateTime in Java 8","l":"http://stackoverflow.com/questions/23944370/how-to-get-milliseconds-from-localdatetime-in-java-8","q":"\n\n<p>I am wondering if there is a way to get current milliseconds since 1-1-1970 (epoch) using the new <code>LocalDate</code>, <code>LocalTime</code> or <code>LocalDateTime</code> classes of Java 8.</p>\n\n<p>The known way is below:  </p>\n\n<pre><code>long currentMilliseconds = new Date().getTime();\n</code></pre>\n\n<p>or</p>\n\n<pre><code>long currentMilliseconds = System.currentTimeMillis();\n</code></pre>\n    ","a":"\n<p>I'm not entirely sure what you mean by \"current milliseconds\" but I'll assume it's the number of milliseconds since the \"epoch,\" namely midnight, January 1, 1970 UTC.</p>\n\n<p>If you want to find the number of milliseconds since the epoch <em>right now,</em> then use <code>System.currentTimeMillis()</code> as <a href=\"http://stackoverflow.com/a/23944399/1441122\">Anubian Noob has pointed out</a>. If so, there's no reason to use any of the new java.time APIs to do this.</p>\n\n<p>However, maybe you already have a <code>LocalDateTime</code> or similar object from somewhere and you want to convert it to milliseconds since the epoch. It's not possible to do that directly, since the <code>LocalDateTime</code> family of objects has no notion of what time zone they're in. Thus time zone information needs to be supplied to find the time relative to the epoch, which is in UTC.</p>\n\n<p>Suppose you have a <code>LocalDateTime</code> like this:</p>\n\n<pre><code>LocalDateTime ldt = LocalDateTime.of(2014, 5, 29, 18, 41, 16);\n</code></pre>\n\n<p>You need to apply the time zone information, giving a <code>ZonedDateTime</code>. I'm in the same time zone as Los Angeles, so I'd do something like this:</p>\n\n<pre><code>ZonedDateTime zdt = ldt.atZone(ZoneId.of(\"America/Los_Angeles\"));\n</code></pre>\n\n<p>Of course, this makes assumptions about the time zone. And there are edge cases that can occur, for example, if the local time happens to name a time near the Daylight Saving Time (Summer Time) transition. Let's set these aside, but you should be aware that these cases exist.</p>\n\n<p>Anyway, if you can get a valid <code>ZonedDateTime</code>, you can convert this to the number of milliseconds since the epoch, like so:</p>\n\n<pre><code>long millis = zdt.toInstant().toEpochMilli();\n</code></pre>\n    "},{"t":"Using Java 7 Comparators in Java 8","l":"http://stackoverflow.com/questions/22572762/using-java-7-comparators-in-java-8","q":"\n\n<p><strong>Situation</strong></p>\n\n<p>I have an OSGi project that I'm trying to migrate to Java 8. In my project, I have dependencies to third party libraries that I \"OSGi-fied\" (by just adding the <code>MANIFEST.MF</code> file and putting metadata into it). These libraries are checked out from read-only SVN repositories, so I just can checkout updates from then when needed and therefore I don't want to make any other changes than in the <code>MANIFEST.MF</code> file, since I <strong>cannot</strong> commit them.</p>\n\n<p><strong>Problem</strong></p>\n\n<p>However, these libraries use lots of anonymous Comparators like:</p>\n\n<pre><code>private static final Comparator heightComparator = new Comparator() {\n    public int compare (Object o1, Object o2) {\n        return ((Glyph)o1).getHeight() - ((Glyph)o2).getHeight();\n    }\n};\n</code></pre>\n\n<p>Now, apparently the <code>java.util.Comparator</code> interface has a whole bunch of new methods that need to be implemented (which, of course, leads to compilation errors). But i really want to avoid implementing them or switch to Lambda expressions because modifying the original source would most likely result in conflicts each time I check out newer revisions.</p>\n\n<p>Java used to work hard on backwards compatibility and I wonder why such a simple and widely used part of the API needs so (relatively) much effort to migrate. Am I missing something or is it really unavoidable?</p>\n    ","a":"\n<p>The new methods in the Java 8 version of <code>Comparator</code> are <strong>default methods</strong> (a new feature in Java 8) which not only include the method signature, but also a default implementation. Thus, older <code>Comparator</code> implementations should work just fine on Java 8 if they worked before.</p>\n\n<p>If something is not working, please let us know what you are trying and what the error message is.</p>\n    "},{"t":"NumberFormat rounding issue with Java 8 only","l":"http://stackoverflow.com/questions/24426438/numberformat-rounding-issue-with-java-8-only","q":"\n\n<p>Can somebody explain to me why the following code:</p>\n\n<pre><code>public class Test {\n    public static void main(String... args) {\n        round(6.2088, 3);\n        round(6.2089, 3);\n    }\n\n    private static void round(Double num, int numDecimal) {\n        System.out.println(\"BigDecimal: \" + new BigDecimal(num).toString());\n\n        // Use Locale.ENGLISH for '.' as decimal separator\n        NumberFormat nf = NumberFormat.getInstance(Locale.ENGLISH);\n        nf.setGroupingUsed(false);\n        nf.setMaximumFractionDigits(numDecimal);\n        nf.setRoundingMode(RoundingMode.HALF_UP);\n\n        if(Math.abs(num) - Math.abs(num.intValue()) != 0){\n            nf.setMinimumFractionDigits(numDecimal);\n        }\n\n        System.out.println(\"Formatted: \" + nf.format(num));\n    }\n}\n</code></pre>\n\n<p>gives the following output?</p>\n\n<pre><code>[me@localhost trunk]$ java Test\nBigDecimal: 6.208800000000000096633812063373625278472900390625\nFormatted: 6.209\nBigDecimal: 6.208899999999999863575794734060764312744140625\nFormatted: 6.208\n</code></pre>\n\n<p>In case you don't see it: \"6.2089\" rounded to 3 digits gives the output \"6.208\" while \"6.2088\" gives \"6.209\" as output. Less is more?</p>\n\n<p>The results were good when using Java 5, 6 or 7 but this Java 8 gives me this strange output.\nJava version:</p>\n\n<pre><code>[me@localhost trunk]$ java -version\njava version \"1.8.0_05\"\nJava(TM) SE Runtime Environment (build 1.8.0_05-b13)\nJava HotSpot(TM) Server VM (build 25.5-b02, mixed mode)\n</code></pre>\n\n<p>EDIT: this is Java 7's output:</p>\n\n<pre><code>[me@localhost trunk]$ java Test\nBigDecimal: 6.208800000000000096633812063373625278472900390625\nFormatted: 6.209\nBigDecimal: 6.208899999999999863575794734060764312744140625\nFormatted: 6.209\n</code></pre>\n\n<p>Java 7 version:</p>\n\n<pre><code>[me@localhost trunk]$ java -version\njava version \"1.7.0_51\"\nJava(TM) SE Runtime Environment (build 1.7.0_51-b13)\nJava HotSpot(TM) Server VM (build 24.51-b03, mixed mode)\n</code></pre>\n    ","a":"\n<p>I could track down this issue to class <code>java.text.DigitList</code> line 522.</p>\n\n<p>The situation is that it thinks the decimal digits <code>6.0289</code> are already rounded (which is correct when comparing to the equivalent <code>BigDecimal</code> representation <code>6.208899…</code>) and decides to not round up again. The problem is that this decision makes sense only in the case that the digit resulting from rounding up is <code>5</code>, not when it is bigger than <code>5</code>. Note how the code for <code>HALF_DOWN</code> correctly differentiates between the <code>digit=='5'</code> and <code>digit&gt;'5'</code> case.</p>\n\n<p>This is a bug, obviously, and a strange one given the fact that the code for doing similar right (just for the other direction) is right below the broken one.</p>\n\n<pre><code>        case HALF_UP:\n            if (digits[maximumDigits] &gt;= '5') {\n                // We should not round up if the rounding digits position is\n                // exactly the last index and if digits were already rounded.\n                if ((maximumDigits == (count - 1)) &amp;&amp;\n                    (alreadyRounded))\n                    return false;\n\n                // Value was exactly at or was above tie. We must round up.\n                return true;\n            }\n            break;\n        case HALF_DOWN:\n            if (digits[maximumDigits] &gt; '5') {\n                return true;\n            } else if (digits[maximumDigits] == '5' ) {\n                if (maximumDigits == (count - 1)) {\n                    // The rounding position is exactly the last index.\n                    if (allDecimalDigits || alreadyRounded)\n                        /* FloatingDecimal rounded up (value was below tie),\n                         * or provided the exact list of digits (value was\n                         * an exact tie). We should not round up, following\n                         * the HALF_DOWN rounding rule.\n                         */\n                        return false;\n                    else\n                        // Value was above the tie, we must round up.\n                        return true;\n                }\n\n                // We must round up if it gives a non null digit after '5'.\n                for (int i=maximumDigits+1; i&lt;count; ++i) {\n                    if (digits[i] != '0') {\n                        return true;\n                    }\n                }\n            }\n            break;\n</code></pre>\n\n<p>The reason why this doesn’t happen to the other number is that <code>6.2088</code> is not the result of rounding up (again, compare to the <code>BigDecimal</code> output <code>6.208800…</code>). So in this case it will round up.</p>\n    "},{"t":"Java 8 forEach with index [duplicate]","l":"http://stackoverflow.com/questions/22793006/java-8-foreach-with-index","q":"\n\n<div class=\"question-status question-originals-of-duplicate\">\n    <p>This question already has an answer here:</p>\n    <ul>\n        <li>\n            <a href=\"/questions/18552005/is-there-a-concise-way-to-iterate-over-a-stream-with-indices-in-java-8\" dir=\"ltr\">Is there a concise way to iterate over a stream with indices in Java 8?</a>\n                <span class=\"question-originals-answer-count\">\n                    6 answers\n                </span>\n        </li>\n    </ul>\n</div>\n<p>Is there a way to build a forEach method in Java 8 that iterates with an index? Ideally I'd like something like this:</p>\n\n<pre><code>params.forEach((idx, e) -&gt; query.bind(idx, e));\n</code></pre>\n\n<p>The best I could do right now is:</p>\n\n<pre><code>int idx = 0;\nparams.forEach(e -&gt; {\n  query.bind(idx, e);\n  idx++;\n});\n</code></pre>\n    ","a":"\n<p>Since you are iterating over an indexable collection (lists, etc.), I presume that you can then just iterate with the indices of the elements:</p>\n\n<pre><code>IntStream.range(0, params.size())\n  .forEach(idx -&gt;\n    query.bind(\n      idx,\n      params.get(idx)\n    )\n  )\n;\n</code></pre>\n\n<p>The resulting code is similar to iterating a list with the classic i++-style for loop, except with easier parallelizability (assuming, of course, that concurrent read-only access to params is safe).</p>\n    "},{"t":"Functional style of Java 8's Optional.ifPresent and if-not-Present?","l":"http://stackoverflow.com/questions/23773024/functional-style-of-java-8s-optional-ifpresent-and-if-not-present","q":"\n\n<p>in java 8 , I want to do something to an optional object if it is present , and do another thing if it is not present.</p>\n\n<pre><code>if (opt.isPresent())\n  System.out.println(\"found\");\nelse\n  System.out.println(\"Not found\");\n</code></pre>\n\n<p>But I think it is not so 'function style'</p>\n\n<p>Optional has an '<code>ifPresent</code>' method , but unable to chain a '<code>orElse</code>' method.\nSo I cannot write :</p>\n\n<pre><code>opt.ifPresent( x -&gt; System.out.println(\"found \" + x))\n   .orElse( System.out.println(\"NOT FOUND\"));\n</code></pre>\n\n<p>Is there any other way ?</p>\n\n<p>=============================================</p>\n\n<p>Thanks @assylias , but I don't think Optional.map() works for the following case :</p>\n\n<pre><code>opt.map( o -&gt; {\n  System.out.println(\"while opt is present...\");\n  o.setProperty(xxx);\n  dao.update(o);\n  return null;\n}).orElseGet( () -&gt; {\n  System.out.println(\"create new obj\");\n  dao.save(new obj);\n  return null;\n});\n</code></pre>\n\n<p>In this case , when opt is present , I update its property and save to db; while it is not available , I create a new obj and save to db.</p>\n\n<p>Note in the two lambdas , I have to return null.</p>\n\n<p>But when opt is truly present , both lambdas will be executed. object will be updated , and a new object will be saved to db . This is because the <code>return null</code> in the first lambda. And orElseGet() will continue to execute.</p>\n    ","a":"\n<p>For me the answer of @Dane White is OK, first I did not like using Runnable but I could not find any alternatives, here another implementation I preferred more</p>\n\n<pre><code>public class OptionalConsumer&lt;T&gt; {\n    private Optional&lt;T&gt; optional;\n\n    private OptionalConsumer(Optional&lt;T&gt; optional) {\n        this.optional = optional;\n    }\n\n    public static &lt;T&gt; OptionalConsumer&lt;T&gt; of(Optional&lt;T&gt; optional) {\n        return new OptionalConsumer&lt;&gt;(optional);\n    }\n\n    public OptionalConsumer&lt;T&gt; ifPresent(Consumer&lt;T&gt; c) {\n        optional.ifPresent(c);\n        return this;\n    }\n\n    public OptionalConsumer&lt;T&gt; ifNotPresent(Runnable r) {\n        if (!optional.isPresent())\n            r.run();\n        return this;\n    }\n}\n</code></pre>\n\n<p>Then :</p>\n\n<pre><code>Optional&lt;Any&gt; o = Optional.of(...);\nOptionalConsumer.of(o).ifPresent(s -&gt;System.out.println(\"isPresent \"+s))\n            .ifNotPresent(() -&gt; System.out.println(\"! isPresent\"));\n</code></pre>\n    "},{"t":"Take every nth element from a Java 8 stream","l":"http://stackoverflow.com/questions/31602425/take-every-nth-element-from-a-java-8-stream","q":"\n\n<p>Suppose I have a list like this :</p>\n\n<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre>\n\n<p>Is it possible to use a Java 8 stream to take every second element from this list to obtain the following?</p>\n\n<pre><code>[1, 3, 5, 7, 9]\n</code></pre>\n\n<p>Or maybe even every third element?</p>\n\n<pre><code>[1, 4, 7, 10]\n</code></pre>\n\n<p>Basically, I'm looking for a function to take every nth element of a stream:</p>\n\n<pre><code>List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nList&lt;Integer&gt; list2 = list.stream().takenth(3).collect(Collectors.toList());\nSystem.out.println(list2);\n// =&gt; [1, 4, 7, 10]\n</code></pre>\n    ","a":"\n<p>One of the prime motivations for the introduction of Java streams was to allow parallel operations. This led to a requirement that operations on Java streams such as <code>map</code> and <code>filter</code> be independent of the position of the item in the stream or the items around it. This has the advantage of making it easy to split streams for parallel processing. It has the disadvantage of making certain operations more complex.</p>\n\n<p>So the simple answer is that there is no easy way to do things such as take every nth item or map each item to the sum of all previous items.</p>\n\n<p>The most straightforward way to implement your requirement is to use the index of the list you are streaming from:</p>\n\n<pre><code>List&lt;String&gt; list = ...;\nreturn IntStream.range(0, list.size())\n    .filter(n -&gt; n % 3 == 0)\n    .mapToObj(list::get)\n    .collect(Collectors.toList());\n</code></pre>\n\n<p>A more complicated solution would be to create a custom collector that collects every nth item into a list. </p>\n\n<pre><code>class EveryNth&lt;C&gt; {\n\n    private final int n;\n    private final List&lt;List&lt;C&gt;&gt; lists = new ArrayList&lt;&gt;();\n    private int next = 0;\n\n    public EveryNth(int n) {\n        this.n = n;\n        IntStream.range(0, n).forEach(i -&gt; lists.add(new ArrayList&lt;&gt;()));\n    }\n\n    public void accept(C item) {\n        lists.get(next++ % n).add(item);\n    }\n\n    public EveryNth&lt;C&gt; combine(EveryNth&lt;C&gt; other) {\n        other.lists.forEach(l -&gt; lists.get(next++ % n).addAll(l));\n        next += other.next;\n        return this;\n    }\n\n    public List&lt;C&gt; getResult() {\n        return lists.get(0);\n    }\n}\n</code></pre>\n\n<p>This could be used as follows:</p>\n\n<pre><code>List&lt;String&gt; list = Arrays.asList(\"Anne\", \"Bill\", \"Chris\", \"Dean\", \"Eve\", \"Fred\", \"George\");\nlist.stream().parallel()\n    .collect(Collector.of(() -&gt; new EveryNth(3), EveryNth::accept, EveryNth::combine, EveryNth::getResult))\n    .stream().forEach(System.out::println);\n</code></pre>\n\n<p>Which returns the result you would expect.</p>\n\n<p>This is a very inefficient algorithm even with parallel processing. It splits all items it accepts into n lists and then just returns the first. Unfortunately it has to keep all items through the accumulation process because it's not until they are combined that it knows which list is the nth one. Given its complexity and inefficiency I would definitely recommending sticking with the indices based solution above in preference to this.</p>\n    "},{"t":"Apply JDK 8 Consumer on String","l":"http://stackoverflow.com/questions/31068203/apply-jdk-8-consumer-on-string","q":"\n\n<p>I have a question regarding Java 8. Here is my source code:</p>\n\n<pre><code>final Consumer&lt;String&gt; d = e -&gt; System.out.println(e);\nfinal Function&lt;String, String&gt; upper = x -&gt; x.toUpperCase();\nfinal Function&lt;String, String&gt; lower = x -&gt; x.toLowerCase();\n\nnew Thread(() -&gt; d.accept(upper.apply(\"hello 1\"))).run();\nnew Thread(() -&gt; d.accept(lower.apply(\"hello 2\"))).run();\n</code></pre>\n\n<p>This works quite well and produces following output:</p>\n\n<pre><code>HELLO 1\nhello 2\n</code></pre>\n\n<p>My question is now if the syntax above <code>d.accept</code> and <code>upper.apply</code> is the only possible one or if there is some more \"java 8 lambda\" style we could write the last two lines. </p>\n    ","a":"\n<p>Before saying anything about about lambda expressions or functional interfaces, we have to talk about your really problematic mistake: <em>you are calling</em> <code>run()</code> <em>on a thread!</em> If you want to start a new thread, you have to call <code>start()</code> on the <code>Thread</code> instance, if you want to run the code sequentially, don’t create a <code>Thread</code> (but just a <code>Runnable</code>).</p>\n\n<p>That said, there are some <code>default</code> method on the functional interfaces of Java&nbsp;8 for combining functions, e.g. you can chain two <code>Function</code>s via <a href=\"http://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#andThen-java.util.function.Function-\"><code>Function.andThen(…)</code></a> but the available combinations are far away from being complete.</p>\n\n<p>If a certain combining task repeats in your application, you may consider creating utility methods:</p>\n\n<pre><code>public static &lt;T&gt; Runnable bind(T value, Consumer&lt;T&gt; c) {\n    return ()-&gt;c.accept(value);\n}\npublic static &lt;T,U&gt; Consumer&lt;U&gt; compose(Function&lt;U,T&gt; f, Consumer&lt;? super T&gt; c) {\n    return u-&gt;c.accept(f.apply(u));\n}\n</code></pre>\n\n<p>&nbsp;</p>\n\n<pre><code>new Thread(bind(\"Hello 1\", compose(upper, d))).start();\nnew Thread(bind(\"Hello 2\", compose(lower, d))).start();\n</code></pre>\n\n<p>But these three parts look more like a task for the stream API:</p>\n\n<pre><code>Stream.of(\"Hello 1\").map(upper).forEach(d);\nStream.of(\"Hello 2\").map(lower).forEach(d);\n</code></pre>\n\n<p>I left the creation of the new thread out here, as it hasn’t any benefit anyway.</p>\n\n<p>If you really want parallel processing, you can do it on a per-character basis:</p>\n\n<pre><code>\"Hello 1\".chars().parallel()\n  .map(Character::toUpperCase).forEachOrdered(c-&gt;System.out.print((char)c));\n</code></pre>\n\n<p>but there still won’t be any benefit given the simplicity of the task and the fixed overhead of the parallel processing.</p>\n    "},{"t":"Parsing and Translating Java 8 lambda expressions","l":"http://stackoverflow.com/questions/25989449/parsing-and-translating-java-8-lambda-expressions","q":"\n\n<p>In C# you can enclose a lambda expression in an expression tree object and then possibly <a href=\"http://msdn.microsoft.com/en-us/library/bb397951.aspx\">parse it</a>. I was wondering if this is also possible in Java?</p>\n\n<p>What I'm looking for is doing something like this:</p>\n\n<pre><code>BooksRepository.getAll()\n.where(b -&gt; b.getIban() == \"SomeIban\")\n.and(b -&gt; b.getAuthor() == \"SomeAuthor\"); //etc.\n</code></pre>\n\n<p>And then the <code>BooksRepository</code> should somehow translate that query to the following RESTful API request based on the predicates specified as lambdas:</p>\n\n<pre><code>GET http://mylibrary.com/books?Iban=SomeIban&amp;Author=SomeAuthor\n</code></pre>\n\n<p>and then return the result to the client. Any idea if this is even possible in Java?</p>\n    ","a":"\n<p>Yes, it's possible. I made a library that does exactly that: <a href=\"https://github.com/TrigerSoft/jaque\" rel=\"nofollow\" title=\"JaQue\">JaQue</a></p>\n    "},{"t":"Justification for using a bitfield instead of EnumSet in modern Java 8 API","l":"http://stackoverflow.com/questions/22596495/justification-for-using-a-bitfield-instead-of-enumset-in-modern-java-8-api","q":"\n\n<p><code>EnumSet</code>, as old as the <code>enum</code> itself (both since Java 5), is supposed to be a noncompromizing replacement for the use case of bitfields: as fast and lean as the bitfield (well, except for not being a primitive type), and typesafe to boot. On the other hand, the most recent and for years the most anticipated Java API—the Streams API—unashamedly employs bitfields for <code>Spliterator</code>'s <a href=\"http://download.java.net/jdk8/docs/api/java/util/Spliterator.html#characteristics--\">characteristics</a>.</p>\n\n<p>Should I consider the above as a clear admission by the core Java experts that <code>EnumSet</code> is not that good after all? Should I reconsider the common best-practice advice to never use bitfields?</p>\n    ","a":"\n<p>Was rather suprised to see that it is using bitfields rather than <code>EnumSet</code>. The rational though is discussed in <a href=\"http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008920.html\">this mailing list thread.</a> It seems like the reason was to be able to set and unset various characteristics without affecting the one on the caller end. With an <code>EnumSet</code>, to implement this, one would need to create a new <code>EnumSet</code> object every time there is a need to change it in different stages. I guess this is the reason why bit fields wins the race there.</p>\n\n<p>The concluding sentence of that thread essentially anticipates your question here:</p>\n\n<blockquote>\n  <p>The presence of such flags in a Java 8 API would (and should) raise a lot\n  of eyebrows, because it goes against what people have been told for well\n  over a decade. If it's adopted as is, there had better be a good\n  explanation for doc readers of why alternatives were rejected. \"We were\n  comfortable with int flags and nothing else significantly better suggested\n  itself\" won't cut it. \"We know int flags aren't great for an API, but we\n  tried very hard to find better alternatives, to no avail\" would (if it were\n  true).</p>\n</blockquote>\n    "},{"t":"Ambiguous method in Java 8, why? [duplicate]","l":"http://stackoverflow.com/questions/29499847/ambiguous-method-in-java-8-why","q":"\n\n<div class=\"question-status question-originals-of-duplicate\">\n    <p>This question already has an answer here:</p>\n    <ul>\n        <li>\n            <a href=\"/questions/28466925/java-type-inference-reference-is-ambiguous-in-java-8-but-not-java-7\" dir=\"ltr\">Java type inference: reference is ambiguous in Java 8, but not Java 7</a>\n                <span class=\"question-originals-answer-count\">\n                    2 answers\n                </span>\n        </li>\n    </ul>\n</div>\n<pre><code>public static void main(String... args){\n    then(bar()); // Compilation Error\n}\n\npublic static &lt;E extends Exception&gt; E bar() {\n    return null;\n}\n\npublic static void then(Throwable actual) { }\n\npublic static void then(CharSequence actual) { }\n</code></pre>\n\n<p>Compilation result (from command line <code>javac Ambiguous.java</code>)</p>\n\n<pre><code>Ambiguous.java:4: error: reference to then is ambiguous\n        then(bar());\n        ^\n  both method then(Throwable) in Ambiguous and method then(CharSequence) in Ambiguous match\n1 error\n</code></pre>\n\n<p>Why this method is ambiguous? This code compile with success under Java 7!</p>\n\n<p>After changing method bar to:</p>\n\n<pre><code>public static &lt;E extends Float&gt; E bar() {\n    return null;\n}\n</code></pre>\n\n<p>This compiles without any problems, but is reported as error in IntelliJ Idea (Cannot resolve method <code>then(java.lang.FLoat)</code>).</p>\n\n<p>This code fails under Java 7 - <code>javac -source 1.7 Ambiguous.java</code>:</p>\n\n<pre><code>Ambiguous.java:4: error: no suitable method found for then(Float)\n        then(bar());\n        ^\n    method Ambiguous.then(Throwable) is not applicable\n      (argument mismatch; Float cannot be converted to Throwable)\n    method Ambiguous.then(CharSequence) is not applicable\n      (argument mismatch; Float cannot be converted to CharSequence)\n1 error\n</code></pre>\n\n<p>Java version</p>\n\n<pre><code>java version \"1.8.0_40\"\nJava(TM) SE Runtime Environment (build 1.8.0_40-b25)\nJava HotSpot(TM) 64-Bit Server VM (build 25.40-b25, mixed mode)\n</code></pre>\n    ","a":"\n<p>Consider the following class:</p>\n\n<pre><code>public class Foo extends Exception implements CharSequence {\n    //...\n}\n</code></pre>\n\n<p>The class <code>Foo</code> implements both <code>Throwable</code> and <code>CharSequence</code>. So in case <code>E</code> is set to this instance, the Java compiler does not know which method to call.</p>\n\n<p>The reason there is probably no problem for <em>Java7</em> is that generics are less implemented. In case you don't provide an <code>E</code> yourself (e.g. <code>(Foo) bar()</code>), Java will fall back on the basic verion of <code>E</code> which is <code>implements Exception</code>, <code>E</code> is thus only considered to be an instance of <code>Exception</code>.</p>\n\n<p>In <a href=\"http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html\" rel=\"nofollow\"><em>Java8</em></a>, the <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html\" rel=\"nofollow\"><em>type inference</em> is improved</a>, the type of <code>E</code> is now derived from the parameter called for by <code>then()</code>, in other words the compiler first looks what possible types <code>then()</code> needs, the problem is that they both are valid choices. So in that case it becomes ambiguous.</p>\n\n<hr>\n\n<p><strong>Proof of concept</strong>:</p>\n\n<p>Now we will slightly modify your code and show how ambiguous calls are resolved:</p>\n\n<p>Say we modify the code to:</p>\n\n<pre><code>public class Main {\n    public static void main(String... args){\n        then(bar()); // Compilation Error\n    }\n    public static &lt;E extends Exception&gt; E bar() {\n        return null;\n    }\n    public static void then(CharSequence actual) {\n        System.out.println(\"char\");\n    }\n}\n</code></pre>\n\n<p>If you run this in <strong>Java8</strong>, there is no problem (it prints <code>char</code>), because Java8 simply assumes there is such class <code>Foo</code> (it created some kind of \"inner\" type for it that derived from both).</p>\n\n<p>Running this in <strong>Java7</strong> yields problems:</p>\n\n<pre><code>/MyClass.java:18: error: method then in class MyClass cannot be applied to given types;\n    then(bar()); // Compilation Error\n    ^\n  required: CharSequence\n  found: Exception\n  reason: actual argument Exception cannot be converted to CharSequence by method invocation conversion\n1 error\n</code></pre>\n\n<p>It did a fallback on <code>Exception</code> and couldn't find a type that could deal with it.</p>\n\n<p>If you run the original code in <strong>Java8</strong>, it will error because of the ambiguous call, if you run it in <strong>Java7</strong> however, it will use the <code>Throwable</code> method.</p>\n\n<hr>\n\n<p>In short: <em>the compiler aims to \"guess\" what <code>E</code> is in Java8, whereas in Java7 the most conservative type was picked.</em></p>\n    "},{"t":"Does Grails 2.3.x Support JDK 8","l":"http://stackoverflow.com/questions/22517916/does-grails-2-3-x-support-jdk-8","q":"\n\n<p>It seems like this questions should be easy but the installation requirements for Grails (<a href=\"http://www.grails.org/Installation\">http://www.grails.org/Installation</a>) haven't been updated in 2 years.  Does anyone know for sure is Grails 2.3 will run on JDK 8?</p>\n    ","a":"\n<p>As noticed by <a href=\"http://stackoverflow.com/users/92063/heikkim\">heikkim</a> this ticket which is now closed suggests that support for Java 8 will start on Grails 2.4:</p>\n\n<p><a href=\"http://jira.grails.org/browse/GRAILS-11063\">http://jira.grails.org/browse/GRAILS-11063</a> (title: Java 8 support)</p>\n    "},{"t":"Understanding typesafety anomaly with Java generics [duplicate]","l":"http://stackoverflow.com/questions/29827947/understanding-typesafety-anomaly-with-java-generics","q":"\n\n<div class=\"question-status question-originals-of-duplicate\">\n    <p>This question already has an answer here:</p>\n    <ul>\n        <li>\n            <a href=\"/questions/27606449/how-exactly-do-generics-work\" dir=\"ltr\">How exactly do Generics work?</a>\n                <span class=\"question-originals-answer-count\">\n                    2 answers\n                </span>\n        </li>\n    </ul>\n</div>\n<p>I have following code:</p>\n\n<pre><code>public static void main(String[] args) {\n    List&lt;String&gt; s = new ArrayList&lt;String&gt;();\n    s.add(\"kshitiz\");\n\n    //This is not typesafe. It should blow up at runtime\n    List&lt;Integer&gt; i = new ArrayList(s);\n    System.out.println(i.get(0));\n}\n</code></pre>\n\n<p>This program runs fine and it prints <code>kshitiz</code>. It only fails if I replace the last line with: </p>\n\n<pre><code>System.out.println(i.get(0).getClass());\n</code></pre>\n\n<p>Exception:</p>\n\n<pre><code>Exception in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n</code></pre>\n\n<p>What is happening here?</p>\n    ","a":"\n<p>I guess you are aware, that generic types are gone at run time. Now, to see what's happening behind the scenes, let's look at this piece of code</p>\n\n<pre><code>public static Class&lt;?&gt; getClass(final Object object) {\n    return object.getClass();\n}\n\npublic static void main(final String[] args) {\n    final List&lt;String&gt; s = new ArrayList&lt;String&gt;();\n    s.add(\"kshitiz\");\n\n    // This is not typesafe. It should blow up at runtime\n    final List&lt;Integer&gt; i = new ArrayList(s);\n    System.out.println(getClass(i.get(0)));\n    System.out.println(i.get(0).getClass());\n}\n</code></pre>\n\n<p>and the output of javap -c</p>\n\n<pre><code>  [...]\n  26: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;\n  29: aload_2\n  30: iconst_0\n  31: invokeinterface #9,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;\n  36: invokestatic  #10                 // Method getClass:(Ljava/lang/Object;)Ljava/lang/Class;\n  39: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n  42: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;\n  45: aload_2\n  46: iconst_0\n  47: invokeinterface #9,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;\n  52: checkcast     #12                 // class java/lang/Integer\n  55: invokevirtual #2                  // Method java/lang/Object.getClass:()Ljava/lang/Class;\n  58: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n  61: return\n</code></pre>\n\n<p>So you see that in the second call, the String is cast to an Integer, while in the first case, it is regarded as an object.\nThus as long as the String is handled just like any other object, everything is fine, but as soon as you call a method of the element type of the list, the object is cast to that type.</p>\n    "},{"t":"Possibility to explicit remove Serialization support for a lambda","l":"http://stackoverflow.com/questions/25443655/possibility-to-explicit-remove-serialization-support-for-a-lambda","q":"\n\n<p>As <a href=\"http://stackoverflow.com/a/22808112/2711488\">already known</a> it’s easy to add <em>Serialization</em> support to a lambda expression when the target interface does not already inherit <code>Serializable</code>, just like <code>(TargetInterface&amp;Serializable)()-&gt;{/*code*/}</code>.</p>\n\n<p>What I ask for, is a way to do the opposite, explicitly remove Serialization support when the target interface <em>does</em> inherit <code>Serializable</code>.</p>\n\n<p>Since you can’t remove an interface from a type a language-based solution would possibly look like <code>(@NotSerializable TargetInterface)()-&gt;{/* code */}</code>. But as far as I know, there is no such solution. (Correct me if I’m wrong, that would be a perfect answer)</p>\n\n<p>Denying the serialization even when the class implements <code>Serializable</code> was a legitimate behavior in the past and with classes under the programmers control, the pattern would look like:</p>\n\n<pre><code>public class NotSupportingSerialization extends SerializableBaseClass {\n    private void writeObject(java.io.ObjectOutputStream out) throws IOException {\n      throw new NotSerializableException();\n    }\n    private void readObject(java.io.ObjectInputStream in)\n      throws IOException, ClassNotFoundException {\n      throw new NotSerializableException();\n    }\n    private void readObjectNoData() throws ObjectStreamException {\n      throw new NotSerializableException();\n    }\n}\n</code></pre>\n\n<p>But for lambda expression, the programmer doesn’t have that control over the lambda class.</p>\n\n<hr>\n\n<p>Why would someone ever bother about removing the support? Well, beside the bigger code generated to include the <code>Serialization</code> support, it creates a security risk. Consider the following code:</p>\n\n<pre><code>public class CreationSite {\n    public static void main(String... arg) {\n        TargetInterface f=CreationSite::privateMethod;\n    }\n    private static void privateMethod() {\n        System.out.println(\"should be private\");\n    }\n}\n</code></pre>\n\n<p>Here, the access to the private method is not exposed even if the <code>TargetInterface</code> is <code>public</code> (interface methods are always <code>public</code>) as long as the programmer takes care, not to pass the instance <code>f</code> to untrusted code.</p>\n\n<p>However, things change if <code>TargetInterface</code> inherits <code>Serializable</code>. Then, even if the <code>CreationSite</code> never hands out an instance, an attacker could create an equivalent instance by de-serializing a manually constructed stream. If the interface for the above example looks like</p>\n\n<pre><code>public interface TargetInterface extends Runnable, Serializable {}\n</code></pre>\n\n<p>it’s as easy as:</p>\n\n<pre><code>SerializedLambda l=new SerializedLambda(CreationSite.class,\n    TargetInterface.class.getName().replace('.', '/'), \"run\", \"()V\",\n    MethodHandleInfo.REF_invokeStatic,\n    CreationSite.class.getName().replace('.', '/'), \"privateMethod\",\n    \"()V\", \"()V\", new Object[0]);\nByteArrayOutputStream os=new ByteArrayOutputStream();\ntry(ObjectOutputStream oos=new ObjectOutputStream(os)) { oos.writeObject(l);}\nTargetInterface f;\ntry(ByteArrayInputStream is=new ByteArrayInputStream(os.toByteArray());\n    ObjectInputStream ois=new ObjectInputStream(is)) {\n    f=(TargetInterface) ois.readObject();\n}\nf.run();// invokes privateMethod\n</code></pre>\n\n<p>Note that the attacking code does not contain any action that a <code>SecurityManager</code> would revoke.</p>\n\n<hr>\n\n<p>The decision to support Serialization is made at compile-time. It requires a synthetic factory method added to <code>CreationSite</code> and a <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html#FLAG_SERIALIZABLE\">flag</a> passed to the <a href=\"http://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html#altMetafactory-java.lang.invoke.MethodHandles.Lookup-java.lang.String-java.lang.invoke.MethodType-java.lang.Object...-\">metafactory</a> method. Without the flag, the generated lambda will not support Serialization even if the interface happens to inherit <code>Serializable</code>. The lambda class will even have a <code>writeObject</code> method like in the <code>NotSupportingSerialization</code> example above. And without the synthetic factory method, De-Serialization is impossible.</p>\n\n<p>This leads to the one solution, I found. You can create a copy of the interface and modify it to not inherit <code>Serializable</code>, then compile against that modified version. So when the real version at runtime happens to inherit <code>Serializable</code>, Serialization will still be revoked.</p>\n\n<p>Well, another solution is to never use lambda expressions/method references in security relevant code, at least if the target interface inherits <code>Serializable</code> which must always be re-checked, when compiling against a newer version of the interface.</p>\n\n<p>But I think there must be better, preferably in-language solutions.</p>\n    ","a":"\n<p>How to handle serializability was one of the biggest challenges for the EG; suffice it to say that there were no great solutions, only tradeoffs between various downsides.  Some parties insisted that all lambdas be automatically serializable (!); others insisted that lambdas never be serializable (which seemed an attractive idea at times, but sadly would badly violate user expectations.)  </p>\n\n<p>You note:</p>\n\n<blockquote>\n  <p>Well, another solution is to never use lambda expressions/method references in security relevant code, </p>\n</blockquote>\n\n<p>In fact, the serialization spec now says exactly that.  </p>\n\n<p>But, there is a fairly easy trick to do what you want here.  Suppose you have some library that wants serializable instances:</p>\n\n<pre><code>public interface SomeLibType extends Runnable, Serializable { }\n</code></pre>\n\n<p>with methods that expect this type:</p>\n\n<pre><code>public void gimmeLambda(SomeLibType r)\n</code></pre>\n\n<p>and you want to pass lambdas into it, but not have them be serializable (and take the consequences of that.)  So, write yourself this helper method:</p>\n\n<pre><code>public static SomeLibType launder(Runnable r) {\n    return new SomeLibType() {\n        public void run() { r.run(); }\n    }\n}\n</code></pre>\n\n<p>Now you can call the library method:</p>\n\n<pre><code>gimmeLambda(launder(() -&gt; myPrivateMethod()));\n</code></pre>\n\n<p>The compiler will convert your lambda into a non-serializable Runnable, and the laundering wrapper will wrap it with an instance that satisifies the type system.  When you try to serialize it, that will fail since <code>r</code> is not serializable.  More importantly, you can't forge access to the private method, because the $deserializeLambda$ support that's needed in the capturing class won't even be there.  </p>\n    "}]